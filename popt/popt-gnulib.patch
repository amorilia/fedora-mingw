diff -urN popt-for-windows/lib/alloca.c popt-for-windows-gnulib/lib/alloca.c
--- popt-for-windows/lib/alloca.c	1970-01-01 01:00:00.000000000 +0100
+++ popt-for-windows-gnulib/lib/alloca.c	2008-10-25 15:17:05.000000000 +0100
@@ -0,0 +1,489 @@
+/* alloca.c -- allocate automatically reclaimed memory
+   (Mostly) portable public-domain implementation -- D A Gwyn
+
+   This implementation of the PWB library alloca function,
+   which is used to allocate space off the run-time stack so
+   that it is automatically reclaimed upon procedure exit,
+   was inspired by discussions with J. Q. Johnson of Cornell.
+   J.Otto Tennant <jot@cray.com> contributed the Cray support.
+
+   There are some preprocessor constants that can
+   be defined when compiling for your specific system, for
+   improved efficiency; however, the defaults should be okay.
+
+   The general concept of this implementation is to keep
+   track of all alloca-allocated blocks, and reclaim any
+   that are found to be deeper in the stack than the current
+   invocation.  This heuristic does not reclaim storage as
+   soon as it becomes invalid, but it will do so eventually.
+
+   As a special case, alloca(0) reclaims storage without
+   allocating any.  It is a good idea to use alloca(0) in
+   your main control loop, etc. to force garbage collection.  */
+
+#include <config.h>
+
+#include <alloca.h>
+
+#include <string.h>
+#include <stdlib.h>
+
+#ifdef emacs
+# include "lisp.h"
+# include "blockinput.h"
+# ifdef EMACS_FREE
+#  undef free
+#  define free EMACS_FREE
+# endif
+#else
+# define memory_full() abort ()
+#endif
+
+/* If compiling with GCC 2, this file's not needed.  */
+#if !defined (__GNUC__) || __GNUC__ < 2
+
+/* If someone has defined alloca as a macro,
+   there must be some other way alloca is supposed to work.  */
+# ifndef alloca
+
+#  ifdef emacs
+#   ifdef static
+/* actually, only want this if static is defined as ""
+   -- this is for usg, in which emacs must undefine static
+   in order to make unexec workable
+   */
+#    ifndef STACK_DIRECTION
+you
+lose
+-- must know STACK_DIRECTION at compile-time
+/* Using #error here is not wise since this file should work for
+   old and obscure compilers.  */
+#    endif /* STACK_DIRECTION undefined */
+#   endif /* static */
+#  endif /* emacs */
+
+/* If your stack is a linked list of frames, you have to
+   provide an "address metric" ADDRESS_FUNCTION macro.  */
+
+#  if defined (CRAY) && defined (CRAY_STACKSEG_END)
+long i00afunc ();
+#   define ADDRESS_FUNCTION(arg) (char *) i00afunc (&(arg))
+#  else
+#   define ADDRESS_FUNCTION(arg) &(arg)
+#  endif
+
+/* Define STACK_DIRECTION if you know the direction of stack
+   growth for your system; otherwise it will be automatically
+   deduced at run-time.
+
+   STACK_DIRECTION > 0 => grows toward higher addresses
+   STACK_DIRECTION < 0 => grows toward lower addresses
+   STACK_DIRECTION = 0 => direction of growth unknown  */
+
+#  ifndef STACK_DIRECTION
+#   define STACK_DIRECTION	0	/* Direction unknown.  */
+#  endif
+
+#  if STACK_DIRECTION != 0
+
+#   define STACK_DIR	STACK_DIRECTION	/* Known at compile-time.  */
+
+#  else /* STACK_DIRECTION == 0; need run-time code.  */
+
+static int stack_dir;		/* 1 or -1 once known.  */
+#   define STACK_DIR	stack_dir
+
+static void
+find_stack_direction (void)
+{
+  static char *addr = NULL;	/* Address of first `dummy', once known.  */
+  auto char dummy;		/* To get stack address.  */
+
+  if (addr == NULL)
+    {				/* Initial entry.  */
+      addr = ADDRESS_FUNCTION (dummy);
+
+      find_stack_direction ();	/* Recurse once.  */
+    }
+  else
+    {
+      /* Second entry.  */
+      if (ADDRESS_FUNCTION (dummy) > addr)
+	stack_dir = 1;		/* Stack grew upward.  */
+      else
+	stack_dir = -1;		/* Stack grew downward.  */
+    }
+}
+
+#  endif /* STACK_DIRECTION == 0 */
+
+/* An "alloca header" is used to:
+   (a) chain together all alloca'ed blocks;
+   (b) keep track of stack depth.
+
+   It is very important that sizeof(header) agree with malloc
+   alignment chunk size.  The following default should work okay.  */
+
+#  ifndef	ALIGN_SIZE
+#   define ALIGN_SIZE	sizeof(double)
+#  endif
+
+typedef union hdr
+{
+  char align[ALIGN_SIZE];	/* To force sizeof(header).  */
+  struct
+    {
+      union hdr *next;		/* For chaining headers.  */
+      char *deep;		/* For stack depth measure.  */
+    } h;
+} header;
+
+static header *last_alloca_header = NULL;	/* -> last alloca header.  */
+
+/* Return a pointer to at least SIZE bytes of storage,
+   which will be automatically reclaimed upon exit from
+   the procedure that called alloca.  Originally, this space
+   was supposed to be taken from the current stack frame of the
+   caller, but that method cannot be made to work for some
+   implementations of C, for example under Gould's UTX/32.  */
+
+void *
+alloca (size_t size)
+{
+  auto char probe;		/* Probes stack depth: */
+  register char *depth = ADDRESS_FUNCTION (probe);
+
+#  if STACK_DIRECTION == 0
+  if (STACK_DIR == 0)		/* Unknown growth direction.  */
+    find_stack_direction ();
+#  endif
+
+  /* Reclaim garbage, defined as all alloca'd storage that
+     was allocated from deeper in the stack than currently.  */
+
+  {
+    register header *hp;	/* Traverses linked list.  */
+
+#  ifdef emacs
+    BLOCK_INPUT;
+#  endif
+
+    for (hp = last_alloca_header; hp != NULL;)
+      if ((STACK_DIR > 0 && hp->h.deep > depth)
+	  || (STACK_DIR < 0 && hp->h.deep < depth))
+	{
+	  register header *np = hp->h.next;
+
+	  free (hp);		/* Collect garbage.  */
+
+	  hp = np;		/* -> next header.  */
+	}
+      else
+	break;			/* Rest are not deeper.  */
+
+    last_alloca_header = hp;	/* -> last valid storage.  */
+
+#  ifdef emacs
+    UNBLOCK_INPUT;
+#  endif
+  }
+
+  if (size == 0)
+    return NULL;		/* No allocation required.  */
+
+  /* Allocate combined header + user data storage.  */
+
+  {
+    /* Address of header.  */
+    register header *new;
+
+    size_t combined_size = sizeof (header) + size;
+    if (combined_size < sizeof (header))
+      memory_full ();
+
+    new = malloc (combined_size);
+
+    if (! new)
+      memory_full ();
+
+    new->h.next = last_alloca_header;
+    new->h.deep = depth;
+
+    last_alloca_header = new;
+
+    /* User storage begins just after header.  */
+
+    return (void *) (new + 1);
+  }
+}
+
+#  if defined (CRAY) && defined (CRAY_STACKSEG_END)
+
+#   ifdef DEBUG_I00AFUNC
+#    include <stdio.h>
+#   endif
+
+#   ifndef CRAY_STACK
+#    define CRAY_STACK
+#    ifndef CRAY2
+/* Stack structures for CRAY-1, CRAY X-MP, and CRAY Y-MP */
+struct stack_control_header
+  {
+    long shgrow:32;		/* Number of times stack has grown.  */
+    long shaseg:32;		/* Size of increments to stack.  */
+    long shhwm:32;		/* High water mark of stack.  */
+    long shsize:32;		/* Current size of stack (all segments).  */
+  };
+
+/* The stack segment linkage control information occurs at
+   the high-address end of a stack segment.  (The stack
+   grows from low addresses to high addresses.)  The initial
+   part of the stack segment linkage control information is
+   0200 (octal) words.  This provides for register storage
+   for the routine which overflows the stack.  */
+
+struct stack_segment_linkage
+  {
+    long ss[0200];		/* 0200 overflow words.  */
+    long sssize:32;		/* Number of words in this segment.  */
+    long ssbase:32;		/* Offset to stack base.  */
+    long:32;
+    long sspseg:32;		/* Offset to linkage control of previous
+				   segment of stack.  */
+    long:32;
+    long sstcpt:32;		/* Pointer to task common address block.  */
+    long sscsnm;		/* Private control structure number for
+				   microtasking.  */
+    long ssusr1;		/* Reserved for user.  */
+    long ssusr2;		/* Reserved for user.  */
+    long sstpid;		/* Process ID for pid based multi-tasking.  */
+    long ssgvup;		/* Pointer to multitasking thread giveup.  */
+    long sscray[7];		/* Reserved for Cray Research.  */
+    long ssa0;
+    long ssa1;
+    long ssa2;
+    long ssa3;
+    long ssa4;
+    long ssa5;
+    long ssa6;
+    long ssa7;
+    long sss0;
+    long sss1;
+    long sss2;
+    long sss3;
+    long sss4;
+    long sss5;
+    long sss6;
+    long sss7;
+  };
+
+#    else /* CRAY2 */
+/* The following structure defines the vector of words
+   returned by the STKSTAT library routine.  */
+struct stk_stat
+  {
+    long now;			/* Current total stack size.  */
+    long maxc;			/* Amount of contiguous space which would
+				   be required to satisfy the maximum
+				   stack demand to date.  */
+    long high_water;		/* Stack high-water mark.  */
+    long overflows;		/* Number of stack overflow ($STKOFEN) calls.  */
+    long hits;			/* Number of internal buffer hits.  */
+    long extends;		/* Number of block extensions.  */
+    long stko_mallocs;		/* Block allocations by $STKOFEN.  */
+    long underflows;		/* Number of stack underflow calls ($STKRETN).  */
+    long stko_free;		/* Number of deallocations by $STKRETN.  */
+    long stkm_free;		/* Number of deallocations by $STKMRET.  */
+    long segments;		/* Current number of stack segments.  */
+    long maxs;			/* Maximum number of stack segments so far.  */
+    long pad_size;		/* Stack pad size.  */
+    long current_address;	/* Current stack segment address.  */
+    long current_size;		/* Current stack segment size.  This
+				   number is actually corrupted by STKSTAT to
+				   include the fifteen word trailer area.  */
+    long initial_address;	/* Address of initial segment.  */
+    long initial_size;		/* Size of initial segment.  */
+  };
+
+/* The following structure describes the data structure which trails
+   any stack segment.  I think that the description in 'asdef' is
+   out of date.  I only describe the parts that I am sure about.  */
+
+struct stk_trailer
+  {
+    long this_address;		/* Address of this block.  */
+    long this_size;		/* Size of this block (does not include
+				   this trailer).  */
+    long unknown2;
+    long unknown3;
+    long link;			/* Address of trailer block of previous
+				   segment.  */
+    long unknown5;
+    long unknown6;
+    long unknown7;
+    long unknown8;
+    long unknown9;
+    long unknown10;
+    long unknown11;
+    long unknown12;
+    long unknown13;
+    long unknown14;
+  };
+
+#    endif /* CRAY2 */
+#   endif /* not CRAY_STACK */
+
+#   ifdef CRAY2
+/* Determine a "stack measure" for an arbitrary ADDRESS.
+   I doubt that "lint" will like this much.  */
+
+static long
+i00afunc (long *address)
+{
+  struct stk_stat status;
+  struct stk_trailer *trailer;
+  long *block, size;
+  long result = 0;
+
+  /* We want to iterate through all of the segments.  The first
+     step is to get the stack status structure.  We could do this
+     more quickly and more directly, perhaps, by referencing the
+     $LM00 common block, but I know that this works.  */
+
+  STKSTAT (&status);
+
+  /* Set up the iteration.  */
+
+  trailer = (struct stk_trailer *) (status.current_address
+				    + status.current_size
+				    - 15);
+
+  /* There must be at least one stack segment.  Therefore it is
+     a fatal error if "trailer" is null.  */
+
+  if (trailer == 0)
+    abort ();
+
+  /* Discard segments that do not contain our argument address.  */
+
+  while (trailer != 0)
+    {
+      block = (long *) trailer->this_address;
+      size = trailer->this_size;
+      if (block == 0 || size == 0)
+	abort ();
+      trailer = (struct stk_trailer *) trailer->link;
+      if ((block <= address) && (address < (block + size)))
+	break;
+    }
+
+  /* Set the result to the offset in this segment and add the sizes
+     of all predecessor segments.  */
+
+  result = address - block;
+
+  if (trailer == 0)
+    {
+      return result;
+    }
+
+  do
+    {
+      if (trailer->this_size <= 0)
+	abort ();
+      result += trailer->this_size;
+      trailer = (struct stk_trailer *) trailer->link;
+    }
+  while (trailer != 0);
+
+  /* We are done.  Note that if you present a bogus address (one
+     not in any segment), you will get a different number back, formed
+     from subtracting the address of the first block.  This is probably
+     not what you want.  */
+
+  return (result);
+}
+
+#   else /* not CRAY2 */
+/* Stack address function for a CRAY-1, CRAY X-MP, or CRAY Y-MP.
+   Determine the number of the cell within the stack,
+   given the address of the cell.  The purpose of this
+   routine is to linearize, in some sense, stack addresses
+   for alloca.  */
+
+static long
+i00afunc (long address)
+{
+  long stkl = 0;
+
+  long size, pseg, this_segment, stack;
+  long result = 0;
+
+  struct stack_segment_linkage *ssptr;
+
+  /* Register B67 contains the address of the end of the
+     current stack segment.  If you (as a subprogram) store
+     your registers on the stack and find that you are past
+     the contents of B67, you have overflowed the segment.
+
+     B67 also points to the stack segment linkage control
+     area, which is what we are really interested in.  */
+
+  stkl = CRAY_STACKSEG_END ();
+  ssptr = (struct stack_segment_linkage *) stkl;
+
+  /* If one subtracts 'size' from the end of the segment,
+     one has the address of the first word of the segment.
+
+     If this is not the first segment, 'pseg' will be
+     nonzero.  */
+
+  pseg = ssptr->sspseg;
+  size = ssptr->sssize;
+
+  this_segment = stkl - size;
+
+  /* It is possible that calling this routine itself caused
+     a stack overflow.  Discard stack segments which do not
+     contain the target address.  */
+
+  while (!(this_segment <= address && address <= stkl))
+    {
+#    ifdef DEBUG_I00AFUNC
+      fprintf (stderr, "%011o %011o %011o\n", this_segment, address, stkl);
+#    endif
+      if (pseg == 0)
+	break;
+      stkl = stkl - pseg;
+      ssptr = (struct stack_segment_linkage *) stkl;
+      size = ssptr->sssize;
+      pseg = ssptr->sspseg;
+      this_segment = stkl - size;
+    }
+
+  result = address - this_segment;
+
+  /* If you subtract pseg from the current end of the stack,
+     you get the address of the previous stack segment's end.
+     This seems a little convoluted to me, but I'll bet you save
+     a cycle somewhere.  */
+
+  while (pseg != 0)
+    {
+#    ifdef DEBUG_I00AFUNC
+      fprintf (stderr, "%011o %011o\n", pseg, size);
+#    endif
+      stkl = stkl - pseg;
+      ssptr = (struct stack_segment_linkage *) stkl;
+      size = ssptr->sssize;
+      pseg = ssptr->sspseg;
+      result += size;
+    }
+  return (result);
+}
+
+#   endif /* not CRAY2 */
+#  endif /* CRAY */
+
+# endif /* no alloca */
+#endif /* not GCC version 3 */
diff -urN popt-for-windows/lib/alloca.in.h popt-for-windows-gnulib/lib/alloca.in.h
--- popt-for-windows/lib/alloca.in.h	1970-01-01 01:00:00.000000000 +0100
+++ popt-for-windows-gnulib/lib/alloca.in.h	2008-10-25 15:17:05.000000000 +0100
@@ -0,0 +1,56 @@
+/* Memory allocation on the stack.
+
+   Copyright (C) 1995, 1999, 2001-2004, 2006-2008 Free Software
+   Foundation, Inc.
+
+   This program is free software; you can redistribute it and/or modify it
+   under the terms of the GNU General Public License as published
+   by the Free Software Foundation; either version 3, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   General Public License for more details.
+
+   You should have received a copy of the GNU General Public
+   License along with this program; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,
+   USA.  */
+
+/* Avoid using the symbol _ALLOCA_H here, as Bison assumes _ALLOCA_H
+   means there is a real alloca function.  */
+#ifndef _GL_ALLOCA_H
+#define _GL_ALLOCA_H
+
+/* alloca (N) returns a pointer to N bytes of memory
+   allocated on the stack, which will last until the function returns.
+   Use of alloca should be avoided:
+     - inside arguments of function calls - undefined behaviour,
+     - in inline functions - the allocation may actually last until the
+       calling function returns,
+     - for huge N (say, N >= 65536) - you never know how large (or small)
+       the stack is, and when the stack cannot fulfill the memory allocation
+       request, the program just crashes.
+ */
+
+#ifndef alloca
+# ifdef __GNUC__
+#  define alloca __builtin_alloca
+# elif defined _AIX
+#  define alloca __alloca
+# elif defined _MSC_VER
+#  include <malloc.h>
+#  define alloca _alloca
+# elif defined __DECC && defined __VMS
+#  define alloca __ALLOCA
+# else
+#  include <stddef.h>
+#  ifdef  __cplusplus
+extern "C"
+#  endif
+void *alloca (size_t);
+# endif
+#endif
+
+#endif /* _GL_ALLOCA_H */
diff -urN popt-for-windows/lib/.cvsignore popt-for-windows-gnulib/lib/.cvsignore
--- popt-for-windows/lib/.cvsignore	1970-01-01 01:00:00.000000000 +0100
+++ popt-for-windows-gnulib/lib/.cvsignore	2008-10-25 15:17:05.000000000 +0100
@@ -0,0 +1,25 @@
+.deps
+.dirstamp
+Makefile.am
+alloca.c
+alloca.in.h
+dirent.in.h
+dirfd.c
+dummy.c
+fnmatch.c
+fnmatch.in.h
+fnmatch_loop.c
+getlogin_r.c
+glob-libc.h
+glob.c
+glob.in.h
+malloc.c
+mempcpy.c
+stdbool.in.h
+stdlib.in.h
+strdup.c
+string.in.h
+sys_stat.in.h
+unistd.in.h
+wchar.in.h
+wctype.in.h
diff -urN popt-for-windows/lib/dirent.in.h popt-for-windows-gnulib/lib/dirent.in.h
--- popt-for-windows/lib/dirent.in.h	1970-01-01 01:00:00.000000000 +0100
+++ popt-for-windows-gnulib/lib/dirent.in.h	2008-10-25 15:17:05.000000000 +0100
@@ -0,0 +1,67 @@
+/* A GNU-like <dirent.h>.
+   Copyright (C) 2006-2008 Free Software Foundation, Inc.
+
+   This program is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+#ifndef _GL_DIRENT_H
+
+#if __GNUC__ >= 3
+@PRAGMA_SYSTEM_HEADER@
+#endif
+
+/* The include_next requires a split double-inclusion guard.  */
+#@INCLUDE_NEXT@ @NEXT_DIRENT_H@
+
+#ifndef _GL_DIRENT_H
+#define _GL_DIRENT_H
+
+/* The definition of GL_LINK_WARNING is copied here.  */
+
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* Declare overridden functions.  */
+
+#if @REPLACE_FCHDIR@
+# define opendir rpl_opendir
+extern DIR * opendir (const char *);
+# define closedir rpl_closedir
+extern int closedir (DIR *);
+#endif
+
+/* Declare GNU extensions.  */
+
+#if @GNULIB_DIRFD@
+# if !@HAVE_DECL_DIRFD@ && !defined dirfd
+/* Return the file descriptor associated with the given directory stream,
+   or -1 if none exists.  */
+extern int dirfd (DIR const *dir);
+# endif
+#elif defined GNULIB_POSIXCHECK
+# undef dirfd
+# define dirfd(d) \
+    (GL_LINK_WARNING ("dirfd is unportable - " \
+                      "use gnulib module dirfd for portability"), \
+     dirfd (d))
+#endif
+
+#ifdef __cplusplus
+}
+#endif
+
+
+#endif /* _GL_DIRENT_H */
+#endif /* _GL_DIRENT_H */
diff -urN popt-for-windows/lib/dirfd.c popt-for-windows-gnulib/lib/dirfd.c
--- popt-for-windows/lib/dirfd.c	1970-01-01 01:00:00.000000000 +0100
+++ popt-for-windows-gnulib/lib/dirfd.c	2008-10-25 15:17:05.000000000 +0100
@@ -0,0 +1,28 @@
+/* dirfd.c -- return the file descriptor associated with an open DIR*
+
+   Copyright (C) 2001, 2006, 2008 Free Software Foundation, Inc.
+
+   This program is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+/* Written by Jim Meyering. */
+
+#include <config.h>
+
+#include <dirent.h>
+
+int
+dirfd (DIR const *dir_p)
+{
+  return DIR_TO_FD (dir_p);
+}
diff -urN popt-for-windows/lib/dummy.c popt-for-windows-gnulib/lib/dummy.c
--- popt-for-windows/lib/dummy.c	1970-01-01 01:00:00.000000000 +0100
+++ popt-for-windows-gnulib/lib/dummy.c	2008-10-25 15:17:05.000000000 +0100
@@ -0,0 +1,42 @@
+/* A dummy file, to prevent empty libraries from breaking builds.
+   Copyright (C) 2004, 2007 Free Software Foundation, Inc.
+
+   This program is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+/* Some systems, reportedly OpenBSD and Mac OS X, refuse to create
+   libraries without any object files.  You might get an error like:
+
+   > ar cru .libs/libgl.a
+   > ar: no archive members specified
+
+   Compiling this file, and adding its object file to the library, will
+   prevent the library from being empty.  */
+
+/* Some systems, such as Solaris with cc 5.0, refuse to work with libraries
+   that don't export any symbol.  You might get an error like:
+
+   > cc ... libgnu.a
+   > ild: (bad file) garbled symbol table in archive ../gllib/libgnu.a
+
+   Compiling this file, and adding its object file to the library, will
+   prevent the library from exporting no symbols.  */
+
+#ifdef __sun
+/* This declaration ensures that the library will export at least 1 symbol.  */
+int gl_dummy_symbol;
+#else
+/* This declaration is solely to ensure that after preprocessing
+   this file is never empty.  */
+typedef int dummy;
+#endif
diff -urN popt-for-windows/lib/fnmatch.c popt-for-windows-gnulib/lib/fnmatch.c
--- popt-for-windows/lib/fnmatch.c	1970-01-01 01:00:00.000000000 +0100
+++ popt-for-windows-gnulib/lib/fnmatch.c	2008-10-25 15:17:05.000000000 +0100
@@ -0,0 +1,354 @@
+/* Copyright (C) 1991,1992,1993,1996,1997,1998,1999,2000,2001,2002,2003,2004,2005,2006,2007
+	Free Software Foundation, Inc.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software Foundation,
+   Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
+
+#ifndef _LIBC
+# include <config.h>
+#endif
+
+/* Enable GNU extensions in fnmatch.h.  */
+#ifndef _GNU_SOURCE
+# define _GNU_SOURCE	1
+#endif
+
+#if ! defined __builtin_expect && __GNUC__ < 3
+# define __builtin_expect(expr, expected) (expr)
+#endif
+
+#include <fnmatch.h>
+
+#include <alloca.h>
+#include <assert.h>
+#include <ctype.h>
+#include <errno.h>
+#include <stddef.h>
+#include <stdbool.h>
+#include <stdlib.h>
+#include <string.h>
+
+#define WIDE_CHAR_SUPPORT \
+  (HAVE_WCTYPE_H && HAVE_BTOWC && HAVE_ISWCTYPE \
+   && HAVE_WMEMCHR && (HAVE_WMEMCPY || HAVE_WMEMPCPY))
+
+/* For platform which support the ISO C amendement 1 functionality we
+   support user defined character classes.  */
+#if defined _LIBC || WIDE_CHAR_SUPPORT
+# include <wctype.h>
+# include <wchar.h>
+#endif
+
+/* We need some of the locale data (the collation sequence information)
+   but there is no interface to get this information in general.  Therefore
+   we support a correct implementation only in glibc.  */
+#ifdef _LIBC
+# include "../locale/localeinfo.h"
+# include "../locale/elem-hash.h"
+# include "../locale/coll-lookup.h"
+# include <shlib-compat.h>
+
+# define CONCAT(a,b) __CONCAT(a,b)
+# define mbsrtowcs __mbsrtowcs
+# define fnmatch __fnmatch
+extern int fnmatch (const char *pattern, const char *string, int flags);
+#endif
+
+#ifndef SIZE_MAX
+# define SIZE_MAX ((size_t) -1)
+#endif
+
+/* We often have to test for FNM_FILE_NAME and FNM_PERIOD being both set.  */
+#define NO_LEADING_PERIOD(flags) \
+  ((flags & (FNM_FILE_NAME | FNM_PERIOD)) == (FNM_FILE_NAME | FNM_PERIOD))
+
+/* Comment out all this code if we are using the GNU C Library, and are not
+   actually compiling the library itself, and have not detected a bug
+   in the library.  This code is part of the GNU C
+   Library, but also included in many other GNU distributions.  Compiling
+   and linking in this code is a waste when using the GNU C library
+   (especially if it is a shared library).  Rather than having every GNU
+   program understand `configure --with-gnu-libc' and omit the object files,
+   it is simpler to just do this in the source for each such file.  */
+
+#if defined _LIBC || !defined __GNU_LIBRARY__ || !HAVE_FNMATCH_GNU
+
+
+# if ! (defined isblank || (HAVE_ISBLANK && HAVE_DECL_ISBLANK))
+#  define isblank(c) ((c) == ' ' || (c) == '\t')
+# endif
+
+# define STREQ(s1, s2) ((strcmp (s1, s2) == 0))
+
+# if defined _LIBC || WIDE_CHAR_SUPPORT
+/* The GNU C library provides support for user-defined character classes
+   and the functions from ISO C amendement 1.  */
+#  ifdef CHARCLASS_NAME_MAX
+#   define CHAR_CLASS_MAX_LENGTH CHARCLASS_NAME_MAX
+#  else
+/* This shouldn't happen but some implementation might still have this
+   problem.  Use a reasonable default value.  */
+#   define CHAR_CLASS_MAX_LENGTH 256
+#  endif
+
+#  ifdef _LIBC
+#   define IS_CHAR_CLASS(string) __wctype (string)
+#  else
+#   define IS_CHAR_CLASS(string) wctype (string)
+#  endif
+
+#  ifdef _LIBC
+#   define ISWCTYPE(WC, WT)	__iswctype (WC, WT)
+#  else
+#   define ISWCTYPE(WC, WT)	iswctype (WC, WT)
+#  endif
+
+#  if (HAVE_MBSTATE_T && HAVE_MBSRTOWCS) || _LIBC
+/* In this case we are implementing the multibyte character handling.  */
+#   define HANDLE_MULTIBYTE	1
+#  endif
+
+# else
+#  define CHAR_CLASS_MAX_LENGTH  6 /* Namely, `xdigit'.  */
+
+#  define IS_CHAR_CLASS(string)						      \
+   (STREQ (string, "alpha") || STREQ (string, "upper")			      \
+    || STREQ (string, "lower") || STREQ (string, "digit")		      \
+    || STREQ (string, "alnum") || STREQ (string, "xdigit")		      \
+    || STREQ (string, "space") || STREQ (string, "print")		      \
+    || STREQ (string, "punct") || STREQ (string, "graph")		      \
+    || STREQ (string, "cntrl") || STREQ (string, "blank"))
+# endif
+
+/* Avoid depending on library functions or files
+   whose names are inconsistent.  */
+
+/* Global variable.  */
+static int posixly_correct;
+
+# ifndef internal_function
+/* Inside GNU libc we mark some function in a special way.  In other
+   environments simply ignore the marking.  */
+#  define internal_function
+# endif
+
+/* Note that this evaluates C many times.  */
+# define FOLD(c) ((flags & FNM_CASEFOLD) ? tolower (c) : (c))
+# define CHAR	char
+# define UCHAR	unsigned char
+# define INT	int
+# define FCT	internal_fnmatch
+# define EXT	ext_match
+# define END	end_pattern
+# define L_(CS)	CS
+# ifdef _LIBC
+#  define BTOWC(C)	__btowc (C)
+# else
+#  define BTOWC(C)	btowc (C)
+# endif
+# define STRLEN(S) strlen (S)
+# define STRCAT(D, S) strcat (D, S)
+# ifdef _LIBC
+#  define MEMPCPY(D, S, N) __mempcpy (D, S, N)
+# else
+#  if HAVE_MEMPCPY
+#   define MEMPCPY(D, S, N) mempcpy (D, S, N)
+#  else
+#   define MEMPCPY(D, S, N) ((void *) ((char *) memcpy (D, S, N) + (N)))
+#  endif
+# endif
+# define MEMCHR(S, C, N) memchr (S, C, N)
+# define STRCOLL(S1, S2) strcoll (S1, S2)
+# include "fnmatch_loop.c"
+
+
+# if HANDLE_MULTIBYTE
+#  define FOLD(c) ((flags & FNM_CASEFOLD) ? towlower (c) : (c))
+#  define CHAR	wchar_t
+#  define UCHAR	wint_t
+#  define INT	wint_t
+#  define FCT	internal_fnwmatch
+#  define EXT	ext_wmatch
+#  define END	end_wpattern
+#  define L_(CS)	L##CS
+#  define BTOWC(C)	(C)
+#  ifdef _LIBC
+#   define STRLEN(S) __wcslen (S)
+#   define STRCAT(D, S) __wcscat (D, S)
+#   define MEMPCPY(D, S, N) __wmempcpy (D, S, N)
+#  else
+#   define STRLEN(S) wcslen (S)
+#   define STRCAT(D, S) wcscat (D, S)
+#   if HAVE_WMEMPCPY
+#    define MEMPCPY(D, S, N) wmempcpy (D, S, N)
+#   else
+#    define MEMPCPY(D, S, N) (wmemcpy (D, S, N) + (N))
+#   endif
+#  endif
+#  define MEMCHR(S, C, N) wmemchr (S, C, N)
+#  define STRCOLL(S1, S2) wcscoll (S1, S2)
+#  define WIDE_CHAR_VERSION 1
+
+#  undef IS_CHAR_CLASS
+/* We have to convert the wide character string in a multibyte string.  But
+   we know that the character class names consist of alphanumeric characters
+   from the portable character set, and since the wide character encoding
+   for a member of the portable character set is the same code point as
+   its single-byte encoding, we can use a simplified method to convert the
+   string to a multibyte character string.  */
+static wctype_t
+is_char_class (const wchar_t *wcs)
+{
+  char s[CHAR_CLASS_MAX_LENGTH + 1];
+  char *cp = s;
+
+  do
+    {
+      /* Test for a printable character from the portable character set.  */
+#  ifdef _LIBC
+      if (*wcs < 0x20 || *wcs > 0x7e
+	  || *wcs == 0x24 || *wcs == 0x40 || *wcs == 0x60)
+	return (wctype_t) 0;
+#  else
+      switch (*wcs)
+	{
+	case L' ': case L'!': case L'"': case L'#': case L'%':
+	case L'&': case L'\'': case L'(': case L')': case L'*':
+	case L'+': case L',': case L'-': case L'.': case L'/':
+	case L'0': case L'1': case L'2': case L'3': case L'4':
+	case L'5': case L'6': case L'7': case L'8': case L'9':
+	case L':': case L';': case L'<': case L'=': case L'>':
+	case L'?':
+	case L'A': case L'B': case L'C': case L'D': case L'E':
+	case L'F': case L'G': case L'H': case L'I': case L'J':
+	case L'K': case L'L': case L'M': case L'N': case L'O':
+	case L'P': case L'Q': case L'R': case L'S': case L'T':
+	case L'U': case L'V': case L'W': case L'X': case L'Y':
+	case L'Z':
+	case L'[': case L'\\': case L']': case L'^': case L'_':
+	case L'a': case L'b': case L'c': case L'd': case L'e':
+	case L'f': case L'g': case L'h': case L'i': case L'j':
+	case L'k': case L'l': case L'm': case L'n': case L'o':
+	case L'p': case L'q': case L'r': case L's': case L't':
+	case L'u': case L'v': case L'w': case L'x': case L'y':
+	case L'z': case L'{': case L'|': case L'}': case L'~':
+	  break;
+	default:
+	  return (wctype_t) 0;
+	}
+#  endif
+
+      /* Avoid overrunning the buffer.  */
+      if (cp == s + CHAR_CLASS_MAX_LENGTH)
+	return (wctype_t) 0;
+
+      *cp++ = (char) *wcs++;
+    }
+  while (*wcs != L'\0');
+
+  *cp = '\0';
+
+#  ifdef _LIBC
+  return __wctype (s);
+#  else
+  return wctype (s);
+#  endif
+}
+#  define IS_CHAR_CLASS(string) is_char_class (string)
+
+#  include "fnmatch_loop.c"
+# endif
+
+
+int
+fnmatch (const char *pattern, const char *string, int flags)
+{
+# if HANDLE_MULTIBYTE
+#  define ALLOCA_LIMIT 2000
+  if (__builtin_expect (MB_CUR_MAX, 1) != 1)
+    {
+      mbstate_t ps;
+      size_t patsize;
+      size_t strsize;
+      size_t totsize;
+      wchar_t *wpattern;
+      wchar_t *wstring;
+      int res;
+
+      /* Calculate the size needed to convert the strings to
+	 wide characters.  */
+      memset (&ps, '\0', sizeof (ps));
+      patsize = mbsrtowcs (NULL, &pattern, 0, &ps) + 1;
+      if (__builtin_expect (patsize != 0, 1))
+	{
+	  assert (mbsinit (&ps));
+	  strsize = mbsrtowcs (NULL, &string, 0, &ps) + 1;
+	  if (__builtin_expect (strsize != 0, 1))
+	    {
+	      assert (mbsinit (&ps));
+	      totsize = patsize + strsize;
+	      if (__builtin_expect (! (patsize <= totsize
+				       && totsize <= SIZE_MAX / sizeof (wchar_t)),
+				    0))
+		{
+		  errno = ENOMEM;
+		  return -1;
+		}
+
+	      /* Allocate room for the wide characters.  */
+	      if (__builtin_expect (totsize < ALLOCA_LIMIT, 1))
+		wpattern = (wchar_t *) alloca (totsize * sizeof (wchar_t));
+	      else
+		{
+		  wpattern = malloc (totsize * sizeof (wchar_t));
+		  if (__builtin_expect (! wpattern, 0))
+		    {
+		      errno = ENOMEM;
+		      return -1;
+		    }
+		}
+	      wstring = wpattern + patsize;
+
+	      /* Convert the strings into wide characters.  */
+	      mbsrtowcs (wpattern, &pattern, patsize, &ps);
+	      assert (mbsinit (&ps));
+	      mbsrtowcs (wstring, &string, strsize, &ps);
+
+	      res = internal_fnwmatch (wpattern, wstring, wstring + strsize - 1,
+				       flags & FNM_PERIOD, flags);
+
+	      if (__builtin_expect (! (totsize < ALLOCA_LIMIT), 0))
+		free (wpattern);
+	      return res;
+	    }
+	}
+    }
+
+# endif /* HANDLE_MULTIBYTE */
+
+  return internal_fnmatch (pattern, string, string + strlen (string),
+			   flags & FNM_PERIOD, flags);
+}
+
+# ifdef _LIBC
+#  undef fnmatch
+versioned_symbol (libc, __fnmatch, fnmatch, GLIBC_2_2_3);
+#  if SHLIB_COMPAT(libc, GLIBC_2_0, GLIBC_2_2_3)
+strong_alias (__fnmatch, __fnmatch_old)
+compat_symbol (libc, __fnmatch_old, fnmatch, GLIBC_2_0);
+#  endif
+libc_hidden_ver (__fnmatch, fnmatch)
+# endif
+
+#endif	/* _LIBC or not __GNU_LIBRARY__.  */
diff -urN popt-for-windows/lib/fnmatch.in.h popt-for-windows-gnulib/lib/fnmatch.in.h
--- popt-for-windows/lib/fnmatch.in.h	1970-01-01 01:00:00.000000000 +0100
+++ popt-for-windows-gnulib/lib/fnmatch.in.h	2008-10-25 15:17:05.000000000 +0100
@@ -0,0 +1,65 @@
+/* Copyright (C) 1991, 1992, 1993, 1996, 1997, 1998, 1999, 2001, 2002, 2003,
+   2005, 2007 Free Software Foundation, Inc.
+
+   This file is part of the GNU C Library.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software Foundation,
+   Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
+
+#ifndef	_FNMATCH_H
+#define	_FNMATCH_H	1
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* We #undef these before defining them because some losing systems
+   (HP-UX A.08.07 for example) define these in <unistd.h>.  */
+#undef	FNM_PATHNAME
+#undef	FNM_NOESCAPE
+#undef	FNM_PERIOD
+
+/* Bits set in the FLAGS argument to `fnmatch'.  */
+#define	FNM_PATHNAME	(1 << 0) /* No wildcard can ever match `/'.  */
+#define	FNM_NOESCAPE	(1 << 1) /* Backslashes don't quote special chars.  */
+#define	FNM_PERIOD	(1 << 2) /* Leading `.' is matched only explicitly.  */
+
+#if !defined _POSIX_C_SOURCE || _POSIX_C_SOURCE < 2 || defined _GNU_SOURCE
+# define FNM_FILE_NAME	 FNM_PATHNAME	/* Preferred GNU name.  */
+# define FNM_LEADING_DIR (1 << 3)	/* Ignore `/...' after a match.  */
+# define FNM_CASEFOLD	 (1 << 4)	/* Compare without regard to case.  */
+# define FNM_EXTMATCH	 (1 << 5)	/* Use ksh-like extended matching. */
+#endif
+
+/* Value returned by `fnmatch' if STRING does not match PATTERN.  */
+#define	FNM_NOMATCH	1
+
+/* This value is returned if the implementation does not support
+   `fnmatch'.  Since this is not the case here it will never be
+   returned but the conformance test suites still require the symbol
+   to be defined.  */
+#ifdef _XOPEN_SOURCE
+# define FNM_NOSYS	(-1)
+#endif
+
+/* Match NAME against the file name pattern PATTERN,
+   returning zero if it matches, FNM_NOMATCH if not.  */
+extern int fnmatch (const char *__pattern, const char *__name,
+		    int __flags);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* fnmatch.h */
diff -urN popt-for-windows/lib/fnmatch_loop.c popt-for-windows-gnulib/lib/fnmatch_loop.c
--- popt-for-windows/lib/fnmatch_loop.c	1970-01-01 01:00:00.000000000 +0100
+++ popt-for-windows-gnulib/lib/fnmatch_loop.c	2008-10-25 15:17:05.000000000 +0100
@@ -0,0 +1,1210 @@
+/* Copyright (C) 1991,1992,1993,1996,1997,1998,1999,2000,2001,2002,2003,2004,2005,2006
+   Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software Foundation,
+   Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
+
+/* Match STRING against the file name pattern PATTERN, returning zero if
+   it matches, nonzero if not.  */
+static int EXT (INT opt, const CHAR *pattern, const CHAR *string,
+		const CHAR *string_end, bool no_leading_period, int flags)
+     internal_function;
+static const CHAR *END (const CHAR *patternp) internal_function;
+
+static int
+internal_function
+FCT (const CHAR *pattern, const CHAR *string, const CHAR *string_end,
+     bool no_leading_period, int flags)
+{
+  register const CHAR *p = pattern, *n = string;
+  register UCHAR c;
+#ifdef _LIBC
+# if WIDE_CHAR_VERSION
+  const char *collseq = (const char *)
+    _NL_CURRENT(LC_COLLATE, _NL_COLLATE_COLLSEQWC);
+# else
+  const UCHAR *collseq = (const UCHAR *)
+    _NL_CURRENT(LC_COLLATE, _NL_COLLATE_COLLSEQMB);
+# endif
+#endif
+
+  while ((c = *p++) != L_('\0'))
+    {
+      bool new_no_leading_period = false;
+      c = FOLD (c);
+
+      switch (c)
+	{
+	case L_('?'):
+	  if (__builtin_expect (flags & FNM_EXTMATCH, 0) && *p == '(')
+	    {
+	      int res;
+
+	      res = EXT (c, p, n, string_end, no_leading_period,
+			 flags);
+	      if (res != -1)
+		return res;
+	    }
+
+	  if (n == string_end)
+	    return FNM_NOMATCH;
+	  else if (*n == L_('/') && (flags & FNM_FILE_NAME))
+	    return FNM_NOMATCH;
+	  else if (*n == L_('.') && no_leading_period)
+	    return FNM_NOMATCH;
+	  break;
+
+	case L_('\\'):
+	  if (!(flags & FNM_NOESCAPE))
+	    {
+	      c = *p++;
+	      if (c == L_('\0'))
+		/* Trailing \ loses.  */
+		return FNM_NOMATCH;
+	      c = FOLD (c);
+	    }
+	  if (n == string_end || FOLD ((UCHAR) *n) != c)
+	    return FNM_NOMATCH;
+	  break;
+
+	case L_('*'):
+	  if (__builtin_expect (flags & FNM_EXTMATCH, 0) && *p == '(')
+	    {
+	      int res;
+
+	      res = EXT (c, p, n, string_end, no_leading_period,
+			 flags);
+	      if (res != -1)
+		return res;
+	    }
+
+	  if (n != string_end && *n == L_('.') && no_leading_period)
+	    return FNM_NOMATCH;
+
+	  for (c = *p++; c == L_('?') || c == L_('*'); c = *p++)
+	    {
+	      if (*p == L_('(') && (flags & FNM_EXTMATCH) != 0)
+		{
+		  const CHAR *endp = END (p);
+		  if (endp != p)
+		    {
+		      /* This is a pattern.  Skip over it.  */
+		      p = endp;
+		      continue;
+		    }
+		}
+
+	      if (c == L_('?'))
+		{
+		  /* A ? needs to match one character.  */
+		  if (n == string_end)
+		    /* There isn't another character; no match.  */
+		    return FNM_NOMATCH;
+		  else if (*n == L_('/')
+			   && __builtin_expect (flags & FNM_FILE_NAME, 0))
+		    /* A slash does not match a wildcard under
+		       FNM_FILE_NAME.  */
+		    return FNM_NOMATCH;
+		  else
+		    /* One character of the string is consumed in matching
+		       this ? wildcard, so *??? won't match if there are
+		       less than three characters.  */
+		    ++n;
+		}
+	    }
+
+	  if (c == L_('\0'))
+	    /* The wildcard(s) is/are the last element of the pattern.
+	       If the name is a file name and contains another slash
+	       this means it cannot match, unless the FNM_LEADING_DIR
+	       flag is set.  */
+	    {
+	      int result = (flags & FNM_FILE_NAME) == 0 ? 0 : FNM_NOMATCH;
+
+	      if (flags & FNM_FILE_NAME)
+		{
+		  if (flags & FNM_LEADING_DIR)
+		    result = 0;
+		  else
+		    {
+		      if (MEMCHR (n, L_('/'), string_end - n) == NULL)
+			result = 0;
+		    }
+		}
+
+	      return result;
+	    }
+	  else
+	    {
+	      const CHAR *endp;
+
+	      endp = MEMCHR (n, (flags & FNM_FILE_NAME) ? L_('/') : L_('\0'),
+			     string_end - n);
+	      if (endp == NULL)
+		endp = string_end;
+
+	      if (c == L_('[')
+		  || (__builtin_expect (flags & FNM_EXTMATCH, 0) != 0
+		      && (c == L_('@') || c == L_('+') || c == L_('!'))
+		      && *p == L_('(')))
+		{
+		  int flags2 = ((flags & FNM_FILE_NAME)
+				? flags : (flags & ~FNM_PERIOD));
+		  bool no_leading_period2 = no_leading_period;
+
+		  for (--p; n < endp; ++n, no_leading_period2 = false)
+		    if (FCT (p, n, string_end, no_leading_period2, flags2)
+			== 0)
+		      return 0;
+		}
+	      else if (c == L_('/') && (flags & FNM_FILE_NAME))
+		{
+		  while (n < string_end && *n != L_('/'))
+		    ++n;
+		  if (n < string_end && *n == L_('/')
+		      && (FCT (p, n + 1, string_end, flags & FNM_PERIOD, flags)
+			  == 0))
+		    return 0;
+		}
+	      else
+		{
+		  int flags2 = ((flags & FNM_FILE_NAME)
+				? flags : (flags & ~FNM_PERIOD));
+		  int no_leading_period2 = no_leading_period;
+
+		  if (c == L_('\\') && !(flags & FNM_NOESCAPE))
+		    c = *p;
+		  c = FOLD (c);
+		  for (--p; n < endp; ++n, no_leading_period2 = false)
+		    if (FOLD ((UCHAR) *n) == c
+			&& (FCT (p, n, string_end, no_leading_period2, flags2)
+			    == 0))
+		      return 0;
+		}
+	    }
+
+	  /* If we come here no match is possible with the wildcard.  */
+	  return FNM_NOMATCH;
+
+	case L_('['):
+	  {
+	    /* Nonzero if the sense of the character class is inverted.  */
+	    register bool not;
+	    CHAR cold;
+	    UCHAR fn;
+
+	    if (posixly_correct == 0)
+	      posixly_correct = getenv ("POSIXLY_CORRECT") != NULL ? 1 : -1;
+
+	    if (n == string_end)
+	      return FNM_NOMATCH;
+
+	    if (*n == L_('.') && no_leading_period)
+	      return FNM_NOMATCH;
+
+	    if (*n == L_('/') && (flags & FNM_FILE_NAME))
+	      /* `/' cannot be matched.  */
+	      return FNM_NOMATCH;
+
+	    not = (*p == L_('!') || (posixly_correct < 0 && *p == L_('^')));
+	    if (not)
+	      ++p;
+
+	    fn = FOLD ((UCHAR) *n);
+
+	    c = *p++;
+	    for (;;)
+	      {
+		if (!(flags & FNM_NOESCAPE) && c == L_('\\'))
+		  {
+		    if (*p == L_('\0'))
+		      return FNM_NOMATCH;
+		    c = FOLD ((UCHAR) *p);
+		    ++p;
+
+		    goto normal_bracket;
+		  }
+		else if (c == L_('[') && *p == L_(':'))
+		  {
+		    /* Leave room for the null.  */
+		    CHAR str[CHAR_CLASS_MAX_LENGTH + 1];
+		    size_t c1 = 0;
+#if defined _LIBC || WIDE_CHAR_SUPPORT
+		    wctype_t wt;
+#endif
+		    const CHAR *startp = p;
+
+		    for (;;)
+		      {
+			if (c1 == CHAR_CLASS_MAX_LENGTH)
+			  /* The name is too long and therefore the pattern
+			     is ill-formed.  */
+			  return FNM_NOMATCH;
+
+			c = *++p;
+			if (c == L_(':') && p[1] == L_(']'))
+			  {
+			    p += 2;
+			    break;
+			  }
+			if (c < L_('a') || c >= L_('z'))
+			  {
+			    /* This cannot possibly be a character class name.
+			       Match it as a normal range.  */
+			    p = startp;
+			    c = L_('[');
+			    goto normal_bracket;
+			  }
+			str[c1++] = c;
+		      }
+		    str[c1] = L_('\0');
+
+#if defined _LIBC || WIDE_CHAR_SUPPORT
+		    wt = IS_CHAR_CLASS (str);
+		    if (wt == 0)
+		      /* Invalid character class name.  */
+		      return FNM_NOMATCH;
+
+# if defined _LIBC && ! WIDE_CHAR_VERSION
+		    /* The following code is glibc specific but does
+		       there a good job in speeding up the code since
+		       we can avoid the btowc() call.  */
+		    if (_ISCTYPE ((UCHAR) *n, wt))
+		      goto matched;
+# else
+		    if (ISWCTYPE (BTOWC ((UCHAR) *n), wt))
+		      goto matched;
+# endif
+#else
+		    if ((STREQ (str, L_("alnum")) && isalnum ((UCHAR) *n))
+			|| (STREQ (str, L_("alpha")) && isalpha ((UCHAR) *n))
+			|| (STREQ (str, L_("blank")) && isblank ((UCHAR) *n))
+			|| (STREQ (str, L_("cntrl")) && iscntrl ((UCHAR) *n))
+			|| (STREQ (str, L_("digit")) && isdigit ((UCHAR) *n))
+			|| (STREQ (str, L_("graph")) && isgraph ((UCHAR) *n))
+			|| (STREQ (str, L_("lower")) && islower ((UCHAR) *n))
+			|| (STREQ (str, L_("print")) && isprint ((UCHAR) *n))
+			|| (STREQ (str, L_("punct")) && ispunct ((UCHAR) *n))
+			|| (STREQ (str, L_("space")) && isspace ((UCHAR) *n))
+			|| (STREQ (str, L_("upper")) && isupper ((UCHAR) *n))
+			|| (STREQ (str, L_("xdigit")) && isxdigit ((UCHAR) *n)))
+		      goto matched;
+#endif
+		    c = *p++;
+		  }
+#ifdef _LIBC
+		else if (c == L_('[') && *p == L_('='))
+		  {
+		    UCHAR str[1];
+		    uint32_t nrules =
+		      _NL_CURRENT_WORD (LC_COLLATE, _NL_COLLATE_NRULES);
+		    const CHAR *startp = p;
+
+		    c = *++p;
+		    if (c == L_('\0'))
+		      {
+			p = startp;
+			c = L_('[');
+			goto normal_bracket;
+		      }
+		    str[0] = c;
+
+		    c = *++p;
+		    if (c != L_('=') || p[1] != L_(']'))
+		      {
+			p = startp;
+			c = L_('[');
+			goto normal_bracket;
+		      }
+		    p += 2;
+
+		    if (nrules == 0)
+		      {
+			if ((UCHAR) *n == str[0])
+			  goto matched;
+		      }
+		    else
+		      {
+			const int32_t *table;
+# if WIDE_CHAR_VERSION
+			const int32_t *weights;
+			const int32_t *extra;
+# else
+			const unsigned char *weights;
+			const unsigned char *extra;
+# endif
+			const int32_t *indirect;
+			int32_t idx;
+			const UCHAR *cp = (const UCHAR *) str;
+
+			/* This #include defines a local function!  */
+# if WIDE_CHAR_VERSION
+#  include <locale/weightwc.h>
+# else
+#  include <locale/weight.h>
+# endif
+
+# if WIDE_CHAR_VERSION
+			table = (const int32_t *)
+			  _NL_CURRENT (LC_COLLATE, _NL_COLLATE_TABLEWC);
+			weights = (const int32_t *)
+			  _NL_CURRENT (LC_COLLATE, _NL_COLLATE_WEIGHTWC);
+			extra = (const int32_t *)
+			  _NL_CURRENT (LC_COLLATE, _NL_COLLATE_EXTRAWC);
+			indirect = (const int32_t *)
+			  _NL_CURRENT (LC_COLLATE, _NL_COLLATE_INDIRECTWC);
+# else
+			table = (const int32_t *)
+			  _NL_CURRENT (LC_COLLATE, _NL_COLLATE_TABLEMB);
+			weights = (const unsigned char *)
+			  _NL_CURRENT (LC_COLLATE, _NL_COLLATE_WEIGHTMB);
+			extra = (const unsigned char *)
+			  _NL_CURRENT (LC_COLLATE, _NL_COLLATE_EXTRAMB);
+			indirect = (const int32_t *)
+			  _NL_CURRENT (LC_COLLATE, _NL_COLLATE_INDIRECTMB);
+# endif
+
+			idx = findidx (&cp);
+			if (idx != 0)
+			  {
+			    /* We found a table entry.  Now see whether the
+			       character we are currently at has the same
+			       equivalance class value.  */
+			    int len = weights[idx];
+			    int32_t idx2;
+			    const UCHAR *np = (const UCHAR *) n;
+
+			    idx2 = findidx (&np);
+			    if (idx2 != 0 && len == weights[idx2])
+			      {
+				int cnt = 0;
+
+				while (cnt < len
+				       && (weights[idx + 1 + cnt]
+					   == weights[idx2 + 1 + cnt]))
+				  ++cnt;
+
+				if (cnt == len)
+				  goto matched;
+			      }
+			  }
+		      }
+
+		    c = *p++;
+		  }
+#endif
+		else if (c == L_('\0'))
+		  /* [ (unterminated) loses.  */
+		  return FNM_NOMATCH;
+		else
+		  {
+		    bool is_range = false;
+
+#ifdef _LIBC
+		    bool is_seqval = false;
+
+		    if (c == L_('[') && *p == L_('.'))
+		      {
+			uint32_t nrules =
+			  _NL_CURRENT_WORD (LC_COLLATE, _NL_COLLATE_NRULES);
+			const CHAR *startp = p;
+			size_t c1 = 0;
+
+			while (1)
+			  {
+			    c = *++p;
+			    if (c == L_('.') && p[1] == L_(']'))
+			      {
+				p += 2;
+				break;
+			      }
+			    if (c == '\0')
+			      return FNM_NOMATCH;
+			    ++c1;
+			  }
+
+			/* We have to handling the symbols differently in
+			   ranges since then the collation sequence is
+			   important.  */
+			is_range = *p == L_('-') && p[1] != L_('\0');
+
+			if (nrules == 0)
+			  {
+			    /* There are no names defined in the collation
+			       data.  Therefore we only accept the trivial
+			       names consisting of the character itself.  */
+			    if (c1 != 1)
+			      return FNM_NOMATCH;
+
+			    if (!is_range && *n == startp[1])
+			      goto matched;
+
+			    cold = startp[1];
+			    c = *p++;
+			  }
+			else
+			  {
+			    int32_t table_size;
+			    const int32_t *symb_table;
+# ifdef WIDE_CHAR_VERSION
+			    char str[c1];
+			    size_t strcnt;
+# else
+#  define str (startp + 1)
+# endif
+			    const unsigned char *extra;
+			    int32_t idx;
+			    int32_t elem;
+			    int32_t second;
+			    int32_t hash;
+
+# ifdef WIDE_CHAR_VERSION
+			    /* We have to convert the name to a single-byte
+			       string.  This is possible since the names
+			       consist of ASCII characters and the internal
+			       representation is UCS4.  */
+			    for (strcnt = 0; strcnt < c1; ++strcnt)
+			      str[strcnt] = startp[1 + strcnt];
+# endif
+
+			    table_size =
+			      _NL_CURRENT_WORD (LC_COLLATE,
+						_NL_COLLATE_SYMB_HASH_SIZEMB);
+			    symb_table = (const int32_t *)
+			      _NL_CURRENT (LC_COLLATE,
+					   _NL_COLLATE_SYMB_TABLEMB);
+			    extra = (const unsigned char *)
+			      _NL_CURRENT (LC_COLLATE,
+					   _NL_COLLATE_SYMB_EXTRAMB);
+
+			    /* Locate the character in the hashing table.  */
+			    hash = elem_hash (str, c1);
+
+			    idx = 0;
+			    elem = hash % table_size;
+			    if (symb_table[2 * elem] != 0)
+			      {
+				second = hash % (table_size - 2) + 1;
+
+				do
+				  {
+				    /* First compare the hashing value.  */
+				    if (symb_table[2 * elem] == hash
+					&& (c1
+					    == extra[symb_table[2 * elem + 1]])
+					&& memcmp (str,
+						   &extra[symb_table[2 * elem
+								     + 1]
+							  + 1], c1) == 0)
+				      {
+					/* Yep, this is the entry.  */
+					idx = symb_table[2 * elem + 1];
+					idx += 1 + extra[idx];
+					break;
+				      }
+
+				    /* Next entry.  */
+				    elem += second;
+				  }
+				while (symb_table[2 * elem] != 0);
+			      }
+
+			    if (symb_table[2 * elem] != 0)
+			      {
+				/* Compare the byte sequence but only if
+				   this is not part of a range.  */
+# ifdef WIDE_CHAR_VERSION
+				int32_t *wextra;
+
+				idx += 1 + extra[idx];
+				/* Adjust for the alignment.  */
+				idx = (idx + 3) & ~3;
+
+				wextra = (int32_t *) &extra[idx + 4];
+# endif
+
+				if (! is_range)
+				  {
+# ifdef WIDE_CHAR_VERSION
+				    for (c1 = 0;
+					 (int32_t) c1 < wextra[idx];
+					 ++c1)
+				      if (n[c1] != wextra[1 + c1])
+					break;
+
+				    if ((int32_t) c1 == wextra[idx])
+				      goto matched;
+# else
+				    for (c1 = 0; c1 < extra[idx]; ++c1)
+				      if (n[c1] != extra[1 + c1])
+					break;
+
+				    if (c1 == extra[idx])
+				      goto matched;
+# endif
+				  }
+
+				/* Get the collation sequence value.  */
+				is_seqval = true;
+# ifdef WIDE_CHAR_VERSION
+				cold = wextra[1 + wextra[idx]];
+# else
+				/* Adjust for the alignment.  */
+				idx += 1 + extra[idx];
+				idx = (idx + 3) & ~4;
+				cold = *((int32_t *) &extra[idx]);
+# endif
+
+				c = *p++;
+			      }
+			    else if (c1 == 1)
+			      {
+				/* No valid character.  Match it as a
+				   single byte.  */
+				if (!is_range && *n == str[0])
+				  goto matched;
+
+				cold = str[0];
+				c = *p++;
+			      }
+			    else
+			      return FNM_NOMATCH;
+			  }
+		      }
+		    else
+# undef str
+#endif
+		      {
+			c = FOLD (c);
+		      normal_bracket:
+
+			/* We have to handling the symbols differently in
+			   ranges since then the collation sequence is
+			   important.  */
+			is_range = (*p == L_('-') && p[1] != L_('\0')
+				    && p[1] != L_(']'));
+
+			if (!is_range && c == fn)
+			  goto matched;
+
+#if _LIBC
+			/* This is needed if we goto normal_bracket; from
+			   outside of is_seqval's scope.  */
+			is_seqval = false;
+#endif
+
+			cold = c;
+			c = *p++;
+		      }
+
+		    if (c == L_('-') && *p != L_(']'))
+		      {
+#if _LIBC
+			/* We have to find the collation sequence
+			   value for C.  Collation sequence is nothing
+			   we can regularly access.  The sequence
+			   value is defined by the order in which the
+			   definitions of the collation values for the
+			   various characters appear in the source
+			   file.  A strange concept, nowhere
+			   documented.  */
+			uint32_t fcollseq;
+			uint32_t lcollseq;
+			UCHAR cend = *p++;
+
+# ifdef WIDE_CHAR_VERSION
+			/* Search in the `names' array for the characters.  */
+			fcollseq = __collseq_table_lookup (collseq, fn);
+			if (fcollseq == ~((uint32_t) 0))
+			  /* XXX We don't know anything about the character
+			     we are supposed to match.  This means we are
+			     failing.  */
+			  goto range_not_matched;
+
+			if (is_seqval)
+			  lcollseq = cold;
+			else
+			  lcollseq = __collseq_table_lookup (collseq, cold);
+# else
+			fcollseq = collseq[fn];
+			lcollseq = is_seqval ? cold : collseq[(UCHAR) cold];
+# endif
+
+			is_seqval = false;
+			if (cend == L_('[') && *p == L_('.'))
+			  {
+			    uint32_t nrules =
+			      _NL_CURRENT_WORD (LC_COLLATE,
+						_NL_COLLATE_NRULES);
+			    const CHAR *startp = p;
+			    size_t c1 = 0;
+
+			    while (1)
+			      {
+				c = *++p;
+				if (c == L_('.') && p[1] == L_(']'))
+				  {
+				    p += 2;
+				    break;
+				  }
+				if (c == '\0')
+				  return FNM_NOMATCH;
+				++c1;
+			      }
+
+			    if (nrules == 0)
+			      {
+				/* There are no names defined in the
+				   collation data.  Therefore we only
+				   accept the trivial names consisting
+				   of the character itself.  */
+				if (c1 != 1)
+				  return FNM_NOMATCH;
+
+				cend = startp[1];
+			      }
+			    else
+			      {
+				int32_t table_size;
+				const int32_t *symb_table;
+# ifdef WIDE_CHAR_VERSION
+				char str[c1];
+				size_t strcnt;
+# else
+#  define str (startp + 1)
+# endif
+				const unsigned char *extra;
+				int32_t idx;
+				int32_t elem;
+				int32_t second;
+				int32_t hash;
+
+# ifdef WIDE_CHAR_VERSION
+				/* We have to convert the name to a single-byte
+				   string.  This is possible since the names
+				   consist of ASCII characters and the internal
+				   representation is UCS4.  */
+				for (strcnt = 0; strcnt < c1; ++strcnt)
+				  str[strcnt] = startp[1 + strcnt];
+# endif
+
+				table_size =
+				  _NL_CURRENT_WORD (LC_COLLATE,
+						    _NL_COLLATE_SYMB_HASH_SIZEMB);
+				symb_table = (const int32_t *)
+				  _NL_CURRENT (LC_COLLATE,
+					       _NL_COLLATE_SYMB_TABLEMB);
+				extra = (const unsigned char *)
+				  _NL_CURRENT (LC_COLLATE,
+					       _NL_COLLATE_SYMB_EXTRAMB);
+
+				/* Locate the character in the hashing
+                                   table.  */
+				hash = elem_hash (str, c1);
+
+				idx = 0;
+				elem = hash % table_size;
+				if (symb_table[2 * elem] != 0)
+				  {
+				    second = hash % (table_size - 2) + 1;
+
+				    do
+				      {
+					/* First compare the hashing value.  */
+					if (symb_table[2 * elem] == hash
+					    && (c1
+						== extra[symb_table[2 * elem + 1]])
+					    && memcmp (str,
+						       &extra[symb_table[2 * elem + 1]
+							      + 1], c1) == 0)
+					  {
+					    /* Yep, this is the entry.  */
+					    idx = symb_table[2 * elem + 1];
+					    idx += 1 + extra[idx];
+					    break;
+					  }
+
+					/* Next entry.  */
+					elem += second;
+				      }
+				    while (symb_table[2 * elem] != 0);
+				  }
+
+				if (symb_table[2 * elem] != 0)
+				  {
+				    /* Compare the byte sequence but only if
+				       this is not part of a range.  */
+# ifdef WIDE_CHAR_VERSION
+				    int32_t *wextra;
+
+				    idx += 1 + extra[idx];
+				    /* Adjust for the alignment.  */
+				    idx = (idx + 3) & ~4;
+
+				    wextra = (int32_t *) &extra[idx + 4];
+# endif
+				    /* Get the collation sequence value.  */
+				    is_seqval = true;
+# ifdef WIDE_CHAR_VERSION
+				    cend = wextra[1 + wextra[idx]];
+# else
+				    /* Adjust for the alignment.  */
+				    idx += 1 + extra[idx];
+				    idx = (idx + 3) & ~4;
+				    cend = *((int32_t *) &extra[idx]);
+# endif
+				  }
+				else if (symb_table[2 * elem] != 0 && c1 == 1)
+				  {
+				    cend = str[0];
+				    c = *p++;
+				  }
+				else
+				  return FNM_NOMATCH;
+			      }
+# undef str
+			  }
+			else
+			  {
+			    if (!(flags & FNM_NOESCAPE) && cend == L_('\\'))
+			      cend = *p++;
+			    if (cend == L_('\0'))
+			      return FNM_NOMATCH;
+			    cend = FOLD (cend);
+			  }
+
+			/* XXX It is not entirely clear to me how to handle
+			   characters which are not mentioned in the
+			   collation specification.  */
+			if (
+# ifdef WIDE_CHAR_VERSION
+			    lcollseq == 0xffffffff ||
+# endif
+			    lcollseq <= fcollseq)
+			  {
+			    /* We have to look at the upper bound.  */
+			    uint32_t hcollseq;
+
+			    if (is_seqval)
+			      hcollseq = cend;
+			    else
+			      {
+# ifdef WIDE_CHAR_VERSION
+				hcollseq =
+				  __collseq_table_lookup (collseq, cend);
+				if (hcollseq == ~((uint32_t) 0))
+				  {
+				    /* Hum, no information about the upper
+				       bound.  The matching succeeds if the
+				       lower bound is matched exactly.  */
+				    if (lcollseq != fcollseq)
+				      goto range_not_matched;
+
+				    goto matched;
+				  }
+# else
+				hcollseq = collseq[cend];
+# endif
+			      }
+
+			    if (lcollseq <= hcollseq && fcollseq <= hcollseq)
+			      goto matched;
+			  }
+# ifdef WIDE_CHAR_VERSION
+		      range_not_matched:
+# endif
+#else
+			/* We use a boring value comparison of the character
+			   values.  This is better than comparing using
+			   `strcoll' since the latter would have surprising
+			   and sometimes fatal consequences.  */
+			UCHAR cend = *p++;
+
+			if (!(flags & FNM_NOESCAPE) && cend == L_('\\'))
+			  cend = *p++;
+			if (cend == L_('\0'))
+			  return FNM_NOMATCH;
+
+			/* It is a range.  */
+			if (cold <= fn && fn <= cend)
+			  goto matched;
+#endif
+
+			c = *p++;
+		      }
+		  }
+
+		if (c == L_(']'))
+		  break;
+	      }
+
+	    if (!not)
+	      return FNM_NOMATCH;
+	    break;
+
+	  matched:
+	    /* Skip the rest of the [...] that already matched.  */
+	    do
+	      {
+	      ignore_next:
+		c = *p++;
+
+		if (c == L_('\0'))
+		  /* [... (unterminated) loses.  */
+		  return FNM_NOMATCH;
+
+		if (!(flags & FNM_NOESCAPE) && c == L_('\\'))
+		  {
+		    if (*p == L_('\0'))
+		      return FNM_NOMATCH;
+		    /* XXX 1003.2d11 is unclear if this is right.  */
+		    ++p;
+		  }
+		else if (c == L_('[') && *p == L_(':'))
+		  {
+		    int c1 = 0;
+		    const CHAR *startp = p;
+
+		    while (1)
+		      {
+			c = *++p;
+			if (++c1 == CHAR_CLASS_MAX_LENGTH)
+			  return FNM_NOMATCH;
+
+			if (*p == L_(':') && p[1] == L_(']'))
+			  break;
+
+			if (c < L_('a') || c >= L_('z'))
+			  {
+			    p = startp;
+			    goto ignore_next;
+			  }
+		      }
+		    p += 2;
+		    c = *p++;
+		  }
+		else if (c == L_('[') && *p == L_('='))
+		  {
+		    c = *++p;
+		    if (c == L_('\0'))
+		      return FNM_NOMATCH;
+		    c = *++p;
+		    if (c != L_('=') || p[1] != L_(']'))
+		      return FNM_NOMATCH;
+		    p += 2;
+		    c = *p++;
+		  }
+		else if (c == L_('[') && *p == L_('.'))
+		  {
+		    ++p;
+		    while (1)
+		      {
+			c = *++p;
+			if (c == '\0')
+			  return FNM_NOMATCH;
+
+			if (*p == L_('.') && p[1] == L_(']'))
+			  break;
+		      }
+		    p += 2;
+		    c = *p++;
+		  }
+	      }
+	    while (c != L_(']'));
+	    if (not)
+	      return FNM_NOMATCH;
+	  }
+	  break;
+
+	case L_('+'):
+	case L_('@'):
+	case L_('!'):
+	  if (__builtin_expect (flags & FNM_EXTMATCH, 0) && *p == '(')
+	    {
+	      int res;
+
+	      res = EXT (c, p, n, string_end, no_leading_period, flags);
+	      if (res != -1)
+		return res;
+	    }
+	  goto normal_match;
+
+	case L_('/'):
+	  if (NO_LEADING_PERIOD (flags))
+	    {
+	      if (n == string_end || c != (UCHAR) *n)
+		return FNM_NOMATCH;
+
+	      new_no_leading_period = true;
+	      break;
+	    }
+	  /* FALLTHROUGH */
+	default:
+	normal_match:
+	  if (n == string_end || c != FOLD ((UCHAR) *n))
+	    return FNM_NOMATCH;
+	}
+
+      no_leading_period = new_no_leading_period;
+      ++n;
+    }
+
+  if (n == string_end)
+    return 0;
+
+  if ((flags & FNM_LEADING_DIR) && n != string_end && *n == L_('/'))
+    /* The FNM_LEADING_DIR flag says that "foo*" matches "foobar/frobozz".  */
+    return 0;
+
+  return FNM_NOMATCH;
+}
+
+
+static const CHAR *
+internal_function
+END (const CHAR *pattern)
+{
+  const CHAR *p = pattern;
+
+  while (1)
+    if (*++p == L_('\0'))
+      /* This is an invalid pattern.  */
+      return pattern;
+    else if (*p == L_('['))
+      {
+	/* Handle brackets special.  */
+	if (posixly_correct == 0)
+	  posixly_correct = getenv ("POSIXLY_CORRECT") != NULL ? 1 : -1;
+
+	/* Skip the not sign.  We have to recognize it because of a possibly
+	   following ']'.  */
+	if (*++p == L_('!') || (posixly_correct < 0 && *p == L_('^')))
+	  ++p;
+	/* A leading ']' is recognized as such.  */
+	if (*p == L_(']'))
+	  ++p;
+	/* Skip over all characters of the list.  */
+	while (*p != L_(']'))
+	  if (*p++ == L_('\0'))
+	    /* This is no valid pattern.  */
+	    return pattern;
+      }
+    else if ((*p == L_('?') || *p == L_('*') || *p == L_('+') || *p == L_('@')
+	      || *p == L_('!')) && p[1] == L_('('))
+      p = END (p + 1);
+    else if (*p == L_(')'))
+      break;
+
+  return p + 1;
+}
+
+
+static int
+internal_function
+EXT (INT opt, const CHAR *pattern, const CHAR *string, const CHAR *string_end,
+     bool no_leading_period, int flags)
+{
+  const CHAR *startp;
+  size_t level;
+  struct patternlist
+  {
+    struct patternlist *next;
+    CHAR str[1];
+  } *list = NULL;
+  struct patternlist **lastp = &list;
+  size_t pattern_len = STRLEN (pattern);
+  const CHAR *p;
+  const CHAR *rs;
+  enum { ALLOCA_LIMIT = 8000 };
+
+  /* Parse the pattern.  Store the individual parts in the list.  */
+  level = 0;
+  for (startp = p = pattern + 1; ; ++p)
+    if (*p == L_('\0'))
+      /* This is an invalid pattern.  */
+      return -1;
+    else if (*p == L_('['))
+      {
+	/* Handle brackets special.  */
+	if (posixly_correct == 0)
+	  posixly_correct = getenv ("POSIXLY_CORRECT") != NULL ? 1 : -1;
+
+	/* Skip the not sign.  We have to recognize it because of a possibly
+	   following ']'.  */
+	if (*++p == L_('!') || (posixly_correct < 0 && *p == L_('^')))
+	  ++p;
+	/* A leading ']' is recognized as such.  */
+	if (*p == L_(']'))
+	  ++p;
+	/* Skip over all characters of the list.  */
+	while (*p != L_(']'))
+	  if (*p++ == L_('\0'))
+	    /* This is no valid pattern.  */
+	    return -1;
+      }
+    else if ((*p == L_('?') || *p == L_('*') || *p == L_('+') || *p == L_('@')
+	      || *p == L_('!')) && p[1] == L_('('))
+      /* Remember the nesting level.  */
+      ++level;
+    else if (*p == L_(')'))
+      {
+	if (level-- == 0)
+	  {
+	    /* This means we found the end of the pattern.  */
+#define NEW_PATTERN \
+	    struct patternlist *newp;					      \
+	    size_t plen;						      \
+	    size_t plensize;						      \
+	    size_t newpsize;						      \
+									      \
+	    plen = (opt == L_('?') || opt == L_('@')			      \
+		    ? pattern_len					      \
+		    : p - startp + 1);					      \
+	    plensize = plen * sizeof (CHAR);				      \
+	    newpsize = offsetof (struct patternlist, str) + plensize;	      \
+	    if ((size_t) -1 / sizeof (CHAR) < plen			      \
+		|| newpsize < offsetof (struct patternlist, str)	      \
+		|| ALLOCA_LIMIT <= newpsize)				      \
+	      return -1;						      \
+	    newp = (struct patternlist *) alloca (newpsize);		      \
+	    *((CHAR *) MEMPCPY (newp->str, startp, p - startp)) = L_('\0');    \
+	    newp->next = NULL;						      \
+	    *lastp = newp;						      \
+	    lastp = &newp->next
+	    NEW_PATTERN;
+	    break;
+	  }
+      }
+    else if (*p == L_('|'))
+      {
+	if (level == 0)
+	  {
+	    NEW_PATTERN;
+	    startp = p + 1;
+	  }
+      }
+  assert (list != NULL);
+  assert (p[-1] == L_(')'));
+#undef NEW_PATTERN
+
+  switch (opt)
+    {
+    case L_('*'):
+      if (FCT (p, string, string_end, no_leading_period, flags) == 0)
+	return 0;
+      /* FALLTHROUGH */
+
+    case L_('+'):
+      do
+	{
+	  for (rs = string; rs <= string_end; ++rs)
+	    /* First match the prefix with the current pattern with the
+	       current pattern.  */
+	    if (FCT (list->str, string, rs, no_leading_period,
+		     flags & FNM_FILE_NAME ? flags : flags & ~FNM_PERIOD) == 0
+		/* This was successful.  Now match the rest with the rest
+		   of the pattern.  */
+		&& (FCT (p, rs, string_end,
+			 rs == string
+			 ? no_leading_period
+			 : rs[-1] == '/' && NO_LEADING_PERIOD (flags),
+			 flags & FNM_FILE_NAME
+			 ? flags : flags & ~FNM_PERIOD) == 0
+		    /* This didn't work.  Try the whole pattern.  */
+		    || (rs != string
+			&& FCT (pattern - 1, rs, string_end,
+				rs == string
+				? no_leading_period
+				: rs[-1] == '/' && NO_LEADING_PERIOD (flags),
+				flags & FNM_FILE_NAME
+				? flags : flags & ~FNM_PERIOD) == 0)))
+	      /* It worked.  Signal success.  */
+	      return 0;
+	}
+      while ((list = list->next) != NULL);
+
+      /* None of the patterns lead to a match.  */
+      return FNM_NOMATCH;
+
+    case L_('?'):
+      if (FCT (p, string, string_end, no_leading_period, flags) == 0)
+	return 0;
+      /* FALLTHROUGH */
+
+    case L_('@'):
+      do
+	/* I cannot believe it but `strcat' is actually acceptable
+	   here.  Match the entire string with the prefix from the
+	   pattern list and the rest of the pattern following the
+	   pattern list.  */
+	if (FCT (STRCAT (list->str, p), string, string_end,
+		 no_leading_period,
+		 flags & FNM_FILE_NAME ? flags : flags & ~FNM_PERIOD) == 0)
+	  /* It worked.  Signal success.  */
+	  return 0;
+      while ((list = list->next) != NULL);
+
+      /* None of the patterns lead to a match.  */
+      return FNM_NOMATCH;
+
+    case L_('!'):
+      for (rs = string; rs <= string_end; ++rs)
+	{
+	  struct patternlist *runp;
+
+	  for (runp = list; runp != NULL; runp = runp->next)
+	    if (FCT (runp->str, string, rs,  no_leading_period,
+		     flags & FNM_FILE_NAME ? flags : flags & ~FNM_PERIOD) == 0)
+	      break;
+
+	  /* If none of the patterns matched see whether the rest does.  */
+	  if (runp == NULL
+	      && (FCT (p, rs, string_end,
+		       rs == string
+		       ? no_leading_period
+		       : rs[-1] == '/' && NO_LEADING_PERIOD (flags),
+		       flags & FNM_FILE_NAME ? flags : flags & ~FNM_PERIOD)
+		  == 0))
+	    /* This is successful.  */
+	    return 0;
+	}
+
+      /* None of the patterns together with the rest of the pattern
+	 lead to a match.  */
+      return FNM_NOMATCH;
+
+    default:
+      assert (! "Invalid extended matching operator");
+      break;
+    }
+
+  return -1;
+}
+
+
+#undef FOLD
+#undef CHAR
+#undef UCHAR
+#undef INT
+#undef FCT
+#undef EXT
+#undef END
+#undef MEMPCPY
+#undef MEMCHR
+#undef STRCOLL
+#undef STRLEN
+#undef STRCAT
+#undef L_
+#undef BTOWC
diff -urN popt-for-windows/lib/getlogin_r.c popt-for-windows-gnulib/lib/getlogin_r.c
--- popt-for-windows/lib/getlogin_r.c	1970-01-01 01:00:00.000000000 +0100
+++ popt-for-windows-gnulib/lib/getlogin_r.c	2008-10-25 15:17:05.000000000 +0100
@@ -0,0 +1,56 @@
+/* Provide a working getlogin_r for systems which lack it.
+
+   Copyright (C) 2005, 2006, 2007 Free Software Foundation, Inc.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software Foundation,
+   Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
+
+/* written by Paul Eggert and Derek Price */
+
+#include <config.h>
+
+/* Specification.  */
+#include <unistd.h>
+
+#include <errno.h>
+#include <string.h>
+
+#if !HAVE_DECL_GETLOGIN
+char *getlogin (void);
+#endif
+
+/* See unistd.in.h for documentation.  */
+int
+getlogin_r (char *name, size_t size)
+{
+  char *n;
+  size_t nlen;
+
+  errno = 0;
+  n = getlogin ();
+
+  /* A system function like getlogin_r is never supposed to set errno
+     to zero, so make sure errno is nonzero here.  ENOENT is a
+     reasonable errno value if getlogin returns NULL.  */
+  if (!errno)
+    errno = ENOENT;
+
+  if (!n)
+    return errno;
+  nlen = strlen (n);
+  if (size <= nlen)
+    return ERANGE;
+  memcpy (name, n, nlen + 1);
+  return 0;
+}
diff -urN popt-for-windows/lib/glob.c popt-for-windows-gnulib/lib/glob.c
--- popt-for-windows/lib/glob.c	1970-01-01 01:00:00.000000000 +0100
+++ popt-for-windows-gnulib/lib/glob.c	2008-10-25 15:17:05.000000000 +0100
@@ -0,0 +1,1548 @@
+/* Copyright (C) 1991-2002, 2003, 2004, 2005, 2006, 2007, 2008
+   Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU General Public
+   License as published by the Free Software Foundation; either
+   version 3 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _LIBC
+# include <config.h>
+#endif
+
+#include <glob.h>
+
+#include <errno.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <stddef.h>
+
+/* Outcomment the following line for production quality code.  */
+/* #define NDEBUG 1 */
+#include <assert.h>
+
+#include <stdbool.h>
+
+#include <stdio.h>		/* Needed on stupid SunOS for assert.  */
+
+#if !defined _LIBC || !defined GLOB_ONLY_P
+
+#include <unistd.h>
+#if !defined POSIX && defined _POSIX_VERSION
+# define POSIX
+#endif
+
+#if (defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__
+# define WINDOWS32
+#endif
+
+#ifndef WINDOWS32
+# include <pwd.h>
+#endif
+
+#include <errno.h>
+#ifndef __set_errno
+# define __set_errno(val) errno = (val)
+#endif
+
+#include <dirent.h>
+
+
+/* In GNU systems, <dirent.h> defines this macro for us.  */
+#ifndef _D_EXACT_NAMLEN
+# define _D_EXACT_NAMLEN(dirent) strlen ((dirent)->d_name)
+#endif
+
+/* When used in the GNU libc the symbol _DIRENT_HAVE_D_TYPE is available
+   if the `d_type' member for `struct dirent' is available.
+   HAVE_STRUCT_DIRENT_D_TYPE plays the same role in GNULIB.  */
+#if defined _DIRENT_HAVE_D_TYPE || defined HAVE_STRUCT_DIRENT_D_TYPE
+/* True if the directory entry D must be of type T.  */
+# define DIRENT_MUST_BE(d, t)	((d)->d_type == (t))
+
+/* True if the directory entry D might be a symbolic link.  */
+# define DIRENT_MIGHT_BE_SYMLINK(d) \
+    ((d)->d_type == DT_UNKNOWN || (d)->d_type == DT_LNK)
+
+/* True if the directory entry D might be a directory.  */
+# define DIRENT_MIGHT_BE_DIR(d)	 \
+    ((d)->d_type == DT_DIR || DIRENT_MIGHT_BE_SYMLINK (d))
+
+#else /* !HAVE_D_TYPE */
+# define DIRENT_MUST_BE(d, t)		false
+# define DIRENT_MIGHT_BE_SYMLINK(d)	true
+# define DIRENT_MIGHT_BE_DIR(d)		true
+#endif /* HAVE_D_TYPE */
+
+/* If the system has the `struct dirent64' type we use it internally.  */
+#if defined _LIBC && !defined COMPILE_GLOB64
+# if (defined POSIX || defined WINDOWS32) && !defined __GNU_LIBRARY__
+#  define CONVERT_D_INO(d64, d32)
+# else
+#  define CONVERT_D_INO(d64, d32) \
+  (d64)->d_ino = (d32)->d_ino;
+# endif
+
+# ifdef _DIRENT_HAVE_D_TYPE
+#  define CONVERT_D_TYPE(d64, d32) \
+  (d64)->d_type = (d32)->d_type;
+# else
+#  define CONVERT_D_TYPE(d64, d32)
+# endif
+
+# define CONVERT_DIRENT_DIRENT64(d64, d32) \
+  memcpy ((d64)->d_name, (d32)->d_name, _D_EXACT_NAMLEN (d32) + 1);	      \
+  CONVERT_D_INO (d64, d32)						      \
+  CONVERT_D_TYPE (d64, d32)
+#endif
+
+
+#if (defined POSIX || defined WINDOWS32) && !defined __GNU_LIBRARY__
+/* Posix does not require that the d_ino field be present, and some
+   systems do not provide it. */
+# define REAL_DIR_ENTRY(dp) 1
+#else
+# define REAL_DIR_ENTRY(dp) (dp->d_ino != 0)
+#endif /* POSIX */
+
+#include <stdlib.h>
+#include <string.h>
+
+/* NAME_MAX is usually defined in <dirent.h> or <limits.h>.  */
+#include <limits.h>
+#ifndef NAME_MAX
+# define NAME_MAX (sizeof (((struct dirent *) 0)->d_name))
+#endif
+
+#include <alloca.h>
+
+#ifdef _LIBC
+# undef strdup
+# define strdup(str) __strdup (str)
+# define sysconf(id) __sysconf (id)
+# define closedir(dir) __closedir (dir)
+# define opendir(name) __opendir (name)
+# define readdir(str) __readdir64 (str)
+# define getpwnam_r(name, bufp, buf, len, res) \
+   __getpwnam_r (name, bufp, buf, len, res)
+# ifndef __stat64
+#  define __stat64(fname, buf) __xstat64 (_STAT_VER, fname, buf)
+# endif
+# define struct_stat64		struct stat64
+#else /* !_LIBC */
+# define __stat64(fname, buf)	stat (fname, buf)
+# define __fxstatat64(_, d, f, st, flag) fstatat (d, f, st, flag)
+# define struct_stat64		struct stat
+# define __stat(fname, buf)	stat (fname, buf)
+# define __alloca		alloca
+# define __readdir		readdir
+# define __readdir64		readdir64
+# define __glob_pattern_p	glob_pattern_p
+#endif /* _LIBC */
+
+#include <fnmatch.h>
+
+#ifdef _SC_GETPW_R_SIZE_MAX
+# define GETPW_R_SIZE_MAX()	sysconf (_SC_GETPW_R_SIZE_MAX)
+#else
+# define GETPW_R_SIZE_MAX()	(-1)
+#endif
+#ifdef _SC_LOGIN_NAME_MAX
+# define GET_LOGIN_NAME_MAX()	sysconf (_SC_LOGIN_NAME_MAX)
+#else
+# define GET_LOGIN_NAME_MAX()	(-1)
+#endif
+
+static const char *next_brace_sub (const char *begin, int flags) __THROW;
+
+#endif /* !defined _LIBC || !defined GLOB_ONLY_P */
+
+#ifndef attribute_hidden
+# define attribute_hidden
+#endif
+
+#ifndef __attribute_noinline__
+# if __GNUC__ < 3 || (__GNUC__ == 3 && __GNUC_MINOR__ < 1)
+#  define __attribute_noinline__ /* Ignore */
+#else
+#  define __attribute_noinline__ __attribute__ ((__noinline__))
+# endif
+#endif
+
+#if ! defined __builtin_expect && __GNUC__ < 3
+# define __builtin_expect(expr, expected) (expr)
+#endif
+
+#ifndef _LIBC
+/* The results of opendir() in this file are not used with dirfd and fchdir,
+   therefore save some unnecessary work in fchdir.c.  */
+# undef opendir
+# undef closedir
+
+# if HAVE_ALLOCA
+/* The OS usually guarantees only one guard page at the bottom of the stack,
+   and a page size can be as small as 4096 bytes.  So we cannot safely
+   allocate anything larger than 4096 bytes.  Also care for the possibility
+   of a few compiler-allocated temporary stack slots.  */
+#  define __libc_use_alloca(n) ((n) < 4032)
+# else
+/* alloca is implemented with malloc, so just use malloc.  */
+#  define __libc_use_alloca(n) 0
+# endif
+#endif
+
+static int glob_in_dir (const char *pattern, const char *directory,
+			int flags, int (*errfunc) (const char *, int),
+			glob_t *pglob);
+extern int __glob_pattern_type (const char *pattern, int quote)
+    attribute_hidden;
+
+#if !defined _LIBC || !defined GLOB_ONLY_P
+static int prefix_array (const char *prefix, char **array, size_t n) __THROW;
+static int collated_compare (const void *, const void *) __THROW;
+
+
+/* Find the end of the sub-pattern in a brace expression.  */
+static const char *
+next_brace_sub (const char *cp, int flags)
+{
+  unsigned int depth = 0;
+  while (*cp != '\0')
+    if ((flags & GLOB_NOESCAPE) == 0 && *cp == '\\')
+      {
+	if (*++cp == '\0')
+	  break;
+	++cp;
+      }
+    else
+      {
+	if ((*cp == '}' && depth-- == 0) || (*cp == ',' && depth == 0))
+	  break;
+
+	if (*cp++ == '{')
+	  depth++;
+      }
+
+  return *cp != '\0' ? cp : NULL;
+}
+
+#endif /* !defined _LIBC || !defined GLOB_ONLY_P */
+
+/* Do glob searching for PATTERN, placing results in PGLOB.
+   The bits defined above may be set in FLAGS.
+   If a directory cannot be opened or read and ERRFUNC is not nil,
+   it is called with the pathname that caused the error, and the
+   `errno' value from the failing call; if it returns non-zero
+   `glob' returns GLOB_ABORTED; if it returns zero, the error is ignored.
+   If memory cannot be allocated for PGLOB, GLOB_NOSPACE is returned.
+   Otherwise, `glob' returns zero.  */
+int
+#ifdef GLOB_ATTRIBUTE
+GLOB_ATTRIBUTE
+#endif
+glob (pattern, flags, errfunc, pglob)
+     const char * restrict pattern;
+     int flags;
+     int (*errfunc) (const char *, int);
+     glob_t * restrict pglob;
+{
+  const char *filename;
+  const char *dirname;
+  size_t dirlen;
+  int status;
+  size_t oldcount;
+  int meta;
+  int dirname_modified;
+  glob_t dirs;
+
+  if (pattern == NULL || pglob == NULL || (flags & ~__GLOB_FLAGS) != 0)
+    {
+      __set_errno (EINVAL);
+      return -1;
+    }
+
+  if (!(flags & GLOB_DOOFFS))
+    /* Have to do this so `globfree' knows where to start freeing.  It
+       also makes all the code that uses gl_offs simpler. */
+    pglob->gl_offs = 0;
+
+  if (flags & GLOB_BRACE)
+    {
+      const char *begin;
+
+      if (flags & GLOB_NOESCAPE)
+	begin = strchr (pattern, '{');
+      else
+	{
+	  begin = pattern;
+	  while (1)
+	    {
+	      if (*begin == '\0')
+		{
+		  begin = NULL;
+		  break;
+		}
+
+	      if (*begin == '\\' && begin[1] != '\0')
+		++begin;
+	      else if (*begin == '{')
+		break;
+
+	      ++begin;
+	    }
+	}
+
+      if (begin != NULL)
+	{
+	  /* Allocate working buffer large enough for our work.  Note that
+	    we have at least an opening and closing brace.  */
+	  size_t firstc;
+	  char *alt_start;
+	  const char *p;
+	  const char *next;
+	  const char *rest;
+	  size_t rest_len;
+#ifdef __GNUC__
+	  char onealt[strlen (pattern) - 1];
+#else
+	  char *onealt = malloc (strlen (pattern) - 1);
+	  if (onealt == NULL)
+	    {
+	      if (!(flags & GLOB_APPEND))
+		{
+		  pglob->gl_pathc = 0;
+		  pglob->gl_pathv = NULL;
+		}
+	      return GLOB_NOSPACE;
+	    }
+#endif
+
+	  /* We know the prefix for all sub-patterns.  */
+	  alt_start = mempcpy (onealt, pattern, begin - pattern);
+
+	  /* Find the first sub-pattern and at the same time find the
+	     rest after the closing brace.  */
+	  next = next_brace_sub (begin + 1, flags);
+	  if (next == NULL)
+	    {
+	      /* It is an invalid expression.  */
+#ifndef __GNUC__
+	      free (onealt);
+#endif
+	      return glob (pattern, flags & ~GLOB_BRACE, errfunc, pglob);
+	    }
+
+	  /* Now find the end of the whole brace expression.  */
+	  rest = next;
+	  while (*rest != '}')
+	    {
+	      rest = next_brace_sub (rest + 1, flags);
+	      if (rest == NULL)
+		{
+		  /* It is an invalid expression.  */
+#ifndef __GNUC__
+		  free (onealt);
+#endif
+		  return glob (pattern, flags & ~GLOB_BRACE, errfunc, pglob);
+		}
+	    }
+	  /* Please note that we now can be sure the brace expression
+	     is well-formed.  */
+	  rest_len = strlen (++rest) + 1;
+
+	  /* We have a brace expression.  BEGIN points to the opening {,
+	     NEXT points past the terminator of the first element, and END
+	     points past the final }.  We will accumulate result names from
+	     recursive runs for each brace alternative in the buffer using
+	     GLOB_APPEND.  */
+
+	  if (!(flags & GLOB_APPEND))
+	    {
+	      /* This call is to set a new vector, so clear out the
+		 vector so we can append to it.  */
+	      pglob->gl_pathc = 0;
+	      pglob->gl_pathv = NULL;
+	    }
+	  firstc = pglob->gl_pathc;
+
+	  p = begin + 1;
+	  while (1)
+	    {
+	      int result;
+
+	      /* Construct the new glob expression.  */
+	      mempcpy (mempcpy (alt_start, p, next - p), rest, rest_len);
+
+	      result = glob (onealt,
+			     ((flags & ~(GLOB_NOCHECK | GLOB_NOMAGIC))
+			      | GLOB_APPEND), errfunc, pglob);
+
+	      /* If we got an error, return it.  */
+	      if (result && result != GLOB_NOMATCH)
+		{
+#ifndef __GNUC__
+		  free (onealt);
+#endif
+		  if (!(flags & GLOB_APPEND))
+		    {
+		      globfree (pglob);
+		      pglob->gl_pathc = 0;
+		    }
+		  return result;
+		}
+
+	      if (*next == '}')
+		/* We saw the last entry.  */
+		break;
+
+	      p = next + 1;
+	      next = next_brace_sub (p, flags);
+	      assert (next != NULL);
+	    }
+
+#ifndef __GNUC__
+	  free (onealt);
+#endif
+
+	  if (pglob->gl_pathc != firstc)
+	    /* We found some entries.  */
+	    return 0;
+	  else if (!(flags & (GLOB_NOCHECK|GLOB_NOMAGIC)))
+	    return GLOB_NOMATCH;
+	}
+    }
+
+  /* Find the filename.  */
+  filename = strrchr (pattern, '/');
+#if defined __MSDOS__ || defined WINDOWS32
+  /* The case of "d:pattern".  Since `:' is not allowed in
+     file names, we can safely assume that wherever it
+     happens in pattern, it signals the filename part.  This
+     is so we could some day support patterns like "[a-z]:foo".  */
+  if (filename == NULL)
+    filename = strchr (pattern, ':');
+#endif /* __MSDOS__ || WINDOWS32 */
+  dirname_modified = 0;
+  if (filename == NULL)
+    {
+      /* This can mean two things: a simple name or "~name".  The latter
+	 case is nothing but a notation for a directory.  */
+      if ((flags & (GLOB_TILDE|GLOB_TILDE_CHECK)) && pattern[0] == '~')
+	{
+	  dirname = pattern;
+	  dirlen = strlen (pattern);
+
+	  /* Set FILENAME to NULL as a special flag.  This is ugly but
+	     other solutions would require much more code.  We test for
+	     this special case below.  */
+	  filename = NULL;
+	}
+      else
+	{
+	  filename = pattern;
+#ifdef _AMIGA
+	  dirname = "";
+#else
+	  dirname = ".";
+#endif
+	  dirlen = 0;
+	}
+    }
+  else if (filename == pattern
+	   || (filename == pattern + 1 && pattern[0] == '\\'
+	       && (flags & GLOB_NOESCAPE) == 0))
+    {
+      /* "/pattern" or "\\/pattern".  */
+      dirname = "/";
+      dirlen = 1;
+      ++filename;
+    }
+  else
+    {
+      char *newp;
+      dirlen = filename - pattern;
+#if defined __MSDOS__ || defined WINDOWS32
+      if (*filename == ':'
+	  || (filename > pattern + 1 && filename[-1] == ':'))
+	{
+	  char *drive_spec;
+
+	  ++dirlen;
+	  drive_spec = __alloca (dirlen + 1);
+	  *((char *) mempcpy (drive_spec, pattern, dirlen)) = '\0';
+	  /* For now, disallow wildcards in the drive spec, to
+	     prevent infinite recursion in glob.  */
+	  if (__glob_pattern_p (drive_spec, !(flags & GLOB_NOESCAPE)))
+	    return GLOB_NOMATCH;
+	  /* If this is "d:pattern", we need to copy `:' to DIRNAME
+	     as well.  If it's "d:/pattern", don't remove the slash
+	     from "d:/", since "d:" and "d:/" are not the same.*/
+	}
+#endif
+      newp = __alloca (dirlen + 1);
+      *((char *) mempcpy (newp, pattern, dirlen)) = '\0';
+      dirname = newp;
+      ++filename;
+
+      if (filename[0] == '\0'
+#if defined __MSDOS__ || defined WINDOWS32
+          && dirname[dirlen - 1] != ':'
+	  && (dirlen < 3 || dirname[dirlen - 2] != ':'
+	      || dirname[dirlen - 1] != '/')
+#endif
+	  && dirlen > 1)
+	/* "pattern/".  Expand "pattern", appending slashes.  */
+	{
+	  int orig_flags = flags;
+	  int val;
+	  if (!(flags & GLOB_NOESCAPE) && dirname[dirlen - 1] == '\\')
+	    {
+	      /* "pattern\\/".  Remove the final backslash if it hasn't
+		 been quoted.  */
+	      char *p = (char *) &dirname[dirlen - 1];
+
+	      while (p > dirname && p[-1] == '\\') --p;
+	      if ((&dirname[dirlen] - p) & 1)
+		{
+		  *(char *) &dirname[--dirlen] = '\0';
+		  flags &= ~(GLOB_NOCHECK | GLOB_NOMAGIC);
+		}
+	    }
+	  val = glob (dirname, flags | GLOB_MARK, errfunc, pglob);
+	  if (val == 0)
+	    pglob->gl_flags = ((pglob->gl_flags & ~GLOB_MARK)
+			       | (flags & GLOB_MARK));
+	  else if (val == GLOB_NOMATCH && flags != orig_flags)
+	    {
+	      /* Make sure globfree (&dirs); is a nop.  */
+	      dirs.gl_pathv = NULL;
+	      flags = orig_flags;
+	      oldcount = pglob->gl_pathc + pglob->gl_offs;
+	      goto no_matches;
+	    }
+	  return val;
+	}
+    }
+
+  if (!(flags & GLOB_APPEND))
+    {
+      pglob->gl_pathc = 0;
+      if (!(flags & GLOB_DOOFFS))
+        pglob->gl_pathv = NULL;
+      else
+	{
+	  size_t i;
+	  pglob->gl_pathv = malloc ((pglob->gl_offs + 1) * sizeof (char *));
+	  if (pglob->gl_pathv == NULL)
+	    return GLOB_NOSPACE;
+
+	  for (i = 0; i <= pglob->gl_offs; ++i)
+	    pglob->gl_pathv[i] = NULL;
+	}
+    }
+
+  oldcount = pglob->gl_pathc + pglob->gl_offs;
+
+  if ((flags & (GLOB_TILDE|GLOB_TILDE_CHECK)) && dirname[0] == '~')
+    {
+      if (dirname[1] == '\0' || dirname[1] == '/'
+	  || (!(flags & GLOB_NOESCAPE) && dirname[1] == '\\'
+	      && (dirname[2] == '\0' || dirname[2] == '/')))
+	{
+	  /* Look up home directory.  */
+	  const char *home_dir = getenv ("HOME");
+# ifdef _AMIGA
+	  if (home_dir == NULL || home_dir[0] == '\0')
+	    home_dir = "SYS:";
+# else
+#  ifdef WINDOWS32
+	  /* Windows NT defines HOMEDRIVE and HOMEPATH.  But give preference
+	     to HOME, because the user can change HOME.  */
+	  if (home_dir == NULL || home_dir[0] == '\0')
+	    {
+	      const char *home_drive = getenv ("HOMEDRIVE");
+	      const char *home_path = getenv ("HOMEPATH");
+
+	      if (home_drive != NULL && home_path != NULL)
+		{
+		  size_t home_drive_len = strlen (home_drive);
+		  size_t home_path_len = strlen (home_path);
+		  char *mem = alloca (home_drive_len + home_path_len + 1);
+
+		  memcpy (mem, home_drive, home_drive_len);
+		  memcpy (mem + home_drive_len, home_path, home_path_len + 1);
+		  home_dir = mem;
+		}
+	      else
+		home_dir = "c:/users/default"; /* poor default */
+	    }
+#  else
+	  if (home_dir == NULL || home_dir[0] == '\0')
+	    {
+	      int success;
+	      char *name;
+	      size_t buflen = GET_LOGIN_NAME_MAX () + 1;
+
+	      if (buflen == 0)
+		/* `sysconf' does not support _SC_LOGIN_NAME_MAX.  Try
+		   a moderate value.  */
+		buflen = 20;
+	      name = __alloca (buflen);
+
+	      success = getlogin_r (name, buflen) == 0;
+	      if (success)
+		{
+		  struct passwd *p;
+#   if defined HAVE_GETPWNAM_R || defined _LIBC
+		  long int pwbuflen = GETPW_R_SIZE_MAX ();
+		  char *pwtmpbuf;
+		  struct passwd pwbuf;
+		  int save = errno;
+
+#    ifndef _LIBC
+		  if (pwbuflen == -1)
+		    /* `sysconf' does not support _SC_GETPW_R_SIZE_MAX.
+		       Try a moderate value.  */
+		    pwbuflen = 1024;
+#    endif
+		  pwtmpbuf = __alloca (pwbuflen);
+
+		  while (getpwnam_r (name, &pwbuf, pwtmpbuf, pwbuflen, &p)
+			 != 0)
+		    {
+		      if (errno != ERANGE)
+			{
+			  p = NULL;
+			  break;
+			}
+#    ifdef _LIBC
+		      pwtmpbuf = extend_alloca (pwtmpbuf, pwbuflen,
+						2 * pwbuflen);
+#    else
+		      pwbuflen *= 2;
+		      pwtmpbuf = __alloca (pwbuflen);
+#    endif
+		      __set_errno (save);
+		    }
+#   else
+		  p = getpwnam (name);
+#   endif
+		  if (p != NULL)
+		    home_dir = p->pw_dir;
+		}
+	    }
+	  if (home_dir == NULL || home_dir[0] == '\0')
+	    {
+	      if (flags & GLOB_TILDE_CHECK)
+		return GLOB_NOMATCH;
+	      else
+		home_dir = "~"; /* No luck.  */
+	    }
+#  endif /* WINDOWS32 */
+# endif
+	  /* Now construct the full directory.  */
+	  if (dirname[1] == '\0')
+	    {
+	      dirname = home_dir;
+	      dirlen = strlen (dirname);
+	    }
+	  else
+	    {
+	      char *newp;
+	      size_t home_len = strlen (home_dir);
+	      newp = __alloca (home_len + dirlen);
+	      mempcpy (mempcpy (newp, home_dir, home_len),
+		       &dirname[1], dirlen);
+	      dirname = newp;
+	      dirlen += home_len - 1;
+	    }
+	  dirname_modified = 1;
+	}
+# if !defined _AMIGA && !defined WINDOWS32
+      else
+	{
+	  char *end_name = strchr (dirname, '/');
+	  const char *user_name;
+	  const char *home_dir;
+	  char *unescape = NULL;
+
+	  if (!(flags & GLOB_NOESCAPE))
+	    {
+	      if (end_name == NULL)
+		{
+		  unescape = strchr (dirname, '\\');
+		  if (unescape)
+		    end_name = strchr (unescape, '\0');
+		}
+	      else
+		unescape = memchr (dirname, '\\', end_name - dirname);
+	    }
+	  if (end_name == NULL)
+	    user_name = dirname + 1;
+	  else
+	    {
+	      char *newp;
+	      newp = __alloca (end_name - dirname);
+	      *((char *) mempcpy (newp, dirname + 1, end_name - dirname))
+		= '\0';
+	      if (unescape != NULL)
+		{
+		  char *p = mempcpy (newp, dirname + 1,
+				     unescape - dirname - 1);
+		  char *q = unescape;
+		  while (*q != '\0')
+		    {
+		      if (*q == '\\')
+			{
+			  if (q[1] == '\0')
+			    {
+			      /* "~fo\\o\\" unescape to user_name "foo\\",
+				 but "~fo\\o\\/" unescape to user_name
+				 "foo".  */
+			      if (filename == NULL)
+				*p++ = '\\';
+			      break;
+			    }
+			  ++q;
+			}
+		      *p++ = *q++;
+		    }
+		  *p = '\0';
+		}
+	      else
+		*((char *) mempcpy (newp, dirname + 1, end_name - dirname))
+		  = '\0';
+	      user_name = newp;
+	    }
+
+	  /* Look up specific user's home directory.  */
+	  {
+	    struct passwd *p;
+#  if defined HAVE_GETPWNAM_R || defined _LIBC
+	    long int buflen = GETPW_R_SIZE_MAX ();
+	    char *pwtmpbuf;
+	    struct passwd pwbuf;
+	    int save = errno;
+
+#   ifndef _LIBC
+	    if (buflen == -1)
+	      /* `sysconf' does not support _SC_GETPW_R_SIZE_MAX.  Try a
+		 moderate value.  */
+	      buflen = 1024;
+#   endif
+	    pwtmpbuf = __alloca (buflen);
+
+	    while (getpwnam_r (user_name, &pwbuf, pwtmpbuf, buflen, &p) != 0)
+	      {
+		if (errno != ERANGE)
+		  {
+		    p = NULL;
+		    break;
+		  }
+#   ifdef _LIBC
+		pwtmpbuf = extend_alloca (pwtmpbuf, buflen, 2 * buflen);
+#   else
+		buflen *= 2;
+		pwtmpbuf = __alloca (buflen);
+#   endif
+		__set_errno (save);
+	      }
+#  else
+	    p = getpwnam (user_name);
+#  endif
+	    if (p != NULL)
+	      home_dir = p->pw_dir;
+	    else
+	      home_dir = NULL;
+	  }
+	  /* If we found a home directory use this.  */
+	  if (home_dir != NULL)
+	    {
+	      char *newp;
+	      size_t home_len = strlen (home_dir);
+	      size_t rest_len = end_name == NULL ? 0 : strlen (end_name);
+	      newp = __alloca (home_len + rest_len + 1);
+	      *((char *) mempcpy (mempcpy (newp, home_dir, home_len),
+				  end_name, rest_len)) = '\0';
+	      dirname = newp;
+	      dirlen = home_len + rest_len;
+	      dirname_modified = 1;
+	    }
+	  else
+	    if (flags & GLOB_TILDE_CHECK)
+	      /* We have to regard it as an error if we cannot find the
+		 home directory.  */
+	      return GLOB_NOMATCH;
+	}
+# endif	/* Not Amiga && not WINDOWS32.  */
+    }
+
+  /* Now test whether we looked for "~" or "~NAME".  In this case we
+     can give the answer now.  */
+  if (filename == NULL)
+    {
+      struct stat st;
+      struct_stat64 st64;
+
+      /* Return the directory if we don't check for error or if it exists.  */
+      if ((flags & GLOB_NOCHECK)
+	  || (((__builtin_expect (flags & GLOB_ALTDIRFUNC, 0))
+	       ? ((*pglob->gl_stat) (dirname, &st) == 0
+		  && S_ISDIR (st.st_mode))
+	       : (__stat64 (dirname, &st64) == 0 && S_ISDIR (st64.st_mode)))))
+	{
+	  int newcount = pglob->gl_pathc + pglob->gl_offs;
+	  char **new_gl_pathv;
+
+	  new_gl_pathv
+	    = realloc (pglob->gl_pathv, (newcount + 1 + 1) * sizeof (char *));
+	  if (new_gl_pathv == NULL)
+	    {
+	    nospace:
+	      free (pglob->gl_pathv);
+	      pglob->gl_pathv = NULL;
+	      pglob->gl_pathc = 0;
+	      return GLOB_NOSPACE;
+	    }
+	  pglob->gl_pathv = new_gl_pathv;
+
+	  if (flags & GLOB_MARK)
+	    {
+	      char *p;
+	      pglob->gl_pathv[newcount] = malloc (dirlen + 2);
+	      if (pglob->gl_pathv[newcount] == NULL)
+		goto nospace;
+	      p = mempcpy (pglob->gl_pathv[newcount], dirname, dirlen);
+	      p[0] = '/';
+	      p[1] = '\0';
+	    }
+	  else
+	    {
+	      pglob->gl_pathv[newcount] = strdup (dirname);
+	      if (pglob->gl_pathv[newcount] == NULL)
+		goto nospace;
+	    }
+	  pglob->gl_pathv[++newcount] = NULL;
+	  ++pglob->gl_pathc;
+	  pglob->gl_flags = flags;
+
+	  return 0;
+	}
+
+      /* Not found.  */
+      return GLOB_NOMATCH;
+    }
+
+  meta = __glob_pattern_type (dirname, !(flags & GLOB_NOESCAPE));
+  /* meta is 1 if correct glob pattern containing metacharacters.
+     If meta has bit (1 << 2) set, it means there was an unterminated
+     [ which we handle the same, using fnmatch.  Broken unterminated
+     pattern bracket expressions ought to be rare enough that it is
+     not worth special casing them, fnmatch will do the right thing.  */
+  if (meta & 5)
+    {
+      /* The directory name contains metacharacters, so we
+	 have to glob for the directory, and then glob for
+	 the pattern in each directory found.  */
+      size_t i;
+
+      if (!(flags & GLOB_NOESCAPE) && dirlen > 0 && dirname[dirlen - 1] == '\\')
+	{
+	  /* "foo\\/bar".  Remove the final backslash from dirname
+	     if it has not been quoted.  */
+	  char *p = (char *) &dirname[dirlen - 1];
+
+	  while (p > dirname && p[-1] == '\\') --p;
+	  if ((&dirname[dirlen] - p) & 1)
+	    *(char *) &dirname[--dirlen] = '\0';
+	}
+
+      if (__builtin_expect ((flags & GLOB_ALTDIRFUNC) != 0, 0))
+	{
+	  /* Use the alternative access functions also in the recursive
+	     call.  */
+	  dirs.gl_opendir = pglob->gl_opendir;
+	  dirs.gl_readdir = pglob->gl_readdir;
+	  dirs.gl_closedir = pglob->gl_closedir;
+	  dirs.gl_stat = pglob->gl_stat;
+	  dirs.gl_lstat = pglob->gl_lstat;
+	}
+
+      status = glob (dirname,
+		     ((flags & (GLOB_ERR | GLOB_NOESCAPE
+				| GLOB_ALTDIRFUNC))
+		      | GLOB_NOSORT | GLOB_ONLYDIR),
+		     errfunc, &dirs);
+      if (status != 0)
+	{
+	  if ((flags & GLOB_NOCHECK) == 0 || status != GLOB_NOMATCH)
+	    return status;
+	  goto no_matches;
+	}
+
+      /* We have successfully globbed the preceding directory name.
+	 For each name we found, call glob_in_dir on it and FILENAME,
+	 appending the results to PGLOB.  */
+      for (i = 0; i < dirs.gl_pathc; ++i)
+	{
+	  int old_pathc;
+
+#ifdef	SHELL
+	  {
+	    /* Make globbing interruptible in the bash shell. */
+	    extern int interrupt_state;
+
+	    if (interrupt_state)
+	      {
+		globfree (&dirs);
+		return GLOB_ABORTED;
+	      }
+	  }
+#endif /* SHELL.  */
+
+	  old_pathc = pglob->gl_pathc;
+	  status = glob_in_dir (filename, dirs.gl_pathv[i],
+				((flags | GLOB_APPEND)
+				 & ~(GLOB_NOCHECK | GLOB_NOMAGIC)),
+				errfunc, pglob);
+	  if (status == GLOB_NOMATCH)
+	    /* No matches in this directory.  Try the next.  */
+	    continue;
+
+	  if (status != 0)
+	    {
+	      globfree (&dirs);
+	      globfree (pglob);
+	      pglob->gl_pathc = 0;
+	      return status;
+	    }
+
+	  /* Stick the directory on the front of each name.  */
+	  if (prefix_array (dirs.gl_pathv[i],
+			    &pglob->gl_pathv[old_pathc + pglob->gl_offs],
+			    pglob->gl_pathc - old_pathc))
+	    {
+	      globfree (&dirs);
+	      globfree (pglob);
+	      pglob->gl_pathc = 0;
+	      return GLOB_NOSPACE;
+	    }
+	}
+
+      flags |= GLOB_MAGCHAR;
+
+      /* We have ignored the GLOB_NOCHECK flag in the `glob_in_dir' calls.
+	 But if we have not found any matching entry and the GLOB_NOCHECK
+	 flag was set we must return the input pattern itself.  */
+      if (pglob->gl_pathc + pglob->gl_offs == oldcount)
+	{
+	no_matches:
+	  /* No matches.  */
+	  if (flags & GLOB_NOCHECK)
+	    {
+	      int newcount = pglob->gl_pathc + pglob->gl_offs;
+	      char **new_gl_pathv;
+
+	      new_gl_pathv = realloc (pglob->gl_pathv,
+				      (newcount + 2) * sizeof (char *));
+	      if (new_gl_pathv == NULL)
+		{
+		  globfree (&dirs);
+		  return GLOB_NOSPACE;
+		}
+	      pglob->gl_pathv = new_gl_pathv;
+
+	      pglob->gl_pathv[newcount] = strdup (pattern);
+	      if (pglob->gl_pathv[newcount] == NULL)
+		{
+		  globfree (&dirs);
+		  globfree (pglob);
+		  pglob->gl_pathc = 0;
+		  return GLOB_NOSPACE;
+		}
+
+	      ++pglob->gl_pathc;
+	      ++newcount;
+
+	      pglob->gl_pathv[newcount] = NULL;
+	      pglob->gl_flags = flags;
+	    }
+	  else
+	    {
+	      globfree (&dirs);
+	      return GLOB_NOMATCH;
+	    }
+	}
+
+      globfree (&dirs);
+    }
+  else
+    {
+      int old_pathc = pglob->gl_pathc;
+      int orig_flags = flags;
+
+      if (meta & 2)
+	{
+	  char *p = strchr (dirname, '\\'), *q;
+	  /* We need to unescape the dirname string.  It is certainly
+	     allocated by alloca, as otherwise filename would be NULL
+	     or dirname wouldn't contain backslashes.  */
+	  q = p;
+	  do
+	    {
+	      if (*p == '\\')
+		{
+		  *q = *++p;
+		  --dirlen;
+		}
+	      else
+		*q = *p;
+	      ++q;
+	    }
+	  while (*p++ != '\0');
+	  dirname_modified = 1;
+	}
+      if (dirname_modified)
+	flags &= ~(GLOB_NOCHECK | GLOB_NOMAGIC);
+      status = glob_in_dir (filename, dirname, flags, errfunc, pglob);
+      if (status != 0)
+	{
+	  if (status == GLOB_NOMATCH && flags != orig_flags
+	      && pglob->gl_pathc + pglob->gl_offs == oldcount)
+	    {
+	      /* Make sure globfree (&dirs); is a nop.  */
+	      dirs.gl_pathv = NULL;
+	      flags = orig_flags;
+	      goto no_matches;
+	    }
+	  return status;
+	}
+
+      if (dirlen > 0)
+	{
+	  /* Stick the directory on the front of each name.  */
+	  if (prefix_array (dirname,
+			    &pglob->gl_pathv[old_pathc + pglob->gl_offs],
+			    pglob->gl_pathc - old_pathc))
+	    {
+	      globfree (pglob);
+	      pglob->gl_pathc = 0;
+	      return GLOB_NOSPACE;
+	    }
+	}
+    }
+
+  if (flags & GLOB_MARK)
+    {
+      /* Append slashes to directory names.  */
+      size_t i;
+      struct stat st;
+      struct_stat64 st64;
+
+      for (i = oldcount; i < pglob->gl_pathc + pglob->gl_offs; ++i)
+	if ((__builtin_expect (flags & GLOB_ALTDIRFUNC, 0)
+	     ? ((*pglob->gl_stat) (pglob->gl_pathv[i], &st) == 0
+		&& S_ISDIR (st.st_mode))
+	     : (__stat64 (pglob->gl_pathv[i], &st64) == 0
+		&& S_ISDIR (st64.st_mode))))
+	  {
+ 	    size_t len = strlen (pglob->gl_pathv[i]) + 2;
+	    char *new = realloc (pglob->gl_pathv[i], len);
+ 	    if (new == NULL)
+	      {
+		globfree (pglob);
+		pglob->gl_pathc = 0;
+		return GLOB_NOSPACE;
+	      }
+	    strcpy (&new[len - 2], "/");
+	    pglob->gl_pathv[i] = new;
+	  }
+    }
+
+  if (!(flags & GLOB_NOSORT))
+    {
+      /* Sort the vector.  */
+      qsort (&pglob->gl_pathv[oldcount],
+	     pglob->gl_pathc + pglob->gl_offs - oldcount,
+	     sizeof (char *), collated_compare);
+    }
+
+  return 0;
+}
+#if defined _LIBC && !defined glob
+libc_hidden_def (glob)
+#endif
+
+
+#if !defined _LIBC || !defined GLOB_ONLY_P
+
+/* Free storage allocated in PGLOB by a previous `glob' call.  */
+void
+globfree (pglob)
+     register glob_t *pglob;
+{
+  if (pglob->gl_pathv != NULL)
+    {
+      size_t i;
+      for (i = 0; i < pglob->gl_pathc; ++i)
+	if (pglob->gl_pathv[pglob->gl_offs + i] != NULL)
+	  free (pglob->gl_pathv[pglob->gl_offs + i]);
+      free (pglob->gl_pathv);
+      pglob->gl_pathv = NULL;
+    }
+}
+#if defined _LIBC && !defined globfree
+libc_hidden_def (globfree)
+#endif
+
+
+/* Do a collated comparison of A and B.  */
+static int
+collated_compare (const void *a, const void *b)
+{
+  char *const *ps1 = a; char *s1 = *ps1;
+  char *const *ps2 = b; char *s2 = *ps2;
+
+  if (s1 == s2)
+    return 0;
+  if (s1 == NULL)
+    return 1;
+  if (s2 == NULL)
+    return -1;
+  return strcoll (s1, s2);
+}
+
+
+/* Prepend DIRNAME to each of N members of ARRAY, replacing ARRAY's
+   elements in place.  Return nonzero if out of memory, zero if successful.
+   A slash is inserted between DIRNAME and each elt of ARRAY,
+   unless DIRNAME is just "/".  Each old element of ARRAY is freed.  */
+static int
+prefix_array (const char *dirname, char **array, size_t n)
+{
+  register size_t i;
+  size_t dirlen = strlen (dirname);
+#if defined __MSDOS__ || defined WINDOWS32
+  int sep_char = '/';
+# define DIRSEP_CHAR sep_char
+#else
+# define DIRSEP_CHAR '/'
+#endif
+
+  if (dirlen == 1 && dirname[0] == '/')
+    /* DIRNAME is just "/", so normal prepending would get us "//foo".
+       We want "/foo" instead, so don't prepend any chars from DIRNAME.  */
+    dirlen = 0;
+#if defined __MSDOS__ || defined WINDOWS32
+  else if (dirlen > 1)
+    {
+      if (dirname[dirlen - 1] == '/' && dirname[dirlen - 2] == ':')
+	/* DIRNAME is "d:/".  Don't prepend the slash from DIRNAME.  */
+	--dirlen;
+      else if (dirname[dirlen - 1] == ':')
+	{
+	  /* DIRNAME is "d:".  Use `:' instead of `/'.  */
+	  --dirlen;
+	  sep_char = ':';
+	}
+    }
+#endif
+
+  for (i = 0; i < n; ++i)
+    {
+      size_t eltlen = strlen (array[i]) + 1;
+      char *new = malloc (dirlen + 1 + eltlen);
+      if (new == NULL)
+	{
+	  while (i > 0)
+	    free (array[--i]);
+	  return 1;
+	}
+
+      {
+	char *endp = mempcpy (new, dirname, dirlen);
+	*endp++ = DIRSEP_CHAR;
+	mempcpy (endp, array[i], eltlen);
+      }
+      free (array[i]);
+      array[i] = new;
+    }
+
+  return 0;
+}
+
+
+/* We must not compile this function twice.  */
+#if !defined _LIBC || !defined NO_GLOB_PATTERN_P
+int
+__glob_pattern_type (pattern, quote)
+     const char *pattern;
+     int quote;
+{
+  register const char *p;
+  int ret = 0;
+
+  for (p = pattern; *p != '\0'; ++p)
+    switch (*p)
+      {
+      case '?':
+      case '*':
+	return 1;
+
+      case '\\':
+	if (quote)
+	  {
+	    if (p[1] != '\0')
+	      ++p;
+	    ret |= 2;
+	  }
+	break;
+
+      case '[':
+	ret |= 4;
+	break;
+
+      case ']':
+	if (ret & 4)
+	  return 1;
+	break;
+      }
+
+  return ret;
+}
+
+/* Return nonzero if PATTERN contains any metacharacters.
+   Metacharacters can be quoted with backslashes if QUOTE is nonzero.  */
+int
+__glob_pattern_p (pattern, quote)
+     const char *pattern;
+     int quote;
+{
+  return __glob_pattern_type (pattern, quote) == 1;
+}
+# ifdef _LIBC
+weak_alias (__glob_pattern_p, glob_pattern_p)
+# endif
+#endif
+
+#endif /* !GLOB_ONLY_P */
+
+
+#if !defined _LIBC || !defined GLOB_ONLY_P
+/* We put this in a separate function mainly to allow the memory
+   allocated with alloca to be recycled.  */
+static int
+__attribute_noinline__
+link_exists2_p (const char *dir, size_t dirlen, const char *fname,
+		glob_t *pglob
+# if !defined _LIBC && !HAVE_FSTATAT
+		, int flags
+# endif
+		)
+{
+  size_t fnamelen = strlen (fname);
+  char *fullname = __alloca (dirlen + 1 + fnamelen + 1);
+  struct stat st;
+
+  mempcpy (mempcpy (mempcpy (fullname, dir, dirlen), "/", 1),
+	   fname, fnamelen + 1);
+
+# if !defined _LIBC && !HAVE_FSTATAT
+  if (__builtin_expect ((flags & GLOB_ALTDIRFUNC) == 0, 1))
+    {
+      struct_stat64 st64;
+      return __stat64 (fullname, &st64) == 0;
+    }
+# endif
+  return (*pglob->gl_stat) (fullname, &st) == 0;
+}
+
+/* Return true if DIR/FNAME exists.  */
+static int
+link_exists_p (int dfd, const char *dir, size_t dirlen, const char *fname,
+	       glob_t *pglob, int flags)
+{
+# if defined _LIBC || HAVE_FSTATAT
+  if (__builtin_expect (flags & GLOB_ALTDIRFUNC, 0))
+    return link_exists2_p (dir, dirlen, fname, pglob);
+  else
+    {
+      struct_stat64 st64;
+      return __fxstatat64 (_STAT_VER, dfd, fname, &st64, 0) == 0;
+    }
+# else
+  return link_exists2_p (dir, dirlen, fname, pglob, flags);
+# endif
+}
+#endif
+
+
+/* Like `glob', but PATTERN is a final pathname component,
+   and matches are searched for in DIRECTORY.
+   The GLOB_NOSORT bit in FLAGS is ignored.  No sorting is ever done.
+   The GLOB_APPEND flag is assumed to be set (always appends).  */
+static int
+glob_in_dir (const char *pattern, const char *directory, int flags,
+	     int (*errfunc) (const char *, int),
+	     glob_t *pglob)
+{
+  size_t dirlen = strlen (directory);
+  void *stream = NULL;
+  struct globnames
+    {
+      struct globnames *next;
+      size_t count;
+      char *name[64];
+    };
+#define INITIAL_COUNT sizeof (init_names.name) / sizeof (init_names.name[0])
+  struct globnames init_names;
+  struct globnames *names = &init_names;
+  struct globnames *names_alloca = &init_names;
+  size_t nfound = 0;
+  size_t allocasize = sizeof (init_names);
+  size_t cur = 0;
+  int meta;
+  int save;
+  int result;
+
+  init_names.next = NULL;
+  init_names.count = INITIAL_COUNT;
+
+  meta = __glob_pattern_type (pattern, !(flags & GLOB_NOESCAPE));
+  if (meta == 0 && (flags & (GLOB_NOCHECK|GLOB_NOMAGIC)))
+    {
+      /* We need not do any tests.  The PATTERN contains no meta
+	 characters and we must not return an error therefore the
+	 result will always contain exactly one name.  */
+      flags |= GLOB_NOCHECK;
+    }
+  else if (meta == 0)
+    {
+      /* Since we use the normal file functions we can also use stat()
+	 to verify the file is there.  */
+      struct stat st;
+      struct_stat64 st64;
+      size_t patlen = strlen (pattern);
+      char *fullname = __alloca (dirlen + 1 + patlen + 1);
+
+      mempcpy (mempcpy (mempcpy (fullname, directory, dirlen),
+			"/", 1),
+	       pattern, patlen + 1);
+      if ((__builtin_expect (flags & GLOB_ALTDIRFUNC, 0)
+	   ? (*pglob->gl_stat) (fullname, &st)
+	   : __stat64 (fullname, &st64)) == 0)
+	/* We found this file to be existing.  Now tell the rest
+	   of the function to copy this name into the result.  */
+	flags |= GLOB_NOCHECK;
+    }
+  else
+    {
+      stream = (__builtin_expect (flags & GLOB_ALTDIRFUNC, 0)
+		? (*pglob->gl_opendir) (directory)
+		: opendir (directory));
+      if (stream == NULL)
+	{
+	  if (errno != ENOTDIR
+	      && ((errfunc != NULL && (*errfunc) (directory, errno))
+		  || (flags & GLOB_ERR)))
+	    return GLOB_ABORTED;
+	}
+      else
+	{
+	  int dfd = (__builtin_expect (flags & GLOB_ALTDIRFUNC, 0)
+		     ? -1 : dirfd ((DIR *) stream));
+	  int fnm_flags = ((!(flags & GLOB_PERIOD) ? FNM_PERIOD : 0)
+			   | ((flags & GLOB_NOESCAPE) ? FNM_NOESCAPE : 0)
+#if defined _AMIGA || defined VMS
+			   | FNM_CASEFOLD
+#endif
+			   );
+	  flags |= GLOB_MAGCHAR;
+
+	  while (1)
+	    {
+	      const char *name;
+	      size_t len;
+#if defined _LIBC && !defined COMPILE_GLOB64
+	      struct dirent64 *d;
+	      union
+		{
+		  struct dirent64 d64;
+		  char room [offsetof (struct dirent64, d_name[0])
+			     + NAME_MAX + 1];
+		}
+	      d64buf;
+
+	      if (__builtin_expect (flags & GLOB_ALTDIRFUNC, 0))
+		{
+		  struct dirent *d32 = (*pglob->gl_readdir) (stream);
+		  if (d32 != NULL)
+		    {
+		      CONVERT_DIRENT_DIRENT64 (&d64buf.d64, d32);
+		      d = &d64buf.d64;
+		    }
+		  else
+		    d = NULL;
+		}
+	      else
+		d = __readdir64 (stream);
+#else
+	      struct dirent *d = (__builtin_expect (flags & GLOB_ALTDIRFUNC, 0)
+				  ? ((struct dirent *)
+				     (*pglob->gl_readdir) (stream))
+				  : __readdir (stream));
+#endif
+	      if (d == NULL)
+		break;
+	      if (! REAL_DIR_ENTRY (d))
+		continue;
+
+	      /* If we shall match only directories use the information
+		 provided by the dirent call if possible.  */
+	      if ((flags & GLOB_ONLYDIR) && !DIRENT_MIGHT_BE_DIR (d))
+		continue;
+
+	      name = d->d_name;
+
+	      if (fnmatch (pattern, name, fnm_flags) == 0)
+		{
+		  /* If the file we found is a symlink we have to
+		     make sure the target file exists.  */
+		  if (!DIRENT_MIGHT_BE_SYMLINK (d)
+		      || link_exists_p (dfd, directory, dirlen, name, pglob,
+					flags))
+		    {
+		      if (cur == names->count)
+			{
+			  struct globnames *newnames;
+			  size_t count = names->count * 2;
+			  size_t size = (sizeof (struct globnames)
+					 + ((count - INITIAL_COUNT)
+					    * sizeof (char *)));
+			  allocasize += size;
+			  if (__libc_use_alloca (allocasize))
+			    newnames = names_alloca = __alloca (size);
+			  else if ((newnames = malloc (size))
+				   == NULL)
+			    goto memory_error;
+			  newnames->count = count;
+			  newnames->next = names;
+			  names = newnames;
+			  cur = 0;
+			}
+		      len = _D_EXACT_NAMLEN (d);
+		      names->name[cur] = malloc (len + 1);
+		      if (names->name[cur] == NULL)
+			goto memory_error;
+		      *((char *) mempcpy (names->name[cur++], name, len))
+			= '\0';
+		      ++nfound;
+		    }
+		}
+	    }
+	}
+    }
+
+  if (nfound == 0 && (flags & GLOB_NOCHECK))
+    {
+      size_t len = strlen (pattern);
+      nfound = 1;
+      names->name[cur] = malloc (len + 1);
+      if (names->name[cur] == NULL)
+	goto memory_error;
+      *((char *) mempcpy (names->name[cur++], pattern, len)) = '\0';
+    }
+
+  result = GLOB_NOMATCH;
+  if (nfound != 0)
+    {
+      char **new_gl_pathv
+	= realloc (pglob->gl_pathv,
+		   (pglob->gl_pathc + pglob->gl_offs + nfound + 1)
+		   * sizeof (char *));
+      result = 0;
+
+      if (new_gl_pathv == NULL)
+	{
+	memory_error:
+	  while (1)
+	    {
+	      struct globnames *old = names;
+	      size_t i;
+	      for (i = 0; i < cur; ++i)
+		free (names->name[i]);
+	      names = names->next;
+	      /* NB: we will not leak memory here if we exit without
+		 freeing the current block assigned to OLD.  At least
+		 the very first block is always allocated on the stack
+		 and this is the block assigned to OLD here.  */
+	      if (names == NULL)
+		{
+		  assert (old == &init_names);
+		  break;
+		}
+	      cur = names->count;
+	      if (old == names_alloca)
+		names_alloca = names;
+	      else
+		free (old);
+	    }
+	  result = GLOB_NOSPACE;
+	}
+      else
+	{
+	  while (1)
+	    {
+	      struct globnames *old = names;
+	      size_t i;
+	      for (i = 0; i < cur; ++i)
+		new_gl_pathv[pglob->gl_offs + pglob->gl_pathc++]
+		  = names->name[i];
+	      names = names->next;
+	      /* NB: we will not leak memory here if we exit without
+		 freeing the current block assigned to OLD.  At least
+		 the very first block is always allocated on the stack
+		 and this is the block assigned to OLD here.  */
+	      if (names == NULL)
+		{
+		  assert (old == &init_names);
+		  break;
+		}
+	      cur = names->count;
+	      if (old == names_alloca)
+		names_alloca = names;
+	      else
+		free (old);
+	    }
+
+	  pglob->gl_pathv = new_gl_pathv;
+
+	  pglob->gl_pathv[pglob->gl_offs + pglob->gl_pathc] = NULL;
+
+	  pglob->gl_flags = flags;
+	}
+    }
+
+  if (stream != NULL)
+    {
+      save = errno;
+      if (__builtin_expect (flags & GLOB_ALTDIRFUNC, 0))
+	(*pglob->gl_closedir) (stream);
+      else
+	closedir (stream);
+      __set_errno (save);
+    }
+
+  return result;
+}
diff -urN popt-for-windows/lib/glob.in.h popt-for-windows-gnulib/lib/glob.in.h
--- popt-for-windows/lib/glob.in.h	1970-01-01 01:00:00.000000000 +0100
+++ popt-for-windows-gnulib/lib/glob.in.h	2008-10-25 15:17:05.000000000 +0100
@@ -0,0 +1,60 @@
+/* glob.h -- Find a path matching a pattern.
+
+   Copyright (C) 2005-2007 Free Software Foundation, Inc.
+
+   Written by Derek Price <derek@ximbiot.com> & Paul Eggert <eggert@CS.UCLA.EDU>
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software Foundation,
+   Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
+
+#ifndef _GL_GLOB_H
+#define _GL_GLOB_H
+
+#if @HAVE_SYS_CDEFS_H@
+# include <sys/cdefs.h>
+#endif
+
+#include <stddef.h>
+
+/* On some systems, such as AIX 5.1, <sys/stat.h> does a "#define stat stat64".
+   Make sure this definition is seen before glob-libc.h defines types that
+   rely on 'struct stat'.  */
+#include <sys/stat.h>
+
+#ifndef __BEGIN_DECLS
+# define __BEGIN_DECLS
+# define __END_DECLS
+#endif
+#ifndef __THROW
+# define __THROW
+#endif
+
+#ifndef __size_t
+# define __size_t	size_t
+#endif
+#ifndef __USE_GNU
+# define __USE_GNU    1
+#endif
+
+
+#define glob rpl_glob
+#define globfree rpl_globfree
+#define glob_pattern_p rpl_glob_pattern_p
+
+#define __GLOB_GNULIB 1
+
+/* Now the standard GNU C Library header should work.  */
+#include "glob-libc.h"
+
+#endif /* _GL_GLOB_H */
diff -urN popt-for-windows/lib/glob-libc.h popt-for-windows-gnulib/lib/glob-libc.h
--- popt-for-windows/lib/glob-libc.h	1970-01-01 01:00:00.000000000 +0100
+++ popt-for-windows-gnulib/lib/glob-libc.h	2008-10-25 15:17:05.000000000 +0100
@@ -0,0 +1,211 @@
+/* Copyright (C) 1991,92,95-98,2000,2001,2004-2007 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU General Public
+   License as published by the Free Software Foundation; either
+   version 3 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef	_GLOB_H
+#define	_GLOB_H	1
+
+#ifndef __GLOB_GNULIB
+# include <sys/cdefs.h>
+#endif
+
+/* GCC 2.95 and later have "__restrict"; C99 compilers have
+   "restrict", and "configure" may have defined "restrict".
+   Other compilers use __restrict, __restrict__, and _Restrict, and
+   'configure' might #define 'restrict' to those words, so pick a
+   different name.  */
+#ifndef _Restrict_
+# if 199901L <= __STDC_VERSION__
+#  define _Restrict_ restrict
+# elif 2 < __GNUC__ || (2 == __GNUC__ && 95 <= __GNUC_MINOR__)
+#  define _Restrict_ __restrict
+# else
+#  define _Restrict_
+# endif
+#endif
+
+__BEGIN_DECLS
+
+/* We need `size_t' for the following definitions.  */
+#ifndef __size_t
+# if defined __GNUC__ && __GNUC__ >= 2
+typedef __SIZE_TYPE__ __size_t;
+#  ifdef __USE_XOPEN
+typedef __SIZE_TYPE__ size_t;
+#  endif
+# else
+#  include <stddef.h>
+#  ifndef __size_t
+#   define __size_t size_t
+#  endif
+# endif
+#else
+/* The GNU CC stddef.h version defines __size_t as empty.  We need a real
+   definition.  */
+# undef __size_t
+# define __size_t size_t
+#endif
+
+/* Bits set in the FLAGS argument to `glob'.  */
+#define	GLOB_ERR	(1 << 0)/* Return on read errors.  */
+#define	GLOB_MARK	(1 << 1)/* Append a slash to each name.  */
+#define	GLOB_NOSORT	(1 << 2)/* Don't sort the names.  */
+#define	GLOB_DOOFFS	(1 << 3)/* Insert PGLOB->gl_offs NULLs.  */
+#define	GLOB_NOCHECK	(1 << 4)/* If nothing matches, return the pattern.  */
+#define	GLOB_APPEND	(1 << 5)/* Append to results of a previous call.  */
+#define	GLOB_NOESCAPE	(1 << 6)/* Backslashes don't quote metacharacters.  */
+#define	GLOB_PERIOD	(1 << 7)/* Leading `.' can be matched by metachars.  */
+
+#if !defined __USE_POSIX2 || defined __USE_BSD || defined __USE_GNU
+# define GLOB_MAGCHAR	 (1 << 8)/* Set in gl_flags if any metachars seen.  */
+# define GLOB_ALTDIRFUNC (1 << 9)/* Use gl_opendir et al functions.  */
+# define GLOB_BRACE	 (1 << 10)/* Expand "{a,b}" to "a" "b".  */
+# define GLOB_NOMAGIC	 (1 << 11)/* If no magic chars, return the pattern.  */
+# define GLOB_TILDE	 (1 << 12)/* Expand ~user and ~ to home directories. */
+# define GLOB_ONLYDIR	 (1 << 13)/* Match only directories.  */
+# define GLOB_TILDE_CHECK (1 << 14)/* Like GLOB_TILDE but return an error
+				      if the user name is not available.  */
+# define __GLOB_FLAGS	(GLOB_ERR|GLOB_MARK|GLOB_NOSORT|GLOB_DOOFFS| \
+			 GLOB_NOESCAPE|GLOB_NOCHECK|GLOB_APPEND|     \
+			 GLOB_PERIOD|GLOB_ALTDIRFUNC|GLOB_BRACE|     \
+			 GLOB_NOMAGIC|GLOB_TILDE|GLOB_ONLYDIR|GLOB_TILDE_CHECK)
+#else
+# define __GLOB_FLAGS	(GLOB_ERR|GLOB_MARK|GLOB_NOSORT|GLOB_DOOFFS| \
+			 GLOB_NOESCAPE|GLOB_NOCHECK|GLOB_APPEND|     \
+			 GLOB_PERIOD)
+#endif
+
+/* Error returns from `glob'.  */
+#define	GLOB_NOSPACE	1	/* Ran out of memory.  */
+#define	GLOB_ABORTED	2	/* Read error.  */
+#define	GLOB_NOMATCH	3	/* No matches found.  */
+#define GLOB_NOSYS	4	/* Not implemented.  */
+#ifdef __USE_GNU
+/* Previous versions of this file defined GLOB_ABEND instead of
+   GLOB_ABORTED.  Provide a compatibility definition here.  */
+# define GLOB_ABEND GLOB_ABORTED
+#endif
+
+/* Structure describing a globbing run.  */
+#ifdef __USE_GNU
+struct stat;
+#endif
+typedef struct
+  {
+    __size_t gl_pathc;		/* Count of paths matched by the pattern.  */
+    char **gl_pathv;		/* List of matched pathnames.  */
+    __size_t gl_offs;		/* Slots to reserve in `gl_pathv'.  */
+    int gl_flags;		/* Set to FLAGS, maybe | GLOB_MAGCHAR.  */
+
+    /* If the GLOB_ALTDIRFUNC flag is set, the following functions
+       are used instead of the normal file access functions.  */
+    void (*gl_closedir) (void *);
+#ifdef __USE_GNU
+    struct dirent *(*gl_readdir) (void *);
+#else
+    void *(*gl_readdir) (void *);
+#endif
+    void *(*gl_opendir) (const char *);
+#ifdef __USE_GNU
+    int (*gl_lstat) (const char *_Restrict_, struct stat *_Restrict_);
+    int (*gl_stat) (const char *_Restrict_, struct stat *_Restrict_);
+#else
+    int (*gl_lstat) (const char *_Restrict_, void *_Restrict_);
+    int (*gl_stat) (const char *_Restrict_, void *_Restrict_);
+#endif
+  } glob_t;
+
+#if defined __USE_LARGEFILE64 && !defined __GLOB_GNULIB
+# ifdef __USE_GNU
+struct stat64;
+# endif
+typedef struct
+  {
+    __size_t gl_pathc;
+    char **gl_pathv;
+    __size_t gl_offs;
+    int gl_flags;
+
+    /* If the GLOB_ALTDIRFUNC flag is set, the following functions
+       are used instead of the normal file access functions.  */
+    void (*gl_closedir) (void *);
+# ifdef __USE_GNU
+    struct dirent64 *(*gl_readdir) (void *);
+# else
+    void *(*gl_readdir) (void *);
+# endif
+    void *(*gl_opendir) (const char *);
+# ifdef __USE_GNU
+    int (*gl_lstat) (const char *_Restrict_, struct stat64 *_Restrict_);
+    int (*gl_stat) (const char *_Restrict_, struct stat64 *_Restrict_);
+# else
+    int (*gl_lstat) (const char *_Restrict_, void *_Restrict_);
+    int (*gl_stat) (const char *_Restrict_, void *_Restrict_);
+# endif
+  } glob64_t;
+#endif
+
+#if __USE_FILE_OFFSET64 && __GNUC__ < 2 && !defined __GLOB_GNULIB
+# define glob glob64
+# define globfree globfree64
+#endif
+
+/* Do glob searching for PATTERN, placing results in PGLOB.
+   The bits defined above may be set in FLAGS.
+   If a directory cannot be opened or read and ERRFUNC is not nil,
+   it is called with the pathname that caused the error, and the
+   `errno' value from the failing call; if it returns non-zero
+   `glob' returns GLOB_ABEND; if it returns zero, the error is ignored.
+   If memory cannot be allocated for PGLOB, GLOB_NOSPACE is returned.
+   Otherwise, `glob' returns zero.  */
+#if !defined __USE_FILE_OFFSET64 || __GNUC__ < 2 || defined __GLOB_GNULIB
+extern int glob (const char *_Restrict_ __pattern, int __flags,
+		 int (*__errfunc) (const char *, int),
+		 glob_t *_Restrict_ __pglob) __THROW;
+
+/* Free storage allocated in PGLOB by a previous `glob' call.  */
+extern void globfree (glob_t *__pglob) __THROW;
+#else
+extern int __REDIRECT_NTH (glob, (const char *_Restrict_ __pattern,
+				  int __flags,
+				  int (*__errfunc) (const char *, int),
+				  glob_t *_Restrict_ __pglob), glob64);
+
+extern void __REDIRECT_NTH (globfree, (glob_t *__pglob), globfree64);
+#endif
+
+#if defined __USE_LARGEFILE64 && !defined __GLOB_GNULIB
+extern int glob64 (const char *_Restrict_ __pattern, int __flags,
+		   int (*__errfunc) (const char *, int),
+		   glob64_t *_Restrict_ __pglob) __THROW;
+
+extern void globfree64 (glob64_t *__pglob) __THROW;
+#endif
+
+
+#ifdef __USE_GNU
+/* Return nonzero if PATTERN contains any metacharacters.
+   Metacharacters can be quoted with backslashes if QUOTE is nonzero.
+
+   This function is not part of the interface specified by POSIX.2
+   but several programs want to use it.  */
+extern int glob_pattern_p (const char *__pattern, int __quote) __THROW;
+#endif
+
+__END_DECLS
+
+#endif /* glob.h  */
diff -urN popt-for-windows/lib/Makefile.am popt-for-windows-gnulib/lib/Makefile.am
--- popt-for-windows/lib/Makefile.am	1970-01-01 01:00:00.000000000 +0100
+++ popt-for-windows-gnulib/lib/Makefile.am	2008-10-25 15:17:05.000000000 +0100
@@ -0,0 +1,502 @@
+## DO NOT EDIT! GENERATED AUTOMATICALLY!
+## Process this file with automake to produce Makefile.in.
+# Copyright (C) 2002-2008 Free Software Foundation, Inc.
+#
+# This file is free software, distributed under the terms of the GNU
+# General Public License.  As a special exception to the GNU General
+# Public License, this file may be distributed as part of a program
+# that contains a configuration script generated by Autoconf, under
+# the same distribution terms as the rest of that program.
+#
+# Generated by gnulib-tool.
+# Reproduce by: gnulib-tool --import --dir=. --lib=libgnu --source-base=lib --m4-base=m4 --doc-base=doc --tests-base=tests --aux-dir=. --libtool --macro-prefix=gl glob
+
+AUTOMAKE_OPTIONS = 1.5 gnits
+
+SUBDIRS =
+noinst_HEADERS =
+noinst_LIBRARIES =
+noinst_LTLIBRARIES =
+EXTRA_DIST =
+BUILT_SOURCES =
+SUFFIXES =
+MOSTLYCLEANFILES = core *.stackdump
+MOSTLYCLEANDIRS =
+CLEANFILES =
+DISTCLEANFILES =
+MAINTAINERCLEANFILES =
+
+AM_CPPFLAGS =
+
+noinst_LTLIBRARIES += libgnu.la
+
+libgnu_la_SOURCES =
+libgnu_la_LIBADD = $(gl_LTLIBOBJS)
+libgnu_la_DEPENDENCIES = $(gl_LTLIBOBJS)
+EXTRA_libgnu_la_SOURCES =
+libgnu_la_LDFLAGS = $(AM_LDFLAGS)
+
+## begin gnulib module alloca
+
+
+EXTRA_DIST += alloca.c
+
+EXTRA_libgnu_la_SOURCES += alloca.c
+
+libgnu_la_LIBADD += @LTALLOCA@
+libgnu_la_DEPENDENCIES += @LTALLOCA@
+## end   gnulib module alloca
+
+## begin gnulib module alloca-opt
+
+BUILT_SOURCES += $(ALLOCA_H)
+
+# We need the following in order to create <alloca.h> when the system
+# doesn't have one that works with the given compiler.
+alloca.h: alloca.in.h
+	{ echo '/* DO NOT EDIT! GENERATED AUTOMATICALLY! */'; \
+	  cat $(srcdir)/alloca.in.h; \
+	} > $@-t
+	mv -f $@-t $@
+MOSTLYCLEANFILES += alloca.h alloca.h-t
+
+EXTRA_DIST += alloca.in.h
+
+## end   gnulib module alloca-opt
+
+## begin gnulib module dirent
+
+BUILT_SOURCES += $(DIRENT_H)
+
+# We need the following in order to create <dirent.h> when the system
+# doesn't have one that works with the given compiler.
+dirent.h: dirent.in.h
+	rm -f $@-t $@
+	{ echo '/* DO NOT EDIT! GENERATED AUTOMATICALLY! */'; \
+	  sed -e 's|@''INCLUDE_NEXT''@|$(INCLUDE_NEXT)|g' \
+	      -e 's|@''PRAGMA_SYSTEM_HEADER''@|@PRAGMA_SYSTEM_HEADER@|g' \
+	      -e 's|@''NEXT_DIRENT_H''@|$(NEXT_DIRENT_H)|g' \
+	      -e 's|@''GNULIB_DIRFD''@|$(GNULIB_DIRFD)|g' \
+	      -e 's|@''HAVE_DECL_DIRFD''@|$(HAVE_DECL_DIRFD)|g' \
+	      -e 's|@''REPLACE_FCHDIR''@|$(REPLACE_FCHDIR)|g' \
+	      -e '/definition of GL_LINK_WARNING/r $(LINK_WARNING_H)' \
+	      < $(srcdir)/dirent.in.h; \
+	} > $@-t
+	mv $@-t $@
+MOSTLYCLEANFILES += dirent.h dirent.h-t
+
+EXTRA_DIST += dirent.in.h
+
+## end   gnulib module dirent
+
+## begin gnulib module dirfd
+
+
+EXTRA_DIST += dirfd.c
+
+EXTRA_libgnu_la_SOURCES += dirfd.c
+
+## end   gnulib module dirfd
+
+## begin gnulib module fnmatch
+
+BUILT_SOURCES += $(FNMATCH_H)
+
+# We need the following in order to create <fnmatch.h> when the system
+# doesn't have one that supports the required API.
+fnmatch.h: fnmatch.in.h
+	{ echo '/* DO NOT EDIT! GENERATED AUTOMATICALLY! */'; \
+	  cat $(srcdir)/fnmatch.in.h; \
+	} > $@-t
+	mv -f $@-t $@
+MOSTLYCLEANFILES += fnmatch.h fnmatch.h-t
+
+EXTRA_DIST += fnmatch.c fnmatch.in.h fnmatch_loop.c
+
+EXTRA_libgnu_la_SOURCES += fnmatch.c fnmatch_loop.c
+
+## end   gnulib module fnmatch
+
+## begin gnulib module getlogin_r
+
+
+EXTRA_DIST += getlogin_r.c
+
+EXTRA_libgnu_la_SOURCES += getlogin_r.c
+
+## end   gnulib module getlogin_r
+
+## begin gnulib module glob
+
+BUILT_SOURCES += $(GLOB_H)
+
+# We need the following in order to create <glob.h> when the system
+# doesn't have one that works with the given compiler.
+glob.h: glob.in.h
+	{ echo '/* DO NOT EDIT! GENERATED AUTOMATICALLY! */'; \
+	  sed -e 's|@''HAVE_SYS_CDEFS_H''@|$(HAVE_SYS_CDEFS_H)|g' \
+	      < $(srcdir)/glob.in.h; \
+	} > $@-t
+	mv -f $@-t $@
+MOSTLYCLEANFILES += glob.h glob.h-t
+
+EXTRA_DIST += glob-libc.h glob.c glob.in.h
+
+EXTRA_libgnu_la_SOURCES += glob.c
+
+## end   gnulib module glob
+
+## begin gnulib module link-warning
+
+LINK_WARNING_H=$(top_srcdir)/./link-warning.h
+
+EXTRA_DIST += $(top_srcdir)/./link-warning.h
+
+## end   gnulib module link-warning
+
+## begin gnulib module malloc-posix
+
+
+EXTRA_DIST += malloc.c
+
+EXTRA_libgnu_la_SOURCES += malloc.c
+
+## end   gnulib module malloc-posix
+
+## begin gnulib module mempcpy
+
+
+EXTRA_DIST += mempcpy.c
+
+EXTRA_libgnu_la_SOURCES += mempcpy.c
+
+## end   gnulib module mempcpy
+
+## begin gnulib module stdbool
+
+BUILT_SOURCES += $(STDBOOL_H)
+
+# We need the following in order to create <stdbool.h> when the system
+# doesn't have one that works.
+stdbool.h: stdbool.in.h
+	rm -f $@-t $@
+	{ echo '/* DO NOT EDIT! GENERATED AUTOMATICALLY! */'; \
+	  sed -e 's/@''HAVE__BOOL''@/$(HAVE__BOOL)/g' < $(srcdir)/stdbool.in.h; \
+	} > $@-t
+	mv $@-t $@
+MOSTLYCLEANFILES += stdbool.h stdbool.h-t
+
+EXTRA_DIST += stdbool.in.h
+
+## end   gnulib module stdbool
+
+## begin gnulib module stdlib
+
+BUILT_SOURCES += stdlib.h
+
+# We need the following in order to create <stdlib.h> when the system
+# doesn't have one that works with the given compiler.
+stdlib.h: stdlib.in.h
+	rm -f $@-t $@
+	{ echo '/* DO NOT EDIT! GENERATED AUTOMATICALLY! */' && \
+	  sed -e 's|@''INCLUDE_NEXT''@|$(INCLUDE_NEXT)|g' \
+	      -e 's|@''PRAGMA_SYSTEM_HEADER''@|@PRAGMA_SYSTEM_HEADER@|g' \
+	      -e 's|@''NEXT_STDLIB_H''@|$(NEXT_STDLIB_H)|g' \
+	      -e 's|@''GNULIB_MALLOC_POSIX''@|$(GNULIB_MALLOC_POSIX)|g' \
+	      -e 's|@''GNULIB_REALLOC_POSIX''@|$(GNULIB_REALLOC_POSIX)|g' \
+	      -e 's|@''GNULIB_CALLOC_POSIX''@|$(GNULIB_CALLOC_POSIX)|g' \
+	      -e 's|@''GNULIB_ATOLL''@|$(GNULIB_ATOLL)|g' \
+	      -e 's|@''GNULIB_GETLOADAVG''@|$(GNULIB_GETLOADAVG)|g' \
+	      -e 's|@''GNULIB_GETSUBOPT''@|$(GNULIB_GETSUBOPT)|g' \
+	      -e 's|@''GNULIB_MKDTEMP''@|$(GNULIB_MKDTEMP)|g' \
+	      -e 's|@''GNULIB_MKSTEMP''@|$(GNULIB_MKSTEMP)|g' \
+	      -e 's|@''GNULIB_PUTENV''@|$(GNULIB_PUTENV)|g' \
+	      -e 's|@''GNULIB_RAND48''@|$(GNULIB_RAND48)|g' \
+	      -e 's|@''GNULIB_RANDOM_R''@|$(GNULIB_RANDOM_R)|g' \
+	      -e 's|@''GNULIB_RPMATCH''@|$(GNULIB_RPMATCH)|g' \
+	      -e 's|@''GNULIB_SETENV''@|$(GNULIB_SETENV)|g' \
+	      -e 's|@''GNULIB_STRTOD''@|$(GNULIB_STRTOD)|g' \
+	      -e 's|@''GNULIB_STRTOLL''@|$(GNULIB_STRTOLL)|g' \
+	      -e 's|@''GNULIB_STRTOULL''@|$(GNULIB_STRTOULL)|g' \
+	      -e 's|@''GNULIB_UNSETENV''@|$(GNULIB_UNSETENV)|g' \
+	      -e 's|@''HAVE_ATOLL''@|$(HAVE_ATOLL)|g' \
+	      -e 's|@''HAVE_CALLOC_POSIX''@|$(HAVE_CALLOC_POSIX)|g' \
+	      -e 's|@''HAVE_GETSUBOPT''@|$(HAVE_GETSUBOPT)|g' \
+	      -e 's|@''HAVE_MALLOC_POSIX''@|$(HAVE_MALLOC_POSIX)|g' \
+	      -e 's|@''HAVE_MKDTEMP''@|$(HAVE_MKDTEMP)|g' \
+	      -e 's|@''HAVE_REALLOC_POSIX''@|$(HAVE_REALLOC_POSIX)|g' \
+	      -e 's|@''HAVE_RAND48''@|$(HAVE_RAND48)|g' \
+	      -e 's|@''HAVE_RANDOM_R''@|$(HAVE_RANDOM_R)|g' \
+	      -e 's|@''HAVE_RPMATCH''@|$(HAVE_RPMATCH)|g' \
+	      -e 's|@''HAVE_SETENV''@|$(HAVE_SETENV)|g' \
+	      -e 's|@''HAVE_STRTOD''@|$(HAVE_STRTOD)|g' \
+	      -e 's|@''HAVE_STRTOLL''@|$(HAVE_STRTOLL)|g' \
+	      -e 's|@''HAVE_STRTOULL''@|$(HAVE_STRTOULL)|g' \
+	      -e 's|@''HAVE_SYS_LOADAVG_H''@|$(HAVE_SYS_LOADAVG_H)|g' \
+	      -e 's|@''HAVE_UNSETENV''@|$(HAVE_UNSETENV)|g' \
+	      -e 's|@''HAVE_DECL_GETLOADAVG''@|$(HAVE_DECL_GETLOADAVG)|g' \
+	      -e 's|@''REPLACE_MKSTEMP''@|$(REPLACE_MKSTEMP)|g' \
+	      -e 's|@''REPLACE_PUTENV''@|$(REPLACE_PUTENV)|g' \
+	      -e 's|@''REPLACE_STRTOD''@|$(REPLACE_STRTOD)|g' \
+	      -e 's|@''VOID_UNSETENV''@|$(VOID_UNSETENV)|g' \
+	      -e '/definition of GL_LINK_WARNING/r $(LINK_WARNING_H)' \
+	      < $(srcdir)/stdlib.in.h; \
+	} > $@-t
+	mv $@-t $@
+MOSTLYCLEANFILES += stdlib.h stdlib.h-t
+
+EXTRA_DIST += stdlib.in.h
+
+## end   gnulib module stdlib
+
+## begin gnulib module strdup
+
+
+EXTRA_DIST += strdup.c
+
+EXTRA_libgnu_la_SOURCES += strdup.c
+
+## end   gnulib module strdup
+
+## begin gnulib module string
+
+BUILT_SOURCES += string.h
+
+# We need the following in order to create <string.h> when the system
+# doesn't have one that works with the given compiler.
+string.h: string.in.h
+	rm -f $@-t $@
+	{ echo '/* DO NOT EDIT! GENERATED AUTOMATICALLY! */' && \
+	  sed -e 's|@''INCLUDE_NEXT''@|$(INCLUDE_NEXT)|g' \
+	      -e 's|@''PRAGMA_SYSTEM_HEADER''@|@PRAGMA_SYSTEM_HEADER@|g' \
+	      -e 's|@''NEXT_STRING_H''@|$(NEXT_STRING_H)|g' \
+	      -e 's|@''GNULIB_MBSLEN''@|$(GNULIB_MBSLEN)|g' \
+	      -e 's|@''GNULIB_MBSNLEN''@|$(GNULIB_MBSNLEN)|g' \
+	      -e 's|@''GNULIB_MBSCHR''@|$(GNULIB_MBSCHR)|g' \
+	      -e 's|@''GNULIB_MBSRCHR''@|$(GNULIB_MBSRCHR)|g' \
+	      -e 's|@''GNULIB_MBSSTR''@|$(GNULIB_MBSSTR)|g' \
+	      -e 's|@''GNULIB_MBSCASECMP''@|$(GNULIB_MBSCASECMP)|g' \
+	      -e 's|@''GNULIB_MBSNCASECMP''@|$(GNULIB_MBSNCASECMP)|g' \
+	      -e 's|@''GNULIB_MBSPCASECMP''@|$(GNULIB_MBSPCASECMP)|g' \
+	      -e 's|@''GNULIB_MBSCASESTR''@|$(GNULIB_MBSCASESTR)|g' \
+	      -e 's|@''GNULIB_MBSCSPN''@|$(GNULIB_MBSCSPN)|g' \
+	      -e 's|@''GNULIB_MBSPBRK''@|$(GNULIB_MBSPBRK)|g' \
+	      -e 's|@''GNULIB_MBSSPN''@|$(GNULIB_MBSSPN)|g' \
+	      -e 's|@''GNULIB_MBSSEP''@|$(GNULIB_MBSSEP)|g' \
+	      -e 's|@''GNULIB_MBSTOK_R''@|$(GNULIB_MBSTOK_R)|g' \
+	      -e 's|@''GNULIB_MEMMEM''@|$(GNULIB_MEMMEM)|g' \
+	      -e 's|@''GNULIB_MEMPCPY''@|$(GNULIB_MEMPCPY)|g' \
+	      -e 's|@''GNULIB_MEMRCHR''@|$(GNULIB_MEMRCHR)|g' \
+	      -e 's|@''GNULIB_RAWMEMCHR''@|$(GNULIB_RAWMEMCHR)|g' \
+	      -e 's|@''GNULIB_STPCPY''@|$(GNULIB_STPCPY)|g' \
+	      -e 's|@''GNULIB_STPNCPY''@|$(GNULIB_STPNCPY)|g' \
+	      -e 's|@''GNULIB_STRCHRNUL''@|$(GNULIB_STRCHRNUL)|g' \
+	      -e 's|@''GNULIB_STRDUP''@|$(GNULIB_STRDUP)|g' \
+	      -e 's|@''GNULIB_STRNDUP''@|$(GNULIB_STRNDUP)|g' \
+	      -e 's|@''GNULIB_STRNLEN''@|$(GNULIB_STRNLEN)|g' \
+	      -e 's|@''GNULIB_STRPBRK''@|$(GNULIB_STRPBRK)|g' \
+	      -e 's|@''GNULIB_STRSEP''@|$(GNULIB_STRSEP)|g' \
+	      -e 's|@''GNULIB_STRSTR''@|$(GNULIB_STRSTR)|g' \
+	      -e 's|@''GNULIB_STRCASESTR''@|$(GNULIB_STRCASESTR)|g' \
+	      -e 's|@''GNULIB_STRTOK_R''@|$(GNULIB_STRTOK_R)|g' \
+	      -e 's|@''GNULIB_STRERROR''@|$(GNULIB_STRERROR)|g' \
+	      -e 's|@''GNULIB_STRSIGNAL''@|$(GNULIB_STRSIGNAL)|g' \
+	      -e 's|@''GNULIB_STRVERSCMP''@|$(GNULIB_STRVERSCMP)|g' \
+	      -e 's|@''HAVE_DECL_MEMMEM''@|$(HAVE_DECL_MEMMEM)|g' \
+	      -e 's|@''HAVE_MEMPCPY''@|$(HAVE_MEMPCPY)|g' \
+	      -e 's|@''HAVE_DECL_MEMRCHR''@|$(HAVE_DECL_MEMRCHR)|g' \
+	      -e 's|@''HAVE_RAWMEMCHR''@|$(HAVE_RAWMEMCHR)|g' \
+	      -e 's|@''HAVE_STPCPY''@|$(HAVE_STPCPY)|g' \
+	      -e 's|@''HAVE_STPNCPY''@|$(HAVE_STPNCPY)|g' \
+	      -e 's|@''HAVE_STRCHRNUL''@|$(HAVE_STRCHRNUL)|g' \
+	      -e 's|@''HAVE_DECL_STRDUP''@|$(HAVE_DECL_STRDUP)|g' \
+	      -e 's|@''HAVE_STRNDUP''@|$(HAVE_STRNDUP)|g' \
+	      -e 's|@''HAVE_DECL_STRNDUP''@|$(HAVE_DECL_STRNDUP)|g' \
+	      -e 's|@''HAVE_DECL_STRNLEN''@|$(HAVE_DECL_STRNLEN)|g' \
+	      -e 's|@''HAVE_STRPBRK''@|$(HAVE_STRPBRK)|g' \
+	      -e 's|@''HAVE_STRSEP''@|$(HAVE_STRSEP)|g' \
+	      -e 's|@''HAVE_STRCASESTR''@|$(HAVE_STRCASESTR)|g' \
+	      -e 's|@''HAVE_DECL_STRTOK_R''@|$(HAVE_DECL_STRTOK_R)|g' \
+	      -e 's|@''HAVE_DECL_STRERROR''@|$(HAVE_DECL_STRERROR)|g' \
+	      -e 's|@''HAVE_DECL_STRSIGNAL''@|$(HAVE_DECL_STRSIGNAL)|g' \
+	      -e 's|@''HAVE_STRVERSCMP''@|$(HAVE_STRVERSCMP)|g' \
+	      -e 's|@''REPLACE_MEMMEM''@|$(REPLACE_MEMMEM)|g' \
+	      -e 's|@''REPLACE_STRCASESTR''@|$(REPLACE_STRCASESTR)|g' \
+	      -e 's|@''REPLACE_STRDUP''@|$(REPLACE_STRDUP)|g' \
+	      -e 's|@''REPLACE_STRSTR''@|$(REPLACE_STRSTR)|g' \
+	      -e 's|@''REPLACE_STRERROR''@|$(REPLACE_STRERROR)|g' \
+	      -e 's|@''REPLACE_STRSIGNAL''@|$(REPLACE_STRSIGNAL)|g' \
+	      -e '/definition of GL_LINK_WARNING/r $(LINK_WARNING_H)' \
+	      < $(srcdir)/string.in.h; \
+	} > $@-t
+	mv $@-t $@
+MOSTLYCLEANFILES += string.h string.h-t
+
+EXTRA_DIST += string.in.h
+
+## end   gnulib module string
+
+## begin gnulib module sys_stat
+
+BUILT_SOURCES += $(SYS_STAT_H)
+
+# We need the following in order to create <sys/stat.h> when the system
+# has one that is incomplete.
+sys/stat.h: sys_stat.in.h
+	@MKDIR_P@ sys
+	rm -f $@-t $@
+	{ echo '/* DO NOT EDIT! GENERATED AUTOMATICALLY! */'; \
+	  sed -e 's|@''INCLUDE_NEXT''@|$(INCLUDE_NEXT)|g' \
+	      -e 's|@''PRAGMA_SYSTEM_HEADER''@|@PRAGMA_SYSTEM_HEADER@|g' \
+	      -e 's|@''NEXT_SYS_STAT_H''@|$(NEXT_SYS_STAT_H)|g' \
+	      -e 's|@''GNULIB_LCHMOD''@|$(GNULIB_LCHMOD)|g' \
+	      -e 's|@''GNULIB_LSTAT''@|$(GNULIB_LSTAT)|g' \
+	      -e 's|@''HAVE_LCHMOD''@|$(HAVE_LCHMOD)|g' \
+	      -e 's|@''HAVE_LSTAT''@|$(HAVE_LSTAT)|g' \
+	      -e 's|@''REPLACE_LSTAT''@|$(REPLACE_LSTAT)|g' \
+	      -e 's|@''REPLACE_MKDIR''@|$(REPLACE_MKDIR)|g' \
+	      -e '/definition of GL_LINK_WARNING/r $(LINK_WARNING_H)' \
+	      < $(srcdir)/sys_stat.in.h; \
+	} > $@-t
+	mv $@-t $@
+MOSTLYCLEANFILES += sys/stat.h sys/stat.h-t
+MOSTLYCLEANDIRS += sys
+
+EXTRA_DIST += sys_stat.in.h
+
+## end   gnulib module sys_stat
+
+## begin gnulib module unistd
+
+BUILT_SOURCES += unistd.h
+
+# We need the following in order to create an empty placeholder for
+# <unistd.h> when the system doesn't have one.
+unistd.h: unistd.in.h
+	rm -f $@-t $@
+	{ echo '/* DO NOT EDIT! GENERATED AUTOMATICALLY! */'; \
+	  sed -e 's|@''HAVE_UNISTD_H''@|$(HAVE_UNISTD_H)|g' \
+	      -e 's|@''INCLUDE_NEXT''@|$(INCLUDE_NEXT)|g' \
+	      -e 's|@''PRAGMA_SYSTEM_HEADER''@|@PRAGMA_SYSTEM_HEADER@|g' \
+	      -e 's|@''NEXT_UNISTD_H''@|$(NEXT_UNISTD_H)|g' \
+	      -e 's|@''GNULIB_CHOWN''@|$(GNULIB_CHOWN)|g' \
+	      -e 's|@''GNULIB_CLOSE''@|$(GNULIB_CLOSE)|g' \
+	      -e 's|@''GNULIB_DUP2''@|$(GNULIB_DUP2)|g' \
+	      -e 's|@''GNULIB_ENVIRON''@|$(GNULIB_ENVIRON)|g' \
+	      -e 's|@''GNULIB_EUIDACCESS''@|$(GNULIB_EUIDACCESS)|g' \
+	      -e 's|@''GNULIB_FCHDIR''@|$(GNULIB_FCHDIR)|g' \
+	      -e 's|@''GNULIB_FSYNC''@|$(GNULIB_FSYNC)|g' \
+	      -e 's|@''GNULIB_FTRUNCATE''@|$(GNULIB_FTRUNCATE)|g' \
+	      -e 's|@''GNULIB_GETCWD''@|$(GNULIB_GETCWD)|g' \
+	      -e 's|@''GNULIB_GETDOMAINNAME''@|$(GNULIB_GETDOMAINNAME)|g' \
+	      -e 's|@''GNULIB_GETDTABLESIZE''@|$(GNULIB_GETDTABLESIZE)|g' \
+	      -e 's|@''GNULIB_GETHOSTNAME''@|$(GNULIB_GETHOSTNAME)|g' \
+	      -e 's|@''GNULIB_GETLOGIN_R''@|$(GNULIB_GETLOGIN_R)|g' \
+	      -e 's|@''GNULIB_GETPAGESIZE''@|$(GNULIB_GETPAGESIZE)|g' \
+	      -e 's|@''GNULIB_GETUSERSHELL''@|$(GNULIB_GETUSERSHELL)|g' \
+	      -e 's|@''GNULIB_LCHOWN''@|$(GNULIB_LCHOWN)|g' \
+	      -e 's|@''GNULIB_LSEEK''@|$(GNULIB_LSEEK)|g' \
+	      -e 's|@''GNULIB_READLINK''@|$(GNULIB_READLINK)|g' \
+	      -e 's|@''GNULIB_SLEEP''@|$(GNULIB_SLEEP)|g' \
+	      -e 's|@''GNULIB_UNISTD_H_SIGPIPE''@|$(GNULIB_UNISTD_H_SIGPIPE)|g' \
+	      -e 's|@''GNULIB_WRITE''@|$(GNULIB_WRITE)|g' \
+	      -e 's|@''HAVE_DUP2''@|$(HAVE_DUP2)|g' \
+	      -e 's|@''HAVE_EUIDACCESS''@|$(HAVE_EUIDACCESS)|g' \
+	      -e 's|@''HAVE_FSYNC''@|$(HAVE_FSYNC)|g' \
+	      -e 's|@''HAVE_FTRUNCATE''@|$(HAVE_FTRUNCATE)|g' \
+	      -e 's|@''HAVE_GETDOMAINNAME''@|$(HAVE_GETDOMAINNAME)|g' \
+	      -e 's|@''HAVE_GETDTABLESIZE''@|$(HAVE_GETDTABLESIZE)|g' \
+	      -e 's|@''HAVE_GETHOSTNAME''@|$(HAVE_GETHOSTNAME)|g' \
+	      -e 's|@''HAVE_GETPAGESIZE''@|$(HAVE_GETPAGESIZE)|g' \
+	      -e 's|@''HAVE_GETUSERSHELL''@|$(HAVE_GETUSERSHELL)|g' \
+	      -e 's|@''HAVE_READLINK''@|$(HAVE_READLINK)|g' \
+	      -e 's|@''HAVE_SLEEP''@|$(HAVE_SLEEP)|g' \
+	      -e 's|@''HAVE_DECL_ENVIRON''@|$(HAVE_DECL_ENVIRON)|g' \
+	      -e 's|@''HAVE_DECL_GETLOGIN_R''@|$(HAVE_DECL_GETLOGIN_R)|g' \
+	      -e 's|@''HAVE_OS_H''@|$(HAVE_OS_H)|g' \
+	      -e 's|@''HAVE_SYS_PARAM_H''@|$(HAVE_SYS_PARAM_H)|g' \
+	      -e 's|@''REPLACE_CHOWN''@|$(REPLACE_CHOWN)|g' \
+	      -e 's|@''REPLACE_CLOSE''@|$(REPLACE_CLOSE)|g' \
+	      -e 's|@''REPLACE_FCHDIR''@|$(REPLACE_FCHDIR)|g' \
+	      -e 's|@''REPLACE_GETCWD''@|$(REPLACE_GETCWD)|g' \
+	      -e 's|@''REPLACE_GETPAGESIZE''@|$(REPLACE_GETPAGESIZE)|g' \
+	      -e 's|@''REPLACE_LCHOWN''@|$(REPLACE_LCHOWN)|g' \
+	      -e 's|@''REPLACE_LSEEK''@|$(REPLACE_LSEEK)|g' \
+	      -e 's|@''REPLACE_WRITE''@|$(REPLACE_WRITE)|g' \
+	      -e 's|@''UNISTD_H_HAVE_WINSOCK2_H''@|$(UNISTD_H_HAVE_WINSOCK2_H)|g' \
+	      -e '/definition of GL_LINK_WARNING/r $(LINK_WARNING_H)' \
+	      < $(srcdir)/unistd.in.h; \
+	} > $@-t
+	mv $@-t $@
+MOSTLYCLEANFILES += unistd.h unistd.h-t
+
+EXTRA_DIST += unistd.in.h
+
+## end   gnulib module unistd
+
+## begin gnulib module wchar
+
+BUILT_SOURCES += $(WCHAR_H)
+
+# We need the following in order to create <wchar.h> when the system
+# version does not work standalone.
+wchar.h: wchar.in.h
+	rm -f $@-t $@
+	{ echo '/* DO NOT EDIT! GENERATED AUTOMATICALLY! */'; \
+	  sed -e 's|@''INCLUDE_NEXT''@|$(INCLUDE_NEXT)|g' \
+	      -e 's|@''PRAGMA_SYSTEM_HEADER''@|@PRAGMA_SYSTEM_HEADER@|g' \
+	      -e 's|@''NEXT_WCHAR_H''@|$(NEXT_WCHAR_H)|g' \
+	      -e 's/@''HAVE_WCHAR_H''@/$(HAVE_WCHAR_H)/g' \
+	      -e 's|@''GNULIB_WCWIDTH''@|$(GNULIB_WCWIDTH)|g' \
+	      -e 's/@''HAVE_WINT_T''@/$(HAVE_WINT_T)/g' \
+	      -e 's|@''HAVE_DECL_WCWIDTH''@|$(HAVE_DECL_WCWIDTH)|g' \
+	      -e 's|@''REPLACE_WCWIDTH''@|$(REPLACE_WCWIDTH)|g' \
+	      -e '/definition of GL_LINK_WARNING/r $(LINK_WARNING_H)' \
+	    < $(srcdir)/wchar.in.h; \
+	} > $@-t
+	mv $@-t $@
+MOSTLYCLEANFILES += wchar.h wchar.h-t
+
+EXTRA_DIST += wchar.in.h
+
+## end   gnulib module wchar
+
+## begin gnulib module wctype
+
+BUILT_SOURCES += $(WCTYPE_H)
+
+# We need the following in order to create <wctype.h> when the system
+# doesn't have one that works with the given compiler.
+wctype.h: wctype.in.h
+	rm -f $@-t $@
+	{ echo '/* DO NOT EDIT! GENERATED AUTOMATICALLY! */'; \
+	  sed -e 's/@''HAVE_WCTYPE_H''@/$(HAVE_WCTYPE_H)/g' \
+	      -e 's|@''INCLUDE_NEXT''@|$(INCLUDE_NEXT)|g' \
+	      -e 's|@''PRAGMA_SYSTEM_HEADER''@|@PRAGMA_SYSTEM_HEADER@|g' \
+	      -e 's|@''NEXT_WCTYPE_H''@|$(NEXT_WCTYPE_H)|g' \
+	      -e 's/@''HAVE_ISWCNTRL''@/$(HAVE_ISWCNTRL)/g' \
+	      -e 's/@''HAVE_WINT_T''@/$(HAVE_WINT_T)/g' \
+	      -e 's/@''REPLACE_ISWCNTRL''@/$(REPLACE_ISWCNTRL)/g' \
+	      < $(srcdir)/wctype.in.h; \
+	} > $@-t
+	mv $@-t $@
+MOSTLYCLEANFILES += wctype.h wctype.h-t
+
+EXTRA_DIST += wctype.in.h
+
+## end   gnulib module wctype
+
+## begin gnulib module dummy
+
+libgnu_la_SOURCES += dummy.c
+
+## end   gnulib module dummy
+
+
+mostlyclean-local: mostlyclean-generic
+	@for dir in '' $(MOSTLYCLEANDIRS); do \
+	  if test -n "$$dir" && test -d $$dir; then \
+	    echo "rmdir $$dir"; rmdir $$dir; \
+	  fi; \
+	done; \
+	:
diff -urN popt-for-windows/lib/malloc.c popt-for-windows-gnulib/lib/malloc.c
--- popt-for-windows/lib/malloc.c	1970-01-01 01:00:00.000000000 +0100
+++ popt-for-windows-gnulib/lib/malloc.c	2008-10-25 15:17:05.000000000 +0100
@@ -0,0 +1,57 @@
+/* malloc() function that is glibc compatible.
+
+   Copyright (C) 1997, 1998, 2006, 2007 Free Software Foundation, Inc.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software Foundation,
+   Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
+
+/* written by Jim Meyering and Bruno Haible */
+
+#include <config.h>
+/* Only the AC_FUNC_MALLOC macro defines 'malloc' already in config.h.  */
+#ifdef malloc
+# define NEED_MALLOC_GNU
+# undef malloc
+#endif
+
+/* Specification.  */
+#include <stdlib.h>
+
+#include <errno.h>
+
+/* Call the system's malloc below.  */
+#undef malloc
+
+/* Allocate an N-byte block of memory from the heap.
+   If N is zero, allocate a 1-byte block.  */
+
+void *
+rpl_malloc (size_t n)
+{
+  void *result;
+
+#ifdef NEED_MALLOC_GNU
+  if (n == 0)
+    n = 1;
+#endif
+
+  result = malloc (n);
+
+#if !HAVE_MALLOC_POSIX
+  if (result == NULL)
+    errno = ENOMEM;
+#endif
+
+  return result;
+}
diff -urN popt-for-windows/lib/mempcpy.c popt-for-windows-gnulib/lib/mempcpy.c
--- popt-for-windows/lib/mempcpy.c	1970-01-01 01:00:00.000000000 +0100
+++ popt-for-windows-gnulib/lib/mempcpy.c	2008-10-25 15:17:05.000000000 +0100
@@ -0,0 +1,29 @@
+/* Copy memory area and return pointer after last written byte.
+   Copyright (C) 2003, 2007 Free Software Foundation, Inc.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software Foundation,
+   Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
+
+#include <config.h>
+
+/* Specification.  */
+#include <string.h>
+
+/* Copy N bytes of SRC to DEST, return pointer to bytes after the
+   last written byte.  */
+void *
+mempcpy (void *dest, const void *src, size_t n)
+{
+  return (char *) memcpy (dest, src, n) + n;
+}
diff -urN popt-for-windows/lib/stdbool.in.h popt-for-windows-gnulib/lib/stdbool.in.h
--- popt-for-windows/lib/stdbool.in.h	1970-01-01 01:00:00.000000000 +0100
+++ popt-for-windows-gnulib/lib/stdbool.in.h	2008-10-25 15:17:05.000000000 +0100
@@ -0,0 +1,119 @@
+/* Copyright (C) 2001-2003, 2006-2008 Free Software Foundation, Inc.
+   Written by Bruno Haible <haible@clisp.cons.org>, 2001.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software Foundation,
+   Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
+
+#ifndef _GL_STDBOOL_H
+#define _GL_STDBOOL_H
+
+/* ISO C 99 <stdbool.h> for platforms that lack it.  */
+
+/* Usage suggestions:
+
+   Programs that use <stdbool.h> should be aware of some limitations
+   and standards compliance issues.
+
+   Standards compliance:
+
+       - <stdbool.h> must be #included before 'bool', 'false', 'true'
+         can be used.
+
+       - You cannot assume that sizeof (bool) == 1.
+
+       - Programs should not undefine the macros bool, true, and false,
+         as C99 lists that as an "obsolescent feature".
+
+   Limitations of this substitute, when used in a C89 environment:
+
+       - <stdbool.h> must be #included before the '_Bool' type can be used.
+
+       - You cannot assume that _Bool is a typedef; it might be a macro.
+
+       - Bit-fields of type 'bool' are not supported.  Portable code
+         should use 'unsigned int foo : 1;' rather than 'bool foo : 1;'.
+
+       - In C99, casts and automatic conversions to '_Bool' or 'bool' are
+         performed in such a way that every nonzero value gets converted
+         to 'true', and zero gets converted to 'false'.  This doesn't work
+         with this substitute.  With this substitute, only the values 0 and 1
+         give the expected result when converted to _Bool' or 'bool'.
+
+   Also, it is suggested that programs use 'bool' rather than '_Bool';
+   this isn't required, but 'bool' is more common.  */
+
+
+/* 7.16. Boolean type and values */
+
+/* BeOS <sys/socket.h> already #defines false 0, true 1.  We use the same
+   definitions below, but temporarily we have to #undef them.  */
+#if defined __BEOS__ && !defined __HAIKU__
+# include <OS.h> /* defines bool but not _Bool */
+# undef false
+# undef true
+#endif
+
+/* For the sake of symbolic names in gdb, we define true and false as
+   enum constants, not only as macros.
+   It is tempting to write
+      typedef enum { false = 0, true = 1 } _Bool;
+   so that gdb prints values of type 'bool' symbolically. But if we do
+   this, values of type '_Bool' may promote to 'int' or 'unsigned int'
+   (see ISO C 99 6.7.2.2.(4)); however, '_Bool' must promote to 'int'
+   (see ISO C 99 6.3.1.1.(2)).  So we add a negative value to the
+   enum; this ensures that '_Bool' promotes to 'int'.  */
+#if defined __cplusplus || (defined __BEOS__ && !defined __HAIKU__)
+  /* A compiler known to have 'bool'.  */
+  /* If the compiler already has both 'bool' and '_Bool', we can assume they
+     are the same types.  */
+# if !@HAVE__BOOL@
+typedef bool _Bool;
+# endif
+#else
+# if !defined __GNUC__
+   /* If @HAVE__BOOL@:
+        Some HP-UX cc and AIX IBM C compiler versions have compiler bugs when
+        the built-in _Bool type is used.  See
+          http://gcc.gnu.org/ml/gcc-patches/2003-12/msg02303.html
+          http://lists.gnu.org/archive/html/bug-coreutils/2005-11/msg00161.html
+          http://lists.gnu.org/archive/html/bug-coreutils/2005-10/msg00086.html
+        Similar bugs are likely with other compilers as well; this file
+        wouldn't be used if <stdbool.h> was working.
+        So we override the _Bool type.
+      If !@HAVE__BOOL@:
+        Need to define _Bool ourselves. As 'signed char' or as an enum type?
+        Use of a typedef, with SunPRO C, leads to a stupid
+          "warning: _Bool is a keyword in ISO C99".
+        Use of an enum type, with IRIX cc, leads to a stupid
+          "warning(1185): enumerated type mixed with another type".
+        Even the existence of an enum type, without a typedef,
+          "Invalid enumerator. (badenum)" with HP-UX cc on Tru64.
+        The only benefit of the enum, debuggability, is not important
+        with these compilers.  So use 'signed char' and no enum.  */
+#  define _Bool signed char
+# else
+   /* With this compiler, trust the _Bool type if the compiler has it.  */
+#  if !@HAVE__BOOL@
+typedef enum { _Bool_must_promote_to_int = -1, false = 0, true = 1 } _Bool;
+#  endif
+# endif
+#endif
+#define bool _Bool
+
+/* The other macros must be usable in preprocessor directives.  */
+#define false 0
+#define true 1
+#define __bool_true_false_are_defined 1
+
+#endif /* _GL_STDBOOL_H */
diff -urN popt-for-windows/lib/stdlib.in.h popt-for-windows-gnulib/lib/stdlib.in.h
--- popt-for-windows/lib/stdlib.in.h	1970-01-01 01:00:00.000000000 +0100
+++ popt-for-windows-gnulib/lib/stdlib.in.h	2008-10-25 15:17:05.000000000 +0100
@@ -0,0 +1,486 @@
+/* A GNU-like <stdlib.h>.
+
+   Copyright (C) 1995, 2001-2004, 2006-2008 Free Software Foundation, Inc.
+
+   This program is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+#if __GNUC__ >= 3
+@PRAGMA_SYSTEM_HEADER@
+#endif
+
+#if defined __need_malloc_and_calloc
+/* Special invocation convention inside glibc header files.  */
+
+#@INCLUDE_NEXT@ @NEXT_STDLIB_H@
+
+#else
+/* Normal invocation convention.  */
+
+#ifndef _GL_STDLIB_H
+
+/* The include_next requires a split double-inclusion guard.  */
+#@INCLUDE_NEXT@ @NEXT_STDLIB_H@
+
+#ifndef _GL_STDLIB_H
+#define _GL_STDLIB_H
+
+
+/* Solaris declares getloadavg() in <sys/loadavg.h>.  */
+#if @GNULIB_GETLOADAVG@ && @HAVE_SYS_LOADAVG_H@
+# include <sys/loadavg.h>
+#endif
+
+/* The definition of GL_LINK_WARNING is copied here.  */
+
+
+/* Some systems do not define EXIT_*, despite otherwise supporting C89.  */
+#ifndef EXIT_SUCCESS
+# define EXIT_SUCCESS 0
+#endif
+/* Tandem/NSK and other platforms that define EXIT_FAILURE as -1 interfere
+   with proper operation of xargs.  */
+#ifndef EXIT_FAILURE
+# define EXIT_FAILURE 1
+#elif EXIT_FAILURE != 1
+# undef EXIT_FAILURE
+# define EXIT_FAILURE 1
+#endif
+
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+#if @GNULIB_MALLOC_POSIX@
+# if !@HAVE_MALLOC_POSIX@
+#  undef malloc
+#  define malloc rpl_malloc
+extern void * malloc (size_t size);
+# endif
+#elif defined GNULIB_POSIXCHECK
+# undef malloc
+# define malloc(s) \
+    (GL_LINK_WARNING ("malloc is not POSIX compliant everywhere - " \
+                      "use gnulib module malloc-posix for portability"), \
+     malloc (s))
+#endif
+
+
+#if @GNULIB_REALLOC_POSIX@
+# if !@HAVE_REALLOC_POSIX@
+#  undef realloc
+#  define realloc rpl_realloc
+extern void * realloc (void *ptr, size_t size);
+# endif
+#elif defined GNULIB_POSIXCHECK
+# undef realloc
+# define realloc(p,s) \
+    (GL_LINK_WARNING ("realloc is not POSIX compliant everywhere - " \
+                      "use gnulib module realloc-posix for portability"), \
+     realloc (p, s))
+#endif
+
+
+#if @GNULIB_CALLOC_POSIX@
+# if !@HAVE_CALLOC_POSIX@
+#  undef calloc
+#  define calloc rpl_calloc
+extern void * calloc (size_t nmemb, size_t size);
+# endif
+#elif defined GNULIB_POSIXCHECK
+# undef calloc
+# define calloc(n,s) \
+    (GL_LINK_WARNING ("calloc is not POSIX compliant everywhere - " \
+                      "use gnulib module calloc-posix for portability"), \
+     calloc (n, s))
+#endif
+
+
+#if @GNULIB_ATOLL@
+# if !@HAVE_ATOLL@
+/* Parse a signed decimal integer.
+   Returns the value of the integer.  Errors are not detected.  */
+extern long long atoll (const char *string);
+# endif
+#elif defined GNULIB_POSIXCHECK
+# undef atoll
+# define atoll(s) \
+    (GL_LINK_WARNING ("atoll is unportable - " \
+                      "use gnulib module atoll for portability"), \
+     atoll (s))
+#endif
+
+
+#if @GNULIB_GETLOADAVG@
+# if !@HAVE_DECL_GETLOADAVG@
+/* Store max(NELEM,3) load average numbers in LOADAVG[].
+   The three numbers are the load average of the last 1 minute, the last 5
+   minutes, and the last 15 minutes, respectively.
+   LOADAVG is an array of NELEM numbers.  */
+extern int getloadavg (double loadavg[], int nelem);
+# endif
+#elif defined GNULIB_POSIXCHECK
+# undef getloadavg
+# define getloadavg(l,n) \
+    (GL_LINK_WARNING ("getloadavg is not portable - " \
+                      "use gnulib module getloadavg for portability"), \
+     getloadavg (l, n))
+#endif
+
+
+#if @GNULIB_GETSUBOPT@
+/* Assuming *OPTIONP is a comma separated list of elements of the form
+   "token" or "token=value", getsubopt parses the first of these elements.
+   If the first element refers to a "token" that is member of the given
+   NULL-terminated array of tokens:
+     - It replaces the comma with a NUL byte, updates *OPTIONP to point past
+       the first option and the comma, sets *VALUEP to the value of the
+       element (or NULL if it doesn't contain an "=" sign),
+     - It returns the index of the "token" in the given array of tokens.
+   Otherwise it returns -1, and *OPTIONP and *VALUEP are undefined.
+   For more details see the POSIX:2001 specification.
+   http://www.opengroup.org/susv3xsh/getsubopt.html */
+# if !@HAVE_GETSUBOPT@
+extern int getsubopt (char **optionp, char *const *tokens, char **valuep);
+# endif
+#elif defined GNULIB_POSIXCHECK
+# undef getsubopt
+# define getsubopt(o,t,v) \
+    (GL_LINK_WARNING ("getsubopt is unportable - " \
+                      "use gnulib module getsubopt for portability"), \
+     getsubopt (o, t, v))
+#endif
+
+
+#if @GNULIB_MKDTEMP@
+# if !@HAVE_MKDTEMP@
+/* Create a unique temporary directory from TEMPLATE.
+   The last six characters of TEMPLATE must be "XXXXXX";
+   they are replaced with a string that makes the directory name unique.
+   Returns TEMPLATE, or a null pointer if it cannot get a unique name.
+   The directory is created mode 700.  */
+extern char * mkdtemp (char * /*template*/);
+# endif
+#elif defined GNULIB_POSIXCHECK
+# undef mkdtemp
+# define mkdtemp(t) \
+    (GL_LINK_WARNING ("mkdtemp is unportable - " \
+                      "use gnulib module mkdtemp for portability"), \
+     mkdtemp (t))
+#endif
+
+
+#if @GNULIB_MKSTEMP@
+# if @REPLACE_MKSTEMP@
+/* Create a unique temporary file from TEMPLATE.
+   The last six characters of TEMPLATE must be "XXXXXX";
+   they are replaced with a string that makes the file name unique.
+   The file is then created, ensuring it didn't exist before.
+   The file is created read-write (mask at least 0600 & ~umask), but it may be
+   world-readable and world-writable (mask 0666 & ~umask), depending on the
+   implementation.
+   Returns the open file descriptor if successful, otherwise -1 and errno
+   set.  */
+#  define mkstemp rpl_mkstemp
+extern int mkstemp (char * /*template*/);
+# else
+/* On MacOS X 10.3, only <unistd.h> declares mkstemp.  */
+#  include <unistd.h>
+# endif
+#elif defined GNULIB_POSIXCHECK
+# undef mkstemp
+# define mkstemp(t) \
+    (GL_LINK_WARNING ("mkstemp is unportable - " \
+                      "use gnulib module mkstemp for portability"), \
+     mkstemp (t))
+#endif
+
+
+#if @GNULIB_PUTENV@
+# if @REPLACE_PUTENV@
+#  undef putenv
+#  define putenv rpl_putenv
+extern int putenv (char *string);
+# endif
+#endif
+
+
+#if @GNULIB_RAND48@
+# if !@HAVE_RAND48@
+
+struct drand48_data
+  {
+    unsigned short int __x[3];  /* Current state.  */
+    unsigned short int __old_x[3]; /* Old state.  */
+    unsigned short int __c;     /* Additive const. in congruential formula.  */
+    unsigned short int __init;  /* Flag for initializing.  */
+    unsigned long long int __a; /* Factor in congruential formula.  */
+  };
+
+double drand48 (void);
+int drand48_r (struct drand48_data *buffer, double *result);
+double erand48 ( unsigned short int xsubi[3]);
+int erand48_r (unsigned short int xsubi[3], struct drand48_data *buffer, double *result);
+long int jrand48 (unsigned short int xsubi[3]);
+int jrand48_r (unsigned short int xsubi[3], struct drand48_data *buffer, long int *result);
+void lcong48 (unsigned short int param[7]);
+int lcong48_r (unsigned short int param[7], struct drand48_data *buffer);
+long int lrand48 ();
+int lrand48_r (struct drand48_data *buffer, long int *result);
+long int mrand48 ();
+int mrand48_r (struct drand48_data *buffer, long int *result);
+long int nrand48 (unsigned short int xsubi[3]);
+int nrand48_r (unsigned short int xsubi[3], struct drand48_data *buffer, long int *result);
+unsigned short int *seed48 (unsigned short int seed16v[3]);
+int seed48_r (unsigned short int seed16v[3], struct drand48_data *buffer);
+void srand48 (long seedval);
+int srand48_r (long int seedval, struct drand48_data *buffer);
+
+# endif
+#elif defined GNULIB_POSIXCHECK
+# undef drand48
+# define drand48()				  \
+    (GL_LINK_WARNING ("drand48 is unportable - " \
+                      "use gnulib module rand48 for portability"), \
+     drand48 ())
+# undef drand48_r
+# define drand48_r(b,r)				 \
+    (GL_LINK_WARNING ("drand48_r is unportable - " \
+                      "use gnulib module rand48 for portability"), \
+     drand48_r (b,r))
+# undef erand48
+# define erand48(a)				  \
+    (GL_LINK_WARNING ("erand48 is unportable - " \
+                      "use gnulib module rand48 for portability"), \
+     erand48 (a))
+# undef erand48_r
+# define erand48_r(a,b,r)			 \
+    (GL_LINK_WARNING ("erand48_r is unportable - " \
+                      "use gnulib module rand48 for portability"), \
+     erand48_r (a,b,r))
+# undef jrand48
+# define jrand48(a)				  \
+    (GL_LINK_WARNING ("jrand48 is unportable - " \
+                      "use gnulib module rand48 for portability"), \
+     jrand48 (a))
+# undef jrand48_r
+# define jrand48_r(a,b,r)			 \
+    (GL_LINK_WARNING ("drand48 is unportable - " \
+                      "use gnulib module rand48 for portability"), \
+     jrand48_r (a,b,r))
+# undef lcong48
+# define lcong48(p)				  \
+    (GL_LINK_WARNING ("lcong48 is unportable - " \
+                      "use gnulib module rand48 for portability"), \
+     lcong48 (p))
+# undef lcong48_r
+# define lcong48_r(p,b)				 \
+    (GL_LINK_WARNING ("lcong48_r is unportable - " \
+                      "use gnulib module rand48 for portability"), \
+     lcong48_r (p,b))
+# undef lrand48
+# define lrand48()				  \
+    (GL_LINK_WARNING ("lrand48 is unportable - " \
+                      "use gnulib module rand48 for portability"), \
+     lrand48 ())
+# undef lrand48_r
+# define lrand48_r(b,r)				 \
+    (GL_LINK_WARNING ("lrand48_r is unportable - " \
+                      "use gnulib module rand48 for portability"), \
+     lrand48_r (b,r))
+# undef mrand48
+# define mrand48()				  \
+    (GL_LINK_WARNING ("mrand48 is unportable - " \
+                      "use gnulib module rand48 for portability"), \
+     mrand48 ())
+# undef mrand48_r
+# define mrand48_r(b,r)				   \
+    (GL_LINK_WARNING ("mrand48_r is unportable - " \
+                      "use gnulib module rand48 for portability"), \
+     mrand48_r (b,r))
+# undef nrand48
+# define nrand48(a)				 \
+    (GL_LINK_WARNING ("nrand48 is unportable - " \
+                      "use gnulib module rand48 for portability"), \
+     nrand48 (a,))
+# undef nrand48_r
+# define nrand48_r(a,b,r)			   \
+    (GL_LINK_WARNING ("nrand48_r is unportable - " \
+                      "use gnulib module rand48 for portability"), \
+     nrand48_r (a,b,r))
+# undef seed48
+# define seed48(s)				  \
+    (GL_LINK_WARNING ("seed48 is unportable - " \
+                      "use gnulib module rand48 for portability"), \
+     seed48 (s))
+# undef seed48_r
+# define seed48_r(s,b)				   \
+    (GL_LINK_WARNING ("seed48_r is unportable - " \
+                      "use gnulib module rand48 for portability"), \
+     seed48_r (s,b))
+# undef srand48
+# define srand48(s)				  \
+    (GL_LINK_WARNING ("srand48 is unportable - " \
+                      "use gnulib module rand48 for portability"), \
+     srand48 (s))
+# undef srand48_r
+# define srand48_r(s,b)				   \
+    (GL_LINK_WARNING ("srand48_r is unportable - " \
+                      "use gnulib module rand48 for portability"), \
+     srand48_r (s,b))
+#endif
+
+
+#if @GNULIB_RANDOM_R@
+# if !@HAVE_RANDOM_R@
+
+#  ifndef RAND_MAX
+#   define RAND_MAX 2147483647
+#  endif
+
+int srandom_r (unsigned int seed, struct random_data *rand_state);
+int initstate_r (unsigned int seed, char *buf, size_t buf_size,
+		 struct random_data *rand_state);
+int setstate_r (char *arg_state, struct random_data *rand_state);
+int random_r (struct random_data *buf, int32_t *result);
+# endif
+#elif defined GNULIB_POSIXCHECK
+# undef random_r
+# define random_r(b,r)				  \
+    (GL_LINK_WARNING ("random_r is unportable - " \
+                      "use gnulib module random_r for portability"), \
+     random_r (b,r))
+# undef initstate_r
+# define initstate_r(s,b,sz,r)			     \
+    (GL_LINK_WARNING ("initstate_r is unportable - " \
+                      "use gnulib module random_r for portability"), \
+     initstate_r (s,b,sz,r))
+# undef srandom_r
+# define srandom_r(s,r)				   \
+    (GL_LINK_WARNING ("srandom_r is unportable - " \
+                      "use gnulib module random_r for portability"), \
+     srandom_r (s,r))
+# undef setstate_r
+# define setstate_r(a,r)				    \
+    (GL_LINK_WARNING ("setstate_r is unportable - " \
+                      "use gnulib module random_r for portability"), \
+     setstate_r (a,r))
+#endif
+
+
+#if @GNULIB_RPMATCH@
+# if !@HAVE_RPMATCH@
+/* Test a user response to a question.
+   Return 1 if it is affirmative, 0 if it is negative, or -1 if not clear.  */
+extern int rpmatch (const char *response);
+# endif
+#elif defined GNULIB_POSIXCHECK
+# undef rpmatch
+# define rpmatch(r) \
+    (GL_LINK_WARNING ("rpmatch is unportable - " \
+                      "use gnulib module rpmatch for portability"), \
+     rpmatch (r))
+#endif
+
+
+#if @GNULIB_SETENV@
+# if !@HAVE_SETENV@
+/* Set NAME to VALUE in the environment.
+   If REPLACE is nonzero, overwrite an existing value.  */
+extern int setenv (const char *name, const char *value, int replace);
+# endif
+#endif
+
+
+#if @GNULIB_UNSETENV@
+# if @HAVE_UNSETENV@
+#  if @VOID_UNSETENV@
+/* On some systems, unsetenv() returns void.
+   This is the case for MacOS X 10.3, FreeBSD 4.8, NetBSD 1.6, OpenBSD 3.4.  */
+#   define unsetenv(name) ((unsetenv)(name), 0)
+#  endif
+# else
+/* Remove the variable NAME from the environment.  */
+extern int unsetenv (const char *name);
+# endif
+#endif
+
+
+#if @GNULIB_STRTOD@
+# if @REPLACE_STRTOD@
+#  define strtod rpl_strtod
+# endif
+# if !@HAVE_STRTOD@ || @REPLACE_STRTOD@
+ /* Parse a double from STRING, updating ENDP if appropriate.  */
+extern double strtod (const char *str, char **endp);
+# endif
+#elif defined GNULIB_POSIXCHECK
+# undef strtod
+# define strtod(s, e)                           \
+    (GL_LINK_WARNING ("strtod is unportable - " \
+                      "use gnulib module strtod for portability"), \
+     strtod (s, e))
+#endif
+
+
+#if @GNULIB_STRTOLL@
+# if !@HAVE_STRTOLL@
+/* Parse a signed integer whose textual representation starts at STRING.
+   The integer is expected to be in base BASE (2 <= BASE <= 36); if BASE == 0,
+   it may be decimal or octal (with prefix "0") or hexadecimal (with prefix
+   "0x").
+   If ENDPTR is not NULL, the address of the first byte after the integer is
+   stored in *ENDPTR.
+   Upon overflow, the return value is LLONG_MAX or LLONG_MIN, and errno is set
+   to ERANGE.  */
+extern long long strtoll (const char *string, char **endptr, int base);
+# endif
+#elif defined GNULIB_POSIXCHECK
+# undef strtoll
+# define strtoll(s,e,b) \
+    (GL_LINK_WARNING ("strtoll is unportable - " \
+                      "use gnulib module strtoll for portability"), \
+     strtoll (s, e, b))
+#endif
+
+
+#if @GNULIB_STRTOULL@
+# if !@HAVE_STRTOULL@
+/* Parse an unsigned integer whose textual representation starts at STRING.
+   The integer is expected to be in base BASE (2 <= BASE <= 36); if BASE == 0,
+   it may be decimal or octal (with prefix "0") or hexadecimal (with prefix
+   "0x").
+   If ENDPTR is not NULL, the address of the first byte after the integer is
+   stored in *ENDPTR.
+   Upon overflow, the return value is ULLONG_MAX, and errno is set to
+   ERANGE.  */
+extern unsigned long long strtoull (const char *string, char **endptr, int base);
+# endif
+#elif defined GNULIB_POSIXCHECK
+# undef strtoull
+# define strtoull(s,e,b) \
+    (GL_LINK_WARNING ("strtoull is unportable - " \
+                      "use gnulib module strtoull for portability"), \
+     strtoull (s, e, b))
+#endif
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* _GL_STDLIB_H */
+#endif /* _GL_STDLIB_H */
+#endif
diff -urN popt-for-windows/lib/strdup.c popt-for-windows-gnulib/lib/strdup.c
--- popt-for-windows/lib/strdup.c	1970-01-01 01:00:00.000000000 +0100
+++ popt-for-windows-gnulib/lib/strdup.c	2008-10-25 15:17:05.000000000 +0100
@@ -0,0 +1,55 @@
+/* Copyright (C) 1991, 1996, 1997, 1998, 2002, 2003, 2004, 2006, 2007 Free
+   Software Foundation, Inc.
+
+   This file is part of the GNU C Library.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License along
+   with this program; if not, write to the Free Software Foundation,
+   Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
+
+#ifndef _LIBC
+# include <config.h>
+#endif
+
+/* Get specification.  */
+#include <string.h>
+
+#include <stdlib.h>
+
+#undef __strdup
+#ifdef _LIBC
+# undef strdup
+#endif
+
+#ifndef weak_alias
+# define __strdup strdup
+#endif
+
+/* Duplicate S, returning an identical malloc'd string.  */
+char *
+__strdup (const char *s)
+{
+  size_t len = strlen (s) + 1;
+  void *new = malloc (len);
+
+  if (new == NULL)
+    return NULL;
+
+  return (char *) memcpy (new, s, len);
+}
+#ifdef libc_hidden_def
+libc_hidden_def (__strdup)
+#endif
+#ifdef weak_alias
+weak_alias (__strdup, strdup)
+#endif
diff -urN popt-for-windows/lib/string.in.h popt-for-windows-gnulib/lib/string.in.h
--- popt-for-windows/lib/string.in.h	1970-01-01 01:00:00.000000000 +0100
+++ popt-for-windows-gnulib/lib/string.in.h	2008-10-25 15:17:05.000000000 +0100
@@ -0,0 +1,605 @@
+/* A GNU-like <string.h>.
+
+   Copyright (C) 1995-1996, 2001-2008 Free Software Foundation, Inc.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software Foundation,
+   Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
+
+#ifndef _GL_STRING_H
+
+#if __GNUC__ >= 3
+@PRAGMA_SYSTEM_HEADER@
+#endif
+
+/* The include_next requires a split double-inclusion guard.  */
+#@INCLUDE_NEXT@ @NEXT_STRING_H@
+
+#ifndef _GL_STRING_H
+#define _GL_STRING_H
+
+
+#ifndef __attribute__
+/* This feature is available in gcc versions 2.5 and later.  */
+# if __GNUC__ < 2 || (__GNUC__ == 2 && __GNUC_MINOR__ < 5)
+#  define __attribute__(Spec) /* empty */
+# endif
+/* The attribute __pure__ was added in gcc 2.96.  */
+# if __GNUC__ < 2 || (__GNUC__ == 2 && __GNUC_MINOR__ < 96)
+#  define __pure__ /* empty */
+# endif
+#endif
+
+
+/* The definition of GL_LINK_WARNING is copied here.  */
+
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+/* Return the first occurrence of NEEDLE in HAYSTACK.  */
+#if @GNULIB_MEMMEM@
+# if @REPLACE_MEMMEM@
+#  define memmem rpl_memmem
+# endif
+# if ! @HAVE_DECL_MEMMEM@ || @REPLACE_MEMMEM@
+extern void *memmem (void const *__haystack, size_t __haystack_len,
+		     void const *__needle, size_t __needle_len)
+  __attribute__ ((__pure__));
+# endif
+#elif defined GNULIB_POSIXCHECK
+# undef memmem
+# define memmem(a,al,b,bl) \
+    (GL_LINK_WARNING ("memmem is unportable and often quadratic - " \
+                      "use gnulib module memmem-simple for portability, " \
+                      "and module memmem for speed" ), \
+     memmem (a, al, b, bl))
+#endif
+
+/* Copy N bytes of SRC to DEST, return pointer to bytes after the
+   last written byte.  */
+#if @GNULIB_MEMPCPY@
+# if ! @HAVE_MEMPCPY@
+extern void *mempcpy (void *restrict __dest, void const *restrict __src,
+		      size_t __n);
+# endif
+#elif defined GNULIB_POSIXCHECK
+# undef mempcpy
+# define mempcpy(a,b,n) \
+    (GL_LINK_WARNING ("mempcpy is unportable - " \
+                      "use gnulib module mempcpy for portability"), \
+     mempcpy (a, b, n))
+#endif
+
+/* Search backwards through a block for a byte (specified as an int).  */
+#if @GNULIB_MEMRCHR@
+# if ! @HAVE_DECL_MEMRCHR@
+extern void *memrchr (void const *, int, size_t)
+  __attribute__ ((__pure__));
+# endif
+#elif defined GNULIB_POSIXCHECK
+# undef memrchr
+# define memrchr(a,b,c) \
+    (GL_LINK_WARNING ("memrchr is unportable - " \
+                      "use gnulib module memrchr for portability"), \
+     memrchr (a, b, c))
+#endif
+
+/* Find the first occurrence of C in S.  More efficient than
+   memchr(S,C,N), at the expense of undefined behavior if C does not
+   occur within N bytes.  */
+#if @GNULIB_RAWMEMCHR@
+# if ! @HAVE_RAWMEMCHR@
+extern void *rawmemchr (void const *__s, int __c_in)
+  __attribute__ ((__pure__));
+# endif
+#elif defined GNULIB_POSIXCHECK
+# undef rawmemchr
+# define rawmemchr(a,b) \
+    (GL_LINK_WARNING ("rawmemchr is unportable - " \
+                      "use gnulib module rawmemchr for portability"), \
+     rawmemchr (a, b))
+#endif
+
+/* Copy SRC to DST, returning the address of the terminating '\0' in DST.  */
+#if @GNULIB_STPCPY@
+# if ! @HAVE_STPCPY@
+extern char *stpcpy (char *restrict __dst, char const *restrict __src);
+# endif
+#elif defined GNULIB_POSIXCHECK
+# undef stpcpy
+# define stpcpy(a,b) \
+    (GL_LINK_WARNING ("stpcpy is unportable - " \
+                      "use gnulib module stpcpy for portability"), \
+     stpcpy (a, b))
+#endif
+
+/* Copy no more than N bytes of SRC to DST, returning a pointer past the
+   last non-NUL byte written into DST.  */
+#if @GNULIB_STPNCPY@
+# if ! @HAVE_STPNCPY@
+#  define stpncpy gnu_stpncpy
+extern char *stpncpy (char *restrict __dst, char const *restrict __src,
+		      size_t __n);
+# endif
+#elif defined GNULIB_POSIXCHECK
+# undef stpncpy
+# define stpncpy(a,b,n) \
+    (GL_LINK_WARNING ("stpncpy is unportable - " \
+                      "use gnulib module stpncpy for portability"), \
+     stpncpy (a, b, n))
+#endif
+
+#if defined GNULIB_POSIXCHECK
+/* strchr() does not work with multibyte strings if the locale encoding is
+   GB18030 and the character to be searched is a digit.  */
+# undef strchr
+# define strchr(s,c) \
+    (GL_LINK_WARNING ("strchr cannot work correctly on character strings " \
+                      "in some multibyte locales - " \
+                      "use mbschr if you care about internationalization"), \
+     strchr (s, c))
+#endif
+
+/* Find the first occurrence of C in S or the final NUL byte.  */
+#if @GNULIB_STRCHRNUL@
+# if ! @HAVE_STRCHRNUL@
+extern char *strchrnul (char const *__s, int __c_in)
+  __attribute__ ((__pure__));
+# endif
+#elif defined GNULIB_POSIXCHECK
+# undef strchrnul
+# define strchrnul(a,b) \
+    (GL_LINK_WARNING ("strchrnul is unportable - " \
+                      "use gnulib module strchrnul for portability"), \
+     strchrnul (a, b))
+#endif
+
+/* Duplicate S, returning an identical malloc'd string.  */
+#if @GNULIB_STRDUP@
+# if @REPLACE_STRDUP@
+#  undef strdup
+#  define strdup rpl_strdup
+# endif
+# if !(@HAVE_DECL_STRDUP@ || defined strdup) || @REPLACE_STRDUP@
+extern char *strdup (char const *__s);
+# endif
+#elif defined GNULIB_POSIXCHECK
+# undef strdup
+# define strdup(a) \
+    (GL_LINK_WARNING ("strdup is unportable - " \
+                      "use gnulib module strdup for portability"), \
+     strdup (a))
+#endif
+
+/* Return a newly allocated copy of at most N bytes of STRING.  */
+#if @GNULIB_STRNDUP@
+# if ! @HAVE_STRNDUP@
+#  undef strndup
+#  define strndup rpl_strndup
+# endif
+# if ! @HAVE_STRNDUP@ || ! @HAVE_DECL_STRNDUP@
+extern char *strndup (char const *__string, size_t __n);
+# endif
+#elif defined GNULIB_POSIXCHECK
+# undef strndup
+# define strndup(a,n) \
+    (GL_LINK_WARNING ("strndup is unportable - " \
+                      "use gnulib module strndup for portability"), \
+     strndup (a, n))
+#endif
+
+/* Find the length (number of bytes) of STRING, but scan at most
+   MAXLEN bytes.  If no '\0' terminator is found in that many bytes,
+   return MAXLEN.  */
+#if @GNULIB_STRNLEN@
+# if ! @HAVE_DECL_STRNLEN@
+extern size_t strnlen (char const *__string, size_t __maxlen)
+  __attribute__ ((__pure__));
+# endif
+#elif defined GNULIB_POSIXCHECK
+# undef strnlen
+# define strnlen(a,n) \
+    (GL_LINK_WARNING ("strnlen is unportable - " \
+                      "use gnulib module strnlen for portability"), \
+     strnlen (a, n))
+#endif
+
+#if defined GNULIB_POSIXCHECK
+/* strcspn() assumes the second argument is a list of single-byte characters.
+   Even in this simple case, it does not work with multibyte strings if the
+   locale encoding is GB18030 and one of the characters to be searched is a
+   digit.  */
+# undef strcspn
+# define strcspn(s,a) \
+    (GL_LINK_WARNING ("strcspn cannot work correctly on character strings " \
+                      "in multibyte locales - " \
+                      "use mbscspn if you care about internationalization"), \
+     strcspn (s, a))
+#endif
+
+/* Find the first occurrence in S of any character in ACCEPT.  */
+#if @GNULIB_STRPBRK@
+# if ! @HAVE_STRPBRK@
+extern char *strpbrk (char const *__s, char const *__accept)
+  __attribute__ ((__pure__));
+# endif
+# if defined GNULIB_POSIXCHECK
+/* strpbrk() assumes the second argument is a list of single-byte characters.
+   Even in this simple case, it does not work with multibyte strings if the
+   locale encoding is GB18030 and one of the characters to be searched is a
+   digit.  */
+#  undef strpbrk
+#  define strpbrk(s,a) \
+     (GL_LINK_WARNING ("strpbrk cannot work correctly on character strings " \
+                       "in multibyte locales - " \
+                       "use mbspbrk if you care about internationalization"), \
+      strpbrk (s, a))
+# endif
+#elif defined GNULIB_POSIXCHECK
+# undef strpbrk
+# define strpbrk(s,a) \
+    (GL_LINK_WARNING ("strpbrk is unportable - " \
+                      "use gnulib module strpbrk for portability"), \
+     strpbrk (s, a))
+#endif
+
+#if defined GNULIB_POSIXCHECK
+/* strspn() assumes the second argument is a list of single-byte characters.
+   Even in this simple case, it cannot work with multibyte strings.  */
+# undef strspn
+# define strspn(s,a) \
+    (GL_LINK_WARNING ("strspn cannot work correctly on character strings " \
+                      "in multibyte locales - " \
+                      "use mbsspn if you care about internationalization"), \
+     strspn (s, a))
+#endif
+
+#if defined GNULIB_POSIXCHECK
+/* strrchr() does not work with multibyte strings if the locale encoding is
+   GB18030 and the character to be searched is a digit.  */
+# undef strrchr
+# define strrchr(s,c) \
+    (GL_LINK_WARNING ("strrchr cannot work correctly on character strings " \
+                      "in some multibyte locales - " \
+                      "use mbsrchr if you care about internationalization"), \
+     strrchr (s, c))
+#endif
+
+/* Search the next delimiter (char listed in DELIM) starting at *STRINGP.
+   If one is found, overwrite it with a NUL, and advance *STRINGP
+   to point to the next char after it.  Otherwise, set *STRINGP to NULL.
+   If *STRINGP was already NULL, nothing happens.
+   Return the old value of *STRINGP.
+
+   This is a variant of strtok() that is multithread-safe and supports
+   empty fields.
+
+   Caveat: It modifies the original string.
+   Caveat: These functions cannot be used on constant strings.
+   Caveat: The identity of the delimiting character is lost.
+   Caveat: It doesn't work with multibyte strings unless all of the delimiter
+           characters are ASCII characters < 0x30.
+
+   See also strtok_r().  */
+#if @GNULIB_STRSEP@
+# if ! @HAVE_STRSEP@
+extern char *strsep (char **restrict __stringp, char const *restrict __delim);
+# endif
+# if defined GNULIB_POSIXCHECK
+#  undef strsep
+#  define strsep(s,d) \
+     (GL_LINK_WARNING ("strsep cannot work correctly on character strings " \
+                       "in multibyte locales - " \
+                       "use mbssep if you care about internationalization"), \
+      strsep (s, d))
+# endif
+#elif defined GNULIB_POSIXCHECK
+# undef strsep
+# define strsep(s,d) \
+    (GL_LINK_WARNING ("strsep is unportable - " \
+                      "use gnulib module strsep for portability"), \
+     strsep (s, d))
+#endif
+
+#if @GNULIB_STRSTR@
+# if @REPLACE_STRSTR@
+#  define strstr rpl_strstr
+char *strstr (const char *haystack, const char *needle)
+  __attribute__ ((__pure__));
+# endif
+#elif defined GNULIB_POSIXCHECK
+/* strstr() does not work with multibyte strings if the locale encoding is
+   different from UTF-8:
+   POSIX says that it operates on "strings", and "string" in POSIX is defined
+   as a sequence of bytes, not of characters.  */
+# undef strstr
+# define strstr(a,b) \
+    (GL_LINK_WARNING ("strstr is quadratic on many systems, and cannot " \
+                      "work correctly on character strings in most "    \
+                      "multibyte locales - " \
+                      "use mbsstr if you care about internationalization, " \
+                      "or use strstr if you care about speed"), \
+     strstr (a, b))
+#endif
+
+/* Find the first occurrence of NEEDLE in HAYSTACK, using case-insensitive
+   comparison.  */
+#if @GNULIB_STRCASESTR@
+# if @REPLACE_STRCASESTR@
+#  define strcasestr rpl_strcasestr
+# endif
+# if ! @HAVE_STRCASESTR@ || @REPLACE_STRCASESTR@
+extern char *strcasestr (const char *haystack, const char *needle)
+  __attribute__ ((__pure__));
+# endif
+#elif defined GNULIB_POSIXCHECK
+/* strcasestr() does not work with multibyte strings:
+   It is a glibc extension, and glibc implements it only for unibyte
+   locales.  */
+# undef strcasestr
+# define strcasestr(a,b) \
+    (GL_LINK_WARNING ("strcasestr does work correctly on character strings " \
+                      "in multibyte locales - " \
+                      "use mbscasestr if you care about " \
+                      "internationalization, or use c-strcasestr if you want " \
+                      "a locale independent function"), \
+     strcasestr (a, b))
+#endif
+
+/* Parse S into tokens separated by characters in DELIM.
+   If S is NULL, the saved pointer in SAVE_PTR is used as
+   the next starting point.  For example:
+	char s[] = "-abc-=-def";
+	char *sp;
+	x = strtok_r(s, "-", &sp);	// x = "abc", sp = "=-def"
+	x = strtok_r(NULL, "-=", &sp);	// x = "def", sp = NULL
+	x = strtok_r(NULL, "=", &sp);	// x = NULL
+		// s = "abc\0-def\0"
+
+   This is a variant of strtok() that is multithread-safe.
+
+   For the POSIX documentation for this function, see:
+   http://www.opengroup.org/susv3xsh/strtok.html
+
+   Caveat: It modifies the original string.
+   Caveat: These functions cannot be used on constant strings.
+   Caveat: The identity of the delimiting character is lost.
+   Caveat: It doesn't work with multibyte strings unless all of the delimiter
+           characters are ASCII characters < 0x30.
+
+   See also strsep().  */
+#if @GNULIB_STRTOK_R@
+# if ! @HAVE_DECL_STRTOK_R@
+extern char *strtok_r (char *restrict s, char const *restrict delim,
+		       char **restrict save_ptr);
+# endif
+# if defined GNULIB_POSIXCHECK
+#  undef strtok_r
+#  define strtok_r(s,d,p) \
+     (GL_LINK_WARNING ("strtok_r cannot work correctly on character strings " \
+                       "in multibyte locales - " \
+                       "use mbstok_r if you care about internationalization"), \
+      strtok_r (s, d, p))
+# endif
+#elif defined GNULIB_POSIXCHECK
+# undef strtok_r
+# define strtok_r(s,d,p) \
+    (GL_LINK_WARNING ("strtok_r is unportable - " \
+                      "use gnulib module strtok_r for portability"), \
+     strtok_r (s, d, p))
+#endif
+
+
+/* The following functions are not specified by POSIX.  They are gnulib
+   extensions.  */
+
+#if @GNULIB_MBSLEN@
+/* Return the number of multibyte characters in the character string STRING.
+   This considers multibyte characters, unlike strlen, which counts bytes.  */
+extern size_t mbslen (const char *string);
+#endif
+
+#if @GNULIB_MBSNLEN@
+/* Return the number of multibyte characters in the character string starting
+   at STRING and ending at STRING + LEN.  */
+extern size_t mbsnlen (const char *string, size_t len);
+#endif
+
+#if @GNULIB_MBSCHR@
+/* Locate the first single-byte character C in the character string STRING,
+   and return a pointer to it.  Return NULL if C is not found in STRING.
+   Unlike strchr(), this function works correctly in multibyte locales with
+   encodings such as GB18030.  */
+# define mbschr rpl_mbschr /* avoid collision with HP-UX function */
+extern char * mbschr (const char *string, int c);
+#endif
+
+#if @GNULIB_MBSRCHR@
+/* Locate the last single-byte character C in the character string STRING,
+   and return a pointer to it.  Return NULL if C is not found in STRING.
+   Unlike strrchr(), this function works correctly in multibyte locales with
+   encodings such as GB18030.  */
+# define mbsrchr rpl_mbsrchr /* avoid collision with HP-UX function */
+extern char * mbsrchr (const char *string, int c);
+#endif
+
+#if @GNULIB_MBSSTR@
+/* Find the first occurrence of the character string NEEDLE in the character
+   string HAYSTACK.  Return NULL if NEEDLE is not found in HAYSTACK.
+   Unlike strstr(), this function works correctly in multibyte locales with
+   encodings different from UTF-8.  */
+extern char * mbsstr (const char *haystack, const char *needle);
+#endif
+
+#if @GNULIB_MBSCASECMP@
+/* Compare the character strings S1 and S2, ignoring case, returning less than,
+   equal to or greater than zero if S1 is lexicographically less than, equal to
+   or greater than S2.
+   Note: This function may, in multibyte locales, return 0 for strings of
+   different lengths!
+   Unlike strcasecmp(), this function works correctly in multibyte locales.  */
+extern int mbscasecmp (const char *s1, const char *s2);
+#endif
+
+#if @GNULIB_MBSNCASECMP@
+/* Compare the initial segment of the character string S1 consisting of at most
+   N characters with the initial segment of the character string S2 consisting
+   of at most N characters, ignoring case, returning less than, equal to or
+   greater than zero if the initial segment of S1 is lexicographically less
+   than, equal to or greater than the initial segment of S2.
+   Note: This function may, in multibyte locales, return 0 for initial segments
+   of different lengths!
+   Unlike strncasecmp(), this function works correctly in multibyte locales.
+   But beware that N is not a byte count but a character count!  */
+extern int mbsncasecmp (const char *s1, const char *s2, size_t n);
+#endif
+
+#if @GNULIB_MBSPCASECMP@
+/* Compare the initial segment of the character string STRING consisting of
+   at most mbslen (PREFIX) characters with the character string PREFIX,
+   ignoring case, returning less than, equal to or greater than zero if this
+   initial segment is lexicographically less than, equal to or greater than
+   PREFIX.
+   Note: This function may, in multibyte locales, return 0 if STRING is of
+   smaller length than PREFIX!
+   Unlike strncasecmp(), this function works correctly in multibyte
+   locales.  */
+extern char * mbspcasecmp (const char *string, const char *prefix);
+#endif
+
+#if @GNULIB_MBSCASESTR@
+/* Find the first occurrence of the character string NEEDLE in the character
+   string HAYSTACK, using case-insensitive comparison.
+   Note: This function may, in multibyte locales, return success even if
+   strlen (haystack) < strlen (needle) !
+   Unlike strcasestr(), this function works correctly in multibyte locales.  */
+extern char * mbscasestr (const char *haystack, const char *needle);
+#endif
+
+#if @GNULIB_MBSCSPN@
+/* Find the first occurrence in the character string STRING of any character
+   in the character string ACCEPT.  Return the number of bytes from the
+   beginning of the string to this occurrence, or to the end of the string
+   if none exists.
+   Unlike strcspn(), this function works correctly in multibyte locales.  */
+extern size_t mbscspn (const char *string, const char *accept);
+#endif
+
+#if @GNULIB_MBSPBRK@
+/* Find the first occurrence in the character string STRING of any character
+   in the character string ACCEPT.  Return the pointer to it, or NULL if none
+   exists.
+   Unlike strpbrk(), this function works correctly in multibyte locales.  */
+# define mbspbrk rpl_mbspbrk /* avoid collision with HP-UX function */
+extern char * mbspbrk (const char *string, const char *accept);
+#endif
+
+#if @GNULIB_MBSSPN@
+/* Find the first occurrence in the character string STRING of any character
+   not in the character string REJECT.  Return the number of bytes from the
+   beginning of the string to this occurrence, or to the end of the string
+   if none exists.
+   Unlike strspn(), this function works correctly in multibyte locales.  */
+extern size_t mbsspn (const char *string, const char *reject);
+#endif
+
+#if @GNULIB_MBSSEP@
+/* Search the next delimiter (multibyte character listed in the character
+   string DELIM) starting at the character string *STRINGP.
+   If one is found, overwrite it with a NUL, and advance *STRINGP to point
+   to the next multibyte character after it.  Otherwise, set *STRINGP to NULL.
+   If *STRINGP was already NULL, nothing happens.
+   Return the old value of *STRINGP.
+
+   This is a variant of mbstok_r() that supports empty fields.
+
+   Caveat: It modifies the original string.
+   Caveat: These functions cannot be used on constant strings.
+   Caveat: The identity of the delimiting character is lost.
+
+   See also mbstok_r().  */
+extern char * mbssep (char **stringp, const char *delim);
+#endif
+
+#if @GNULIB_MBSTOK_R@
+/* Parse the character string STRING into tokens separated by characters in
+   the character string DELIM.
+   If STRING is NULL, the saved pointer in SAVE_PTR is used as
+   the next starting point.  For example:
+	char s[] = "-abc-=-def";
+	char *sp;
+	x = mbstok_r(s, "-", &sp);	// x = "abc", sp = "=-def"
+	x = mbstok_r(NULL, "-=", &sp);	// x = "def", sp = NULL
+	x = mbstok_r(NULL, "=", &sp);	// x = NULL
+		// s = "abc\0-def\0"
+
+   Caveat: It modifies the original string.
+   Caveat: These functions cannot be used on constant strings.
+   Caveat: The identity of the delimiting character is lost.
+
+   See also mbssep().  */
+extern char * mbstok_r (char *string, const char *delim, char **save_ptr);
+#endif
+
+/* Map any int, typically from errno, into an error message.  */
+#if @GNULIB_STRERROR@
+# if @REPLACE_STRERROR@
+#  undef strerror
+#  define strerror rpl_strerror
+extern char *strerror (int);
+# endif
+#elif defined GNULIB_POSIXCHECK
+# undef strerror
+# define strerror(e) \
+    (GL_LINK_WARNING ("strerror is unportable - " \
+                      "use gnulib module strerror to guarantee non-NULL result"), \
+     strerror (e))
+#endif
+
+#if @GNULIB_STRSIGNAL@
+# if @REPLACE_STRSIGNAL@
+#  define strsignal rpl_strsignal
+# endif
+# if ! @HAVE_DECL_STRSIGNAL@ || @REPLACE_STRSIGNAL@
+extern char *strsignal (int __sig);
+# endif
+#elif defined GNULIB_POSIXCHECK
+# undef strsignal
+# define strsignal(a) \
+    (GL_LINK_WARNING ("strsignal is unportable - " \
+                      "use gnulib module strsignal for portability"), \
+     strsignal (a))
+#endif
+
+#if @GNULIB_STRVERSCMP@
+# if !@HAVE_STRVERSCMP@
+extern int strverscmp (const char *, const char *);
+# endif
+#elif defined GNULIB_POSIXCHECK
+# undef strverscmp
+# define strverscmp(a, b) \
+    (GL_LINK_WARNING ("strverscmp is unportable - " \
+                      "use gnulib module strverscmp for portability"), \
+     strverscmp (a, b))
+#endif
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* _GL_STRING_H */
+#endif /* _GL_STRING_H */
diff -urN popt-for-windows/lib/sys_stat.in.h popt-for-windows-gnulib/lib/sys_stat.in.h
--- popt-for-windows/lib/sys_stat.in.h	1970-01-01 01:00:00.000000000 +0100
+++ popt-for-windows-gnulib/lib/sys_stat.in.h	2008-10-25 15:17:05.000000000 +0100
@@ -0,0 +1,339 @@
+/* Provide a more complete sys/stat header file.
+   Copyright (C) 2005-2008 Free Software Foundation, Inc.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software Foundation,
+   Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
+
+/* Written by Eric Blake, Paul Eggert, and Jim Meyering.  */
+
+/* This file is supposed to be used on platforms where <sys/stat.h> is
+   incomplete.  It is intended to provide definitions and prototypes
+   needed by an application.  Start with what the system provides.  */
+
+#if __GNUC__ >= 3
+@PRAGMA_SYSTEM_HEADER@
+#endif
+
+#if defined __need_system_sys_stat_h
+/* Special invocation convention.  */
+
+#@INCLUDE_NEXT@ @NEXT_SYS_STAT_H@
+
+#else
+/* Normal invocation convention.  */
+
+#ifndef _GL_SYS_STAT_H
+
+/* The include_next requires a split double-inclusion guard.  */
+#@INCLUDE_NEXT@ @NEXT_SYS_STAT_H@
+
+#ifndef _GL_SYS_STAT_H
+#define _GL_SYS_STAT_H
+
+/* The definition of GL_LINK_WARNING is copied here.  */
+
+/* Before doing "#define mkdir rpl_mkdir" below, we need to include all
+   headers that may declare mkdir().  */
+#if (defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__
+# include <io.h>
+#endif
+
+#ifndef S_IFMT
+# define S_IFMT 0170000
+#endif
+
+#if STAT_MACROS_BROKEN
+# undef S_ISBLK
+# undef S_ISCHR
+# undef S_ISDIR
+# undef S_ISFIFO
+# undef S_ISLNK
+# undef S_ISNAM
+# undef S_ISMPB
+# undef S_ISMPC
+# undef S_ISNWK
+# undef S_ISREG
+# undef S_ISSOCK
+#endif
+
+#ifndef S_ISBLK
+# ifdef S_IFBLK
+#  define S_ISBLK(m) (((m) & S_IFMT) == S_IFBLK)
+# else
+#  define S_ISBLK(m) 0
+# endif
+#endif
+
+#ifndef S_ISCHR
+# ifdef S_IFCHR
+#  define S_ISCHR(m) (((m) & S_IFMT) == S_IFCHR)
+# else
+#  define S_ISCHR(m) 0
+# endif
+#endif
+
+#ifndef S_ISDIR
+# ifdef S_IFDIR
+#  define S_ISDIR(m) (((m) & S_IFMT) == S_IFDIR)
+# else
+#  define S_ISDIR(m) 0
+# endif
+#endif
+
+#ifndef S_ISDOOR /* Solaris 2.5 and up */
+# define S_ISDOOR(m) 0
+#endif
+
+#ifndef S_ISFIFO
+# ifdef S_IFIFO
+#  define S_ISFIFO(m) (((m) & S_IFMT) == S_IFIFO)
+# else
+#  define S_ISFIFO(m) 0
+# endif
+#endif
+
+#ifndef S_ISLNK
+# ifdef S_IFLNK
+#  define S_ISLNK(m) (((m) & S_IFMT) == S_IFLNK)
+# else
+#  define S_ISLNK(m) 0
+# endif
+#endif
+
+#ifndef S_ISMPB /* V7 */
+# ifdef S_IFMPB
+#  define S_ISMPB(m) (((m) & S_IFMT) == S_IFMPB)
+#  define S_ISMPC(m) (((m) & S_IFMT) == S_IFMPC)
+# else
+#  define S_ISMPB(m) 0
+#  define S_ISMPC(m) 0
+# endif
+#endif
+
+#ifndef S_ISNAM /* Xenix */
+# ifdef S_IFNAM
+#  define S_ISNAM(m) (((m) & S_IFMT) == S_IFNAM)
+# else
+#  define S_ISNAM(m) 0
+# endif
+#endif
+
+#ifndef S_ISNWK /* HP/UX */
+# ifdef S_IFNWK
+#  define S_ISNWK(m) (((m) & S_IFMT) == S_IFNWK)
+# else
+#  define S_ISNWK(m) 0
+# endif
+#endif
+
+#ifndef S_ISPORT /* Solaris 10 and up */
+# define S_ISPORT(m) 0
+#endif
+
+#ifndef S_ISREG
+# ifdef S_IFREG
+#  define S_ISREG(m) (((m) & S_IFMT) == S_IFREG)
+# else
+#  define S_ISREG(m) 0
+# endif
+#endif
+
+#ifndef S_ISSOCK
+# ifdef S_IFSOCK
+#  define S_ISSOCK(m) (((m) & S_IFMT) == S_IFSOCK)
+# else
+#  define S_ISSOCK(m) 0
+# endif
+#endif
+
+
+#ifndef S_TYPEISMQ
+# define S_TYPEISMQ(p) 0
+#endif
+
+#ifndef S_TYPEISTMO
+# define S_TYPEISTMO(p) 0
+#endif
+
+
+#ifndef S_TYPEISSEM
+# ifdef S_INSEM
+#  define S_TYPEISSEM(p) (S_ISNAM ((p)->st_mode) && (p)->st_rdev == S_INSEM)
+# else
+#  define S_TYPEISSEM(p) 0
+# endif
+#endif
+
+#ifndef S_TYPEISSHM
+# ifdef S_INSHD
+#  define S_TYPEISSHM(p) (S_ISNAM ((p)->st_mode) && (p)->st_rdev == S_INSHD)
+# else
+#  define S_TYPEISSHM(p) 0
+# endif
+#endif
+
+/* high performance ("contiguous data") */
+#ifndef S_ISCTG
+# define S_ISCTG(p) 0
+#endif
+
+/* Cray DMF (data migration facility): off line, with data  */
+#ifndef S_ISOFD
+# define S_ISOFD(p) 0
+#endif
+
+/* Cray DMF (data migration facility): off line, with no data  */
+#ifndef S_ISOFL
+# define S_ISOFL(p) 0
+#endif
+
+/* 4.4BSD whiteout */
+#ifndef S_ISWHT
+# define S_ISWHT(m) 0
+#endif
+
+/* If any of the following are undefined,
+   define them to their de facto standard values.  */
+#if !S_ISUID
+# define S_ISUID 04000
+#endif
+#if !S_ISGID
+# define S_ISGID 02000
+#endif
+
+/* S_ISVTX is a common extension to POSIX.  */
+#ifndef S_ISVTX
+# define S_ISVTX 01000
+#endif
+
+#if !S_IRUSR && S_IREAD
+# define S_IRUSR S_IREAD
+#endif
+#if !S_IRUSR
+# define S_IRUSR 00400
+#endif
+#if !S_IRGRP
+# define S_IRGRP (S_IRUSR >> 3)
+#endif
+#if !S_IROTH
+# define S_IROTH (S_IRUSR >> 6)
+#endif
+
+#if !S_IWUSR && S_IWRITE
+# define S_IWUSR S_IWRITE
+#endif
+#if !S_IWUSR
+# define S_IWUSR 00200
+#endif
+#if !S_IWGRP
+# define S_IWGRP (S_IWUSR >> 3)
+#endif
+#if !S_IWOTH
+# define S_IWOTH (S_IWUSR >> 6)
+#endif
+
+#if !S_IXUSR && S_IEXEC
+# define S_IXUSR S_IEXEC
+#endif
+#if !S_IXUSR
+# define S_IXUSR 00100
+#endif
+#if !S_IXGRP
+# define S_IXGRP (S_IXUSR >> 3)
+#endif
+#if !S_IXOTH
+# define S_IXOTH (S_IXUSR >> 6)
+#endif
+
+#if !S_IRWXU
+# define S_IRWXU (S_IRUSR | S_IWUSR | S_IXUSR)
+#endif
+#if !S_IRWXG
+# define S_IRWXG (S_IRGRP | S_IWGRP | S_IXGRP)
+#endif
+#if !S_IRWXO
+# define S_IRWXO (S_IROTH | S_IWOTH | S_IXOTH)
+#endif
+
+/* S_IXUGO is a common extension to POSIX.  */
+#if !S_IXUGO
+# define S_IXUGO (S_IXUSR | S_IXGRP | S_IXOTH)
+#endif
+
+#ifndef S_IRWXUGO
+# define S_IRWXUGO (S_IRWXU | S_IRWXG | S_IRWXO)
+#endif
+
+/* mingw does not support symlinks, therefore it does not have lstat.  But
+   without links, stat does just fine.  */
+#if ! @HAVE_LSTAT@
+# define lstat stat
+#endif
+#if @GNULIB_LSTAT@ && @REPLACE_LSTAT@
+# undef lstat
+# define lstat rpl_lstat
+extern int rpl_lstat (const char *name, struct stat *buf);
+#endif
+
+
+#if @REPLACE_MKDIR@
+# undef mkdir
+# define mkdir rpl_mkdir
+extern int mkdir (char const *name, mode_t mode);
+#else
+/* mingw's _mkdir() function has 1 argument, but we pass 2 arguments.
+   Additionally, it declares _mkdir (and depending on compile flags, an
+   alias mkdir), only in the nonstandard <io.h>, which is included above.  */
+# if (defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__
+
+static inline int
+rpl_mkdir (char const *name, mode_t mode)
+{
+  return _mkdir (name);
+}
+
+#  define mkdir rpl_mkdir
+# endif
+#endif
+
+
+/* Declare BSD extensions.  */
+
+#if @GNULIB_LCHMOD@
+/* Change the mode of FILENAME to MODE, without dereferencing it if FILENAME
+   denotes a symbolic link.  */
+# if !@HAVE_LCHMOD@
+/* The lchmod replacement follows symbolic links.  Callers should take
+   this into account; lchmod should be applied only to arguments that
+   are known to not be symbolic links.  On hosts that lack lchmod,
+   this can lead to race conditions between the check and the
+   invocation of lchmod, but we know of no workarounds that are
+   reliable in general.  You might try requesting support for lchmod
+   from your operating system supplier.  */
+#  define lchmod chmod
+# endif
+# if 0 /* assume already declared */
+extern int lchmod (const char *filename, mode_t mode);
+# endif
+#elif defined GNULIB_POSIXCHECK
+# undef lchmod
+# define lchmod(f,m) \
+    (GL_LINK_WARNING ("lchmod is unportable - " \
+                      "use gnulib module lchmod for portability"), \
+     lchmod (f, m))
+#endif
+
+#endif /* _GL_SYS_STAT_H */
+#endif /* _GL_SYS_STAT_H */
+#endif
diff -urN popt-for-windows/lib/unistd.in.h popt-for-windows-gnulib/lib/unistd.in.h
--- popt-for-windows/lib/unistd.in.h	1970-01-01 01:00:00.000000000 +0100
+++ popt-for-windows-gnulib/lib/unistd.in.h	2008-10-25 15:17:05.000000000 +0100
@@ -0,0 +1,501 @@
+/* Substitute for and wrapper around <unistd.h>.
+   Copyright (C) 2003-2008 Free Software Foundation, Inc.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software Foundation,
+   Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
+
+#ifndef _GL_UNISTD_H
+
+#if __GNUC__ >= 3
+@PRAGMA_SYSTEM_HEADER@
+#endif
+
+/* The include_next requires a split double-inclusion guard.  */
+#if @HAVE_UNISTD_H@
+# @INCLUDE_NEXT@ @NEXT_UNISTD_H@
+#endif
+
+#ifndef _GL_UNISTD_H
+#define _GL_UNISTD_H
+
+/* mingw doesn't define the SEEK_* macros in <unistd.h>.  */
+#if !(defined SEEK_CUR && defined SEEK_END && defined SEEK_SET)
+# include <stdio.h>
+#endif
+
+/* mingw fails to declare _exit in <unistd.h>.  */
+#include <stdlib.h>
+
+#if @GNULIB_WRITE@ && @REPLACE_WRITE@ && @GNULIB_UNISTD_H_SIGPIPE@
+/* Get ssize_t.  */
+# include <sys/types.h>
+#endif
+
+/* The definition of GL_LINK_WARNING is copied here.  */
+
+
+/* Declare overridden functions.  */
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+#if @GNULIB_CHOWN@
+# if @REPLACE_CHOWN@
+#  ifndef REPLACE_CHOWN
+#   define REPLACE_CHOWN 1
+#  endif
+#  if REPLACE_CHOWN
+/* Change the owner of FILE to UID (if UID is not -1) and the group of FILE
+   to GID (if GID is not -1).  Follow symbolic links.
+   Return 0 if successful, otherwise -1 and errno set.
+   See the POSIX:2001 specification
+   <http://www.opengroup.org/susv3xsh/chown.html>.  */
+#   define chown rpl_chown
+extern int chown (const char *file, uid_t uid, gid_t gid);
+#  endif
+# endif
+#elif defined GNULIB_POSIXCHECK
+# undef chown
+# define chown(f,u,g) \
+    (GL_LINK_WARNING ("chown fails to follow symlinks on some systems and " \
+                      "doesn't treat a uid or gid of -1 on some systems - " \
+                      "use gnulib module chown for portability"), \
+     chown (f, u, g))
+#endif
+
+
+#if @GNULIB_CLOSE@
+# if @REPLACE_CLOSE@
+/* Automatically included by modules that need a replacement for close.  */
+#  undef close
+#  define close rpl_close
+extern int close (int);
+# endif
+#elif @UNISTD_H_HAVE_WINSOCK2_H@
+# undef close
+# define close close_used_without_requesting_gnulib_module_close
+#elif defined GNULIB_POSIXCHECK
+# undef close
+# define close(f) \
+    (GL_LINK_WARNING ("close does not portably work on sockets - " \
+                      "use gnulib module close for portability"), \
+     close (f))
+#endif
+
+
+#if @GNULIB_DUP2@
+# if !@HAVE_DUP2@
+/* Copy the file descriptor OLDFD into file descriptor NEWFD.  Do nothing if
+   NEWFD = OLDFD, otherwise close NEWFD first if it is open.
+   Return 0 if successful, otherwise -1 and errno set.
+   See the POSIX:2001 specification
+   <http://www.opengroup.org/susv3xsh/dup2.html>.  */
+extern int dup2 (int oldfd, int newfd);
+# endif
+#elif defined GNULIB_POSIXCHECK
+# undef dup2
+# define dup2(o,n) \
+    (GL_LINK_WARNING ("dup2 is unportable - " \
+                      "use gnulib module dup2 for portability"), \
+     dup2 (o, n))
+#endif
+
+
+#if @GNULIB_ENVIRON@
+# if !@HAVE_DECL_ENVIRON@
+/* Set of environment variables and values.  An array of strings of the form
+   "VARIABLE=VALUE", terminated with a NULL.  */
+#  if defined __APPLE__ && defined __MACH__
+#   include <crt_externs.h>
+#   define environ (*_NSGetEnviron ())
+#  else
+extern char **environ;
+#  endif
+# endif
+#elif defined GNULIB_POSIXCHECK
+# undef environ
+# define environ \
+    (GL_LINK_WARNING ("environ is unportable - " \
+                      "use gnulib module environ for portability"), \
+     environ)
+#endif
+
+
+#if @GNULIB_EUIDACCESS@
+# if !@HAVE_EUIDACCESS@
+/* Like access(), except that is uses the effective user id and group id of
+   the current process.  */
+extern int euidaccess (const char *filename, int mode);
+# endif
+#elif defined GNULIB_POSIXCHECK
+# undef euidaccess
+# define euidaccess(f,m) \
+    (GL_LINK_WARNING ("euidaccess is unportable - " \
+                      "use gnulib module euidaccess for portability"), \
+     euidaccess (f, m))
+#endif
+
+
+#if @GNULIB_FCHDIR@
+# if @REPLACE_FCHDIR@
+
+/* Change the process' current working directory to the directory on which
+   the given file descriptor is open.
+   Return 0 if successful, otherwise -1 and errno set.
+   See the POSIX:2001 specification
+   <http://www.opengroup.org/susv3xsh/fchdir.html>.  */
+extern int fchdir (int /*fd*/);
+
+#  define dup rpl_dup
+extern int dup (int);
+#  define dup2 rpl_dup2
+extern int dup2 (int, int);
+
+# endif
+#elif defined GNULIB_POSIXCHECK
+# undef fchdir
+# define fchdir(f) \
+    (GL_LINK_WARNING ("fchdir is unportable - " \
+                      "use gnulib module fchdir for portability"), \
+     fchdir (f))
+#endif
+
+
+#if @GNULIB_FSYNC@
+/* Synchronize changes to a file.
+   Return 0 if successful, otherwise -1 and errno set.
+   See POSIX:2001 specification
+   <http://www.opengroup.org/susv3xsh/fsync.html>.  */
+# if !@HAVE_FSYNC@
+extern int fsync (int fd);
+# endif
+#elif defined GNULIB_POSIXCHECK
+# undef fsync
+# define fsync(fd) \
+    (GL_LINK_WARNING ("fsync is unportable - " \
+                      "use gnulib module fsync for portability"), \
+     fsync (fd))
+#endif
+
+
+#if @GNULIB_FTRUNCATE@
+# if !@HAVE_FTRUNCATE@
+/* Change the size of the file to which FD is opened to become equal to LENGTH.
+   Return 0 if successful, otherwise -1 and errno set.
+   See the POSIX:2001 specification
+   <http://www.opengroup.org/susv3xsh/ftruncate.html>.  */
+extern int ftruncate (int fd, off_t length);
+# endif
+#elif defined GNULIB_POSIXCHECK
+# undef ftruncate
+# define ftruncate(f,l) \
+    (GL_LINK_WARNING ("ftruncate is unportable - " \
+                      "use gnulib module ftruncate for portability"), \
+     ftruncate (f, l))
+#endif
+
+
+#if @GNULIB_GETCWD@
+/* Include the headers that might declare getcwd so that they will not
+   cause confusion if included after this file.  */
+# include <stdlib.h>
+# if @REPLACE_GETCWD@
+/* Get the name of the current working directory, and put it in SIZE bytes
+   of BUF.
+   Return BUF if successful, or NULL if the directory couldn't be determined
+   or SIZE was too small.
+   See the POSIX:2001 specification
+   <http://www.opengroup.org/susv3xsh/getcwd.html>.
+   Additionally, the gnulib module 'getcwd' guarantees the following GNU
+   extension: If BUF is NULL, an array is allocated with 'malloc'; the array
+   is SIZE bytes long, unless SIZE == 0, in which case it is as big as
+   necessary.  */
+#  define getcwd rpl_getcwd
+extern char * getcwd (char *buf, size_t size);
+# endif
+#elif defined GNULIB_POSIXCHECK
+# undef getcwd
+# define getcwd(b,s) \
+    (GL_LINK_WARNING ("getcwd is unportable - " \
+                      "use gnulib module getcwd for portability"), \
+     getcwd (b, s))
+#endif
+
+
+#if @GNULIB_GETDOMAINNAME@
+/* Return the NIS domain name of the machine.
+   WARNING! The NIS domain name is unrelated to the fully qualified host name
+            of the machine.  It is also unrelated to email addresses.
+   WARNING! The NIS domain name is usually the empty string or "(none)" when
+            not using NIS.
+
+   Put up to LEN bytes of the NIS domain name into NAME.
+   Null terminate it if the name is shorter than LEN.
+   If the NIS domain name is longer than LEN, set errno = EINVAL and return -1.
+   Return 0 if successful, otherwise set errno and return -1.  */
+# if !@HAVE_GETDOMAINNAME@
+extern int getdomainname(char *name, size_t len);
+# endif
+#elif defined GNULIB_POSIXCHECK
+# undef getdomainname
+# define getdomainname(n,l) \
+    (GL_LINK_WARNING ("getdomainname is unportable - " \
+                      "use gnulib module getdomainname for portability"), \
+     getdomainname (n, l))
+#endif
+
+
+#if @GNULIB_GETDTABLESIZE@
+# if !@HAVE_GETDTABLESIZE@
+/* Return the maximum number of file descriptors in the current process.  */
+extern int getdtablesize (void);
+# endif
+#elif defined GNULIB_POSIXCHECK
+# undef getdtablesize
+# define getdtablesize() \
+    (GL_LINK_WARNING ("getdtablesize is unportable - " \
+                      "use gnulib module getdtablesize for portability"), \
+     getdtablesize ())
+#endif
+
+
+#if @GNULIB_GETHOSTNAME@
+/* Return the standard host name of the machine.
+   WARNING! The host name may or may not be fully qualified.
+
+   Put up to LEN bytes of the host name into NAME.
+   Null terminate it if the name is shorter than LEN.
+   If the host name is longer than LEN, set errno = EINVAL and return -1.
+   Return 0 if successful, otherwise set errno and return -1.  */
+# if !@HAVE_GETHOSTNAME@
+extern int gethostname(char *name, size_t len);
+# endif
+#elif defined GNULIB_POSIXCHECK
+# undef gethostname
+# define gethostname(n,l) \
+    (GL_LINK_WARNING ("gethostname is unportable - " \
+                      "use gnulib module gethostname for portability"), \
+     gethostname (n, l))
+#endif
+
+
+#if @GNULIB_GETLOGIN_R@
+/* Copies the user's login name to NAME.
+   The array pointed to by NAME has room for SIZE bytes.
+
+   Returns 0 if successful.  Upon error, an error number is returned, or -1 in
+   the case that the login name cannot be found but no specific error is
+   provided (this case is hopefully rare but is left open by the POSIX spec).
+
+   See <http://www.opengroup.org/susv3xsh/getlogin.html>.
+ */
+# if !@HAVE_DECL_GETLOGIN_R@
+#  include <stddef.h>
+extern int getlogin_r (char *name, size_t size);
+# endif
+#elif defined GNULIB_POSIXCHECK
+# undef getlogin_r
+# define getlogin_r(n,s) \
+    (GL_LINK_WARNING ("getlogin_r is unportable - " \
+                      "use gnulib module getlogin_r for portability"), \
+     getlogin_r (n, s))
+#endif
+
+
+#if @GNULIB_GETPAGESIZE@
+# if @REPLACE_GETPAGESIZE@
+#  define getpagesize rpl_getpagesize
+extern int getpagesize (void);
+# elif !@HAVE_GETPAGESIZE@
+/* This is for POSIX systems.  */
+#  if !defined getpagesize && defined _SC_PAGESIZE
+#   if ! (defined __VMS && __VMS_VER < 70000000)
+#    define getpagesize() sysconf (_SC_PAGESIZE)
+#   endif
+#  endif
+/* This is for older VMS.  */
+#  if !defined getpagesize && defined __VMS
+#   ifdef __ALPHA
+#    define getpagesize() 8192
+#   else
+#    define getpagesize() 512
+#   endif
+#  endif
+/* This is for BeOS.  */
+#  if !defined getpagesize && @HAVE_OS_H@
+#   include <OS.h>
+#   if defined B_PAGE_SIZE
+#    define getpagesize() B_PAGE_SIZE
+#   endif
+#  endif
+/* This is for AmigaOS4.0.  */
+#  if !defined getpagesize && defined __amigaos4__
+#   define getpagesize() 2048
+#  endif
+/* This is for older Unix systems.  */
+#  if !defined getpagesize && @HAVE_SYS_PARAM_H@
+#   include <sys/param.h>
+#   ifdef EXEC_PAGESIZE
+#    define getpagesize() EXEC_PAGESIZE
+#   else
+#    ifdef NBPG
+#     ifndef CLSIZE
+#      define CLSIZE 1
+#     endif
+#     define getpagesize() (NBPG * CLSIZE)
+#    else
+#     ifdef NBPC
+#      define getpagesize() NBPC
+#     endif
+#    endif
+#   endif
+#  endif
+# endif
+#elif defined GNULIB_POSIXCHECK
+# undef getpagesize
+# define getpagesize() \
+    (GL_LINK_WARNING ("getpagesize is unportable - " \
+                      "use gnulib module getpagesize for portability"), \
+     getpagesize ())
+#endif
+
+
+#if @GNULIB_GETUSERSHELL@
+# if !@HAVE_GETUSERSHELL@
+/* Return the next valid login shell on the system, or NULL when the end of
+   the list has been reached.  */
+extern char *getusershell (void);
+/* Rewind to pointer that is advanced at each getusershell() call.  */
+extern void setusershell (void);
+/* Free the pointer that is advanced at each getusershell() call and
+   associated resources.  */
+extern void endusershell (void);
+# endif
+#elif defined GNULIB_POSIXCHECK
+# undef getusershell
+# define getusershell() \
+    (GL_LINK_WARNING ("getusershell is unportable - " \
+                      "use gnulib module getusershell for portability"), \
+     getusershell ())
+# undef setusershell
+# define setusershell() \
+    (GL_LINK_WARNING ("setusershell is unportable - " \
+                      "use gnulib module getusershell for portability"), \
+     setusershell ())
+# undef endusershell
+# define endusershell() \
+    (GL_LINK_WARNING ("endusershell is unportable - " \
+                      "use gnulib module getusershell for portability"), \
+     endusershell ())
+#endif
+
+
+#if @GNULIB_LCHOWN@
+# if @REPLACE_LCHOWN@
+/* Change the owner of FILE to UID (if UID is not -1) and the group of FILE
+   to GID (if GID is not -1).  Do not follow symbolic links.
+   Return 0 if successful, otherwise -1 and errno set.
+   See the POSIX:2001 specification
+   <http://www.opengroup.org/susv3xsh/lchown.html>.  */
+#  define lchown rpl_lchown
+extern int lchown (char const *file, uid_t owner, gid_t group);
+# endif
+#elif defined GNULIB_POSIXCHECK
+# undef lchown
+# define lchown(f,u,g) \
+    (GL_LINK_WARNING ("lchown is unportable to pre-POSIX.1-2001 " \
+                      "systems - use gnulib module lchown for portability"), \
+     lchown (f, u, g))
+#endif
+
+
+#if @GNULIB_LSEEK@
+# if @REPLACE_LSEEK@
+/* Set the offset of FD relative to SEEK_SET, SEEK_CUR, or SEEK_END.
+   Return the new offset if successful, otherwise -1 and errno set.
+   See the POSIX:2001 specification
+   <http://www.opengroup.org/susv3xsh/lseek.html>.  */
+#  define lseek rpl_lseek
+   extern off_t lseek (int fd, off_t offset, int whence);
+# endif
+#elif defined GNULIB_POSIXCHECK
+# undef lseek
+# define lseek(f,o,w) \
+    (GL_LINK_WARNING ("lseek does not fail with ESPIPE on pipes on some " \
+                      "systems - use gnulib module lseek for portability"), \
+     lseek (f, o, w))
+#endif
+
+
+#if @GNULIB_READLINK@
+/* Read the contents of the symbolic link FILE and place the first BUFSIZE
+   bytes of it into BUF.  Return the number of bytes placed into BUF if
+   successful, otherwise -1 and errno set.
+   See the POSIX:2001 specification
+   <http://www.opengroup.org/susv3xsh/readlink.html>.  */
+# if !@HAVE_READLINK@
+#  include <stddef.h>
+extern int readlink (const char *file, char *buf, size_t bufsize);
+# endif
+#elif defined GNULIB_POSIXCHECK
+# undef readlink
+# define readlink(f,b,s) \
+    (GL_LINK_WARNING ("readlink is unportable - " \
+                      "use gnulib module readlink for portability"), \
+     readlink (f, b, s))
+#endif
+
+
+#if @GNULIB_SLEEP@
+/* Pause the execution of the current thread for N seconds.
+   Returns the number of seconds left to sleep.
+   See the POSIX:2001 specification
+   <http://www.opengroup.org/susv3xsh/sleep.html>.  */
+# if !@HAVE_SLEEP@
+extern unsigned int sleep (unsigned int n);
+# endif
+#elif defined GNULIB_POSIXCHECK
+# undef sleep
+# define sleep(n) \
+    (GL_LINK_WARNING ("sleep is unportable - " \
+                      "use gnulib module sleep for portability"), \
+     sleep (n))
+#endif
+
+
+#if @GNULIB_WRITE@ && @REPLACE_WRITE@ && @GNULIB_UNISTD_H_SIGPIPE@
+/* Write up to COUNT bytes starting at BUF to file descriptor FD.
+   See the POSIX:2001 specification
+   <http://www.opengroup.org/susv3xsh/write.html>.  */
+# undef write
+# define write rpl_write
+extern ssize_t write (int fd, const void *buf, size_t count);
+#endif
+
+
+#ifdef FCHDIR_REPLACEMENT
+/* gnulib internal function.  */
+extern void _gl_unregister_fd (int fd);
+#endif
+
+
+#ifdef __cplusplus
+}
+#endif
+
+
+#endif /* _GL_UNISTD_H */
+#endif /* _GL_UNISTD_H */
diff -urN popt-for-windows/lib/wchar.in.h popt-for-windows-gnulib/lib/wchar.in.h
--- popt-for-windows/lib/wchar.in.h	1970-01-01 01:00:00.000000000 +0100
+++ popt-for-windows-gnulib/lib/wchar.in.h	2008-10-25 15:17:05.000000000 +0100
@@ -0,0 +1,101 @@
+/* A substitute for ISO C99 <wchar.h>, for platforms that have issues.
+
+   Copyright (C) 2007-2008 Free Software Foundation, Inc.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software Foundation,
+   Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
+
+/* Written by Eric Blake.  */
+
+/*
+ * ISO C 99 <wchar.h> for platforms that have issues.
+ * <http://www.opengroup.org/susv3xbd/wchar.h.html>
+ *
+ * For now, this just ensures proper prerequisite inclusion order and
+ * the declaration of wcwidth().
+ */
+
+#if __GNUC__ >= 3
+@PRAGMA_SYSTEM_HEADER@
+#endif
+
+#ifdef __need_mbstate_t
+/* Special invocation convention inside uClibc header files.  */
+
+#@INCLUDE_NEXT@ @NEXT_WCHAR_H@
+
+#else
+/* Normal invocation convention.  */
+
+#ifndef _GL_WCHAR_H
+
+/* Tru64 with Desktop Toolkit C has a bug: <stdio.h> must be included before
+   <wchar.h>.
+   BSD/OS 4.0.1 has a bug: <stddef.h>, <stdio.h> and <time.h> must be
+   included before <wchar.h>.  */
+#include <stddef.h>
+#include <stdio.h>
+#include <time.h>
+
+/* Include the original <wchar.h> if it exists.
+   Some builds of uClibc lack it.  */
+/* The include_next requires a split double-inclusion guard.  */
+#if @HAVE_WCHAR_H@
+# @INCLUDE_NEXT@ @NEXT_WCHAR_H@
+#endif
+
+#ifndef _GL_WCHAR_H
+#define _GL_WCHAR_H
+
+/* The definition of GL_LINK_WARNING is copied here.  */
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+/* Define wint_t.  (Also done in wctype.in.h.)  */
+#if !@HAVE_WINT_T@ && !defined wint_t
+# define wint_t int
+#endif
+
+
+/* Return the number of screen columns needed for WC.  */
+#if @GNULIB_WCWIDTH@
+# if @REPLACE_WCWIDTH@
+#  undef wcwidth
+#  define wcwidth rpl_wcwidth
+extern int wcwidth (wchar_t);
+# else
+#  if !defined wcwidth && !@HAVE_DECL_WCWIDTH@
+/* wcwidth exists but is not declared.  */
+extern int wcwidth (int /* actually wchar_t */);
+#  endif
+# endif
+#elif defined GNULIB_POSIXCHECK
+# undef wcwidth
+# define wcwidth(w) \
+    (GL_LINK_WARNING ("wcwidth is unportable - " \
+                      "use gnulib module wcwidth for portability"), \
+     wcwidth (w))
+#endif
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* _GL_WCHAR_H */
+#endif /* _GL_WCHAR_H */
+#endif
diff -urN popt-for-windows/lib/wctype.in.h popt-for-windows-gnulib/lib/wctype.in.h
--- popt-for-windows/lib/wctype.in.h	1970-01-01 01:00:00.000000000 +0100
+++ popt-for-windows-gnulib/lib/wctype.in.h	2008-10-25 15:17:05.000000000 +0100
@@ -0,0 +1,181 @@
+/* A substitute for ISO C99 <wctype.h>, for platforms that lack it.
+
+   Copyright (C) 2006-2008 Free Software Foundation, Inc.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software Foundation,
+   Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
+
+/* Written by Bruno Haible and Paul Eggert.  */
+
+/*
+ * ISO C 99 <wctype.h> for platforms that lack it.
+ * <http://www.opengroup.org/susv3xbd/wctype.h.html>
+ *
+ * iswctype, towctrans, towlower, towupper, wctrans, wctype,
+ * wctrans_t, and wctype_t are not yet implemented.
+ */
+
+#ifndef _GL_WCTYPE_H
+
+#if __GNUC__ >= 3
+@PRAGMA_SYSTEM_HEADER@
+#endif
+
+#if @HAVE_WINT_T@
+/* Solaris 2.5 has a bug: <wchar.h> must be included before <wctype.h>.
+   Tru64 with Desktop Toolkit C has a bug: <stdio.h> must be included before
+   <wchar.h>.
+   BSD/OS 4.0.1 has a bug: <stddef.h>, <stdio.h> and <time.h> must be
+   included before <wchar.h>.  */
+# include <stddef.h>
+# include <stdio.h>
+# include <time.h>
+# include <wchar.h>
+#endif
+
+/* Include the original <wctype.h> if it exists.
+   BeOS 5 has the functions but no <wctype.h>.  */
+/* The include_next requires a split double-inclusion guard.  */
+#if @HAVE_WCTYPE_H@
+# @INCLUDE_NEXT@ @NEXT_WCTYPE_H@
+#endif
+
+#ifndef _GL_WCTYPE_H
+#define _GL_WCTYPE_H
+
+/* Define wint_t.  (Also done in wchar.in.h.)  */
+#if !@HAVE_WINT_T@ && !defined wint_t
+# define wint_t int
+#endif
+
+/* FreeBSD 4.4 to 4.11 has <wctype.h> but lacks the functions.
+   Linux libc5 has <wctype.h> and the functions but they are broken.
+   Assume all 12 functions are implemented the same way, or not at all.  */
+#if ! @HAVE_ISWCNTRL@ || @REPLACE_ISWCNTRL@
+
+/* IRIX 5.3 has macros but no functions, its isw* macros refer to an
+   undefined variable _ctmp_ and to <ctype.h> macros like _P, and they
+   refer to system functions like _iswctype that are not in the
+   standard C library.  Rather than try to get ancient buggy
+   implementations like this to work, just disable them.  */
+#  undef iswalnum
+#  undef iswalpha
+#  undef iswblank
+#  undef iswcntrl
+#  undef iswdigit
+#  undef iswgraph
+#  undef iswlower
+#  undef iswprint
+#  undef iswpunct
+#  undef iswspace
+#  undef iswupper
+#  undef iswxdigit
+
+/* Linux libc5 has <wctype.h> and the functions but they are broken.  */
+#  if @REPLACE_ISWCNTRL@
+#   define iswalnum rpl_iswalnum
+#   define iswalpha rpl_iswalpha
+#   define iswblank rpl_iswblank
+#   define iswcntrl rpl_iswcntrl
+#   define iswdigit rpl_iswdigit
+#   define iswgraph rpl_iswgraph
+#   define iswlower rpl_iswlower
+#   define iswprint rpl_iswprint
+#   define iswpunct rpl_iswpunct
+#   define iswspace rpl_iswspace
+#   define iswupper rpl_iswupper
+#   define iswxdigit rpl_iswxdigit
+#  endif
+
+static inline int
+iswalnum (wint_t wc)
+{
+  return ((wc >= '0' && wc <= '9')
+	  || ((wc & ~0x20) >= 'A' && (wc & ~0x20) <= 'Z'));
+}
+
+static inline int
+iswalpha (wint_t wc)
+{
+  return (wc & ~0x20) >= 'A' && (wc & ~0x20) <= 'Z';
+}
+
+static inline int
+iswblank (wint_t wc)
+{
+  return wc == ' ' || wc == '\t';
+}
+
+static inline int
+iswcntrl (wint_t wc)
+{
+  return (wc & ~0x1f) == 0 || wc == 0x7f;
+}
+
+static inline int
+iswdigit (wint_t wc)
+{
+  return wc >= '0' && wc <= '9';
+}
+
+static inline int
+iswgraph (wint_t wc)
+{
+  return wc >= '!' && wc <= '~';
+}
+
+static inline int
+iswlower (wint_t wc)
+{
+  return wc >= 'a' && wc <= 'z';
+}
+
+static inline int
+iswprint (wint_t wc)
+{
+  return wc >= ' ' && wc <= '~';
+}
+
+static inline int
+iswpunct (wint_t wc)
+{
+  return (wc >= '!' && wc <= '~'
+	  && !((wc >= '0' && wc <= '9')
+	       || ((wc & ~0x20) >= 'A' && (wc & ~0x20) <= 'Z')));
+}
+
+static inline int
+iswspace (wint_t wc)
+{
+  return (wc == ' ' || wc == '\t'
+	  || wc == '\n' || wc == '\v' || wc == '\f' || wc == '\r');
+}
+
+static inline int
+iswupper (wint_t wc)
+{
+  return wc >= 'A' && wc <= 'Z';
+}
+
+static inline int
+iswxdigit (wint_t wc)
+{
+  return ((wc >= '0' && wc <= '9')
+	  || ((wc & ~0x20) >= 'A' && (wc & ~0x20) <= 'F'));
+}
+
+# endif /* ! HAVE_ISWCNTRL */
+
+#endif /* _GL_WCTYPE_H */
+#endif /* _GL_WCTYPE_H */
diff -urN popt-for-windows/link-warning.h popt-for-windows-gnulib/link-warning.h
--- popt-for-windows/link-warning.h	1970-01-01 01:00:00.000000000 +0100
+++ popt-for-windows-gnulib/link-warning.h	2008-10-25 15:17:05.000000000 +0100
@@ -0,0 +1,28 @@
+/* GL_LINK_WARNING("literal string") arranges to emit the literal string as
+   a linker warning on most glibc systems.
+   We use a linker warning rather than a preprocessor warning, because
+   #warning cannot be used inside macros.  */
+#ifndef GL_LINK_WARNING
+  /* This works on platforms with GNU ld and ELF object format.
+     Testing __GLIBC__ is sufficient for asserting that GNU ld is in use.
+     Testing __ELF__ guarantees the ELF object format.
+     Testing __GNUC__ is necessary for the compound expression syntax.  */
+# if defined __GLIBC__ && defined __ELF__ && defined __GNUC__
+#  define GL_LINK_WARNING(message) \
+     GL_LINK_WARNING1 (__FILE__, __LINE__, message)
+#  define GL_LINK_WARNING1(file, line, message) \
+     GL_LINK_WARNING2 (file, line, message)  /* macroexpand file and line */
+#  define GL_LINK_WARNING2(file, line, message) \
+     GL_LINK_WARNING3 (file ":" #line ": warning: " message)
+#  define GL_LINK_WARNING3(message) \
+     ({ static const char warning[sizeof (message)]		\
+          __attribute__ ((__unused__,				\
+                          __section__ (".gnu.warning"),		\
+                          __aligned__ (1)))			\
+          = message "\n";					\
+        (void)0;						\
+     })
+# else
+#  define GL_LINK_WARNING(message) ((void) 0)
+# endif
+#endif
diff -urN popt-for-windows/m4/alloca.m4 popt-for-windows-gnulib/m4/alloca.m4
--- popt-for-windows/m4/alloca.m4	1970-01-01 01:00:00.000000000 +0100
+++ popt-for-windows-gnulib/m4/alloca.m4	2008-10-25 15:17:05.000000000 +0100
@@ -0,0 +1,46 @@
+# alloca.m4 serial 8
+dnl Copyright (C) 2002-2004, 2006, 2007 Free Software Foundation, Inc.
+dnl This file is free software; the Free Software Foundation
+dnl gives unlimited permission to copy and/or distribute it,
+dnl with or without modifications, as long as this notice is preserved.
+
+AC_DEFUN([gl_FUNC_ALLOCA],
+[
+  dnl Work around a bug of AC_EGREP_CPP in autoconf-2.57.
+  AC_REQUIRE([AC_PROG_CPP])
+  AC_REQUIRE([AC_PROG_EGREP])
+
+  AC_REQUIRE([AC_FUNC_ALLOCA])
+  if test $ac_cv_func_alloca_works = no; then
+    gl_PREREQ_ALLOCA
+  fi
+
+  # Define an additional variable used in the Makefile substitution.
+  if test $ac_cv_working_alloca_h = yes; then
+    AC_CACHE_CHECK([for alloca as a compiler built-in], [gl_cv_rpl_alloca], [
+      AC_EGREP_CPP([Need own alloca], [
+#if defined __GNUC__ || defined _AIX || defined _MSC_VER
+        Need own alloca
+#endif
+        ], [gl_cv_rpl_alloca=yes], [gl_cv_rpl_alloca=no])
+    ])
+    if test $gl_cv_rpl_alloca = yes; then
+      dnl OK, alloca can be implemented through a compiler built-in.
+      AC_DEFINE([HAVE_ALLOCA], 1,
+        [Define to 1 if you have 'alloca' after including <alloca.h>,
+         a header that may be supplied by this distribution.])
+      ALLOCA_H=alloca.h
+    else
+      dnl alloca exists as a library function, i.e. it is slow and probably
+      dnl a memory leak. Don't define HAVE_ALLOCA in this case.
+      ALLOCA_H=
+    fi
+  else
+    ALLOCA_H=alloca.h
+  fi
+  AC_SUBST([ALLOCA_H])
+])
+
+# Prerequisites of lib/alloca.c.
+# STACK_DIRECTION is already handled by AC_FUNC_ALLOCA.
+AC_DEFUN([gl_PREREQ_ALLOCA], [:])
diff -urN popt-for-windows/m4/.cvsignore popt-for-windows-gnulib/m4/.cvsignore
--- popt-for-windows/m4/.cvsignore	2008-02-11 17:06:13.000000000 +0000
+++ popt-for-windows-gnulib/m4/.cvsignore	2008-10-25 15:17:06.000000000 +0100
@@ -1 +1,26 @@
 *.m4
+alloca.m4
+d-type.m4
+dirent_h.m4
+dirfd.m4
+extensions.m4
+fnmatch.m4
+getlogin_r.m4
+glob.m4
+gnulib-common.m4
+gnulib-comp.m4
+gnulib-tool.m4
+include_next.m4
+malloc.m4
+mbstate_t.m4
+mempcpy.m4
+onceonly.m4
+stdbool.m4
+stdlib_h.m4
+strdup.m4
+string_h.m4
+sys_stat_h.m4
+unistd_h.m4
+wchar.m4
+wctype.m4
+wint_t.m4
diff -urN popt-for-windows/m4/.cvsignore~ popt-for-windows-gnulib/m4/.cvsignore~
--- popt-for-windows/m4/.cvsignore~	1970-01-01 01:00:00.000000000 +0100
+++ popt-for-windows-gnulib/m4/.cvsignore~	2008-02-11 17:06:13.000000000 +0000
@@ -0,0 +1 @@
+*.m4
diff -urN popt-for-windows/m4/dirent_h.m4 popt-for-windows-gnulib/m4/dirent_h.m4
--- popt-for-windows/m4/dirent_h.m4	1970-01-01 01:00:00.000000000 +0100
+++ popt-for-windows-gnulib/m4/dirent_h.m4	2008-10-25 15:17:05.000000000 +0100
@@ -0,0 +1,39 @@
+# dirent_h.m4 serial 2
+dnl Copyright (C) 2008 Free Software Foundation, Inc.
+dnl This file is free software; the Free Software Foundation
+dnl gives unlimited permission to copy and/or distribute it,
+dnl with or without modifications, as long as this notice is preserved.
+
+dnl Written by Bruno Haible.
+
+AC_DEFUN([gl_DIRENT_H],
+[
+  dnl Use AC_REQUIRE here, so that the default behavior below is expanded
+  dnl once only, before all statements that occur in other macros.
+  AC_REQUIRE([gl_DIRENT_H_DEFAULTS])
+
+  gl_CHECK_NEXT_HEADERS([dirent.h])
+])
+
+dnl Unconditionally enables the replacement of <dirent.h>.
+AC_DEFUN([gl_REPLACE_DIRENT_H],
+[
+  AC_REQUIRE([gl_DIRENT_H_DEFAULTS])
+  DIRENT_H='dirent.h'
+])
+
+AC_DEFUN([gl_DIRENT_MODULE_INDICATOR],
+[
+  dnl Use AC_REQUIRE here, so that the default settings are expanded once only.
+  AC_REQUIRE([gl_DIRENT_H_DEFAULTS])
+  GNULIB_[]m4_translit([$1],[abcdefghijklmnopqrstuvwxyz./-],[ABCDEFGHIJKLMNOPQRSTUVWXYZ___])=1
+])
+
+AC_DEFUN([gl_DIRENT_H_DEFAULTS],
+[
+  AC_REQUIRE([gl_UNISTD_H_DEFAULTS]) dnl for REPLACE_FCHDIR
+  GNULIB_DIRFD=0;    AC_SUBST([GNULIB_DIRFD])
+  dnl Assume proper GNU behavior unless another module says otherwise.
+  HAVE_DECL_DIRFD=1; AC_SUBST([HAVE_DECL_DIRFD])
+  DIRENT_H='';       AC_SUBST([DIRENT_H])
+])
diff -urN popt-for-windows/m4/dirfd.m4 popt-for-windows-gnulib/m4/dirfd.m4
--- popt-for-windows/m4/dirfd.m4	1970-01-01 01:00:00.000000000 +0100
+++ popt-for-windows-gnulib/m4/dirfd.m4	2008-10-25 15:17:05.000000000 +0100
@@ -0,0 +1,84 @@
+#serial 15   -*- Autoconf -*-
+
+dnl Find out how to get the file descriptor associated with an open DIR*.
+
+# Copyright (C) 2001, 2002, 2003, 2004, 2005, 2006, 2008 Free Software
+# Foundation, Inc.
+# This file is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+dnl From Jim Meyering
+
+AC_DEFUN([gl_FUNC_DIRFD],
+[
+  AC_REQUIRE([gl_DIRENT_H_DEFAULTS])
+  gl_REPLACE_DIRENT_H
+
+  dnl Persuade glibc <dirent.h> to declare dirfd().
+  AC_REQUIRE([AC_USE_SYSTEM_EXTENSIONS])
+
+  dnl Work around a bug of AC_EGREP_CPP in autoconf-2.57.
+  AC_REQUIRE([AC_PROG_CPP])
+  AC_REQUIRE([AC_PROG_EGREP])
+
+  AC_CHECK_FUNCS(dirfd)
+  AC_CHECK_DECLS([dirfd], , ,
+    [#include <sys/types.h>
+     #include <dirent.h>])
+  if test $ac_cv_have_decl_dirfd = no; then
+    HAVE_DECL_DIRFD=0
+  fi
+
+  AC_CACHE_CHECK([whether dirfd is a macro],
+    gl_cv_func_dirfd_macro,
+    [AC_EGREP_CPP([dirent_header_defines_dirfd], [
+#include <sys/types.h>
+#include <dirent.h>
+#ifdef dirfd
+ dirent_header_defines_dirfd
+#endif],
+       gl_cv_func_dirfd_macro=yes,
+       gl_cv_func_dirfd_macro=no)])
+
+  # Use the replacement only if we have no function, macro,
+  # or declaration with that name.
+  if test $ac_cv_func_dirfd,$ac_cv_have_decl_dirfd,$gl_cv_func_dirfd_macro \
+      = no,no,no; then
+    AC_REPLACE_FUNCS([dirfd])
+    AC_CACHE_CHECK(
+	      [how to get the file descriptor associated with an open DIR*],
+		   gl_cv_sys_dir_fd_member_name,
+      [
+	dirfd_save_CFLAGS=$CFLAGS
+	for ac_expr in d_fd dd_fd; do
+
+	  CFLAGS="$CFLAGS -DDIR_FD_MEMBER_NAME=$ac_expr"
+	  AC_TRY_COMPILE(
+	    [#include <sys/types.h>
+	     #include <dirent.h>],
+	    [DIR *dir_p = opendir("."); (void) dir_p->DIR_FD_MEMBER_NAME;],
+	    dir_fd_found=yes
+	  )
+	  CFLAGS=$dirfd_save_CFLAGS
+	  test "$dir_fd_found" = yes && break
+	done
+	test "$dir_fd_found" = yes || ac_expr=no_such_member
+
+	gl_cv_sys_dir_fd_member_name=$ac_expr
+      ]
+    )
+    if test $gl_cv_sys_dir_fd_member_name != no_such_member; then
+      AC_DEFINE_UNQUOTED(DIR_FD_MEMBER_NAME,
+	$gl_cv_sys_dir_fd_member_name,
+	[the name of the file descriptor member of DIR])
+    fi
+    AH_VERBATIM(DIR_TO_FD,
+		[#ifdef DIR_FD_MEMBER_NAME
+# define DIR_TO_FD(Dir_p) ((Dir_p)->DIR_FD_MEMBER_NAME)
+#else
+# define DIR_TO_FD(Dir_p) -1
+#endif
+])
+  fi
+])
diff -urN popt-for-windows/m4/d-type.m4 popt-for-windows-gnulib/m4/d-type.m4
--- popt-for-windows/m4/d-type.m4	1970-01-01 01:00:00.000000000 +0100
+++ popt-for-windows-gnulib/m4/d-type.m4	2008-10-25 15:17:05.000000000 +0100
@@ -0,0 +1,35 @@
+#serial 9
+
+dnl From Jim Meyering.
+dnl
+dnl Check whether struct dirent has a member named d_type.
+dnl
+
+# Copyright (C) 1997, 1999, 2000, 2001, 2002, 2003, 2004, 2006 Free Software
+# Foundation, Inc.
+#
+# This file is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+AC_DEFUN([gl_CHECK_TYPE_STRUCT_DIRENT_D_TYPE],
+  [AC_CACHE_CHECK([for d_type member in directory struct],
+		  gl_cv_struct_dirent_d_type,
+     [AC_TRY_LINK(dnl
+       [
+#include <sys/types.h>
+#include <dirent.h>
+       ],
+       [struct dirent dp; dp.d_type = 0;],
+
+       gl_cv_struct_dirent_d_type=yes,
+       gl_cv_struct_dirent_d_type=no)
+     ]
+   )
+   if test $gl_cv_struct_dirent_d_type = yes; then
+     AC_DEFINE(HAVE_STRUCT_DIRENT_D_TYPE, 1,
+       [Define if there is a member named d_type in the struct describing
+        directory headers.])
+   fi
+  ]
+)
diff -urN popt-for-windows/m4/extensions.m4 popt-for-windows-gnulib/m4/extensions.m4
--- popt-for-windows/m4/extensions.m4	1970-01-01 01:00:00.000000000 +0100
+++ popt-for-windows-gnulib/m4/extensions.m4	2008-10-25 15:17:05.000000000 +0100
@@ -0,0 +1,82 @@
+# serial 5  -*- Autoconf -*-
+# Enable extensions on systems that normally disable them.
+
+# Copyright (C) 2003, 2006-2008 Free Software Foundation, Inc.
+# This file is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# This definition of AC_USE_SYSTEM_EXTENSIONS is stolen from CVS
+# Autoconf.  Perhaps we can remove this once we can assume Autoconf
+# 2.62 or later everywhere, but since CVS Autoconf mutates rapidly
+# enough in this area it's likely we'll need to redefine
+# AC_USE_SYSTEM_EXTENSIONS for quite some time.
+
+# AC_USE_SYSTEM_EXTENSIONS
+# ------------------------
+# Enable extensions on systems that normally disable them,
+# typically due to standards-conformance issues.
+# Remember that #undef in AH_VERBATIM gets replaced with #define by
+# AC_DEFINE.  The goal here is to define all known feature-enabling
+# macros, then, if reports of conflicts are made, disable macros that
+# cause problems on some platforms (such as __EXTENSIONS__).
+AC_DEFUN([AC_USE_SYSTEM_EXTENSIONS],
+[AC_BEFORE([$0], [AC_COMPILE_IFELSE])dnl
+AC_BEFORE([$0], [AC_RUN_IFELSE])dnl
+
+  AC_CHECK_HEADER([minix/config.h], [MINIX=yes], [MINIX=])
+  if test "$MINIX" = yes; then
+    AC_DEFINE([_POSIX_SOURCE], [1],
+      [Define to 1 if you need to in order for `stat' and other
+       things to work.])
+    AC_DEFINE([_POSIX_1_SOURCE], [2],
+      [Define to 2 if the system does not provide POSIX.1 features
+       except with this defined.])
+    AC_DEFINE([_MINIX], [1],
+      [Define to 1 if on MINIX.])
+  fi
+
+  AH_VERBATIM([__EXTENSIONS__],
+[/* Enable extensions on AIX 3, Interix.  */
+#ifndef _ALL_SOURCE
+# undef _ALL_SOURCE
+#endif
+/* Enable GNU extensions on systems that have them.  */
+#ifndef _GNU_SOURCE
+# undef _GNU_SOURCE
+#endif
+/* Enable threading extensions on Solaris.  */
+#ifndef _POSIX_PTHREAD_SEMANTICS
+# undef _POSIX_PTHREAD_SEMANTICS
+#endif
+/* Enable extensions on HP NonStop.  */
+#ifndef _TANDEM_SOURCE
+# undef _TANDEM_SOURCE
+#endif
+/* Enable general extensions on Solaris.  */
+#ifndef __EXTENSIONS__
+# undef __EXTENSIONS__
+#endif
+])
+  AC_CACHE_CHECK([whether it is safe to define __EXTENSIONS__],
+    [ac_cv_safe_to_define___extensions__],
+    [AC_COMPILE_IFELSE(
+       [AC_LANG_PROGRAM([[
+#	  define __EXTENSIONS__ 1
+	  ]AC_INCLUDES_DEFAULT])],
+       [ac_cv_safe_to_define___extensions__=yes],
+       [ac_cv_safe_to_define___extensions__=no])])
+  test $ac_cv_safe_to_define___extensions__ = yes &&
+    AC_DEFINE([__EXTENSIONS__])
+  AC_DEFINE([_ALL_SOURCE])
+  AC_DEFINE([_GNU_SOURCE])
+  AC_DEFINE([_POSIX_PTHREAD_SEMANTICS])
+  AC_DEFINE([_TANDEM_SOURCE])
+])# AC_USE_SYSTEM_EXTENSIONS
+
+# gl_USE_SYSTEM_EXTENSIONS
+# ------------------------
+# Enable extensions on systems that normally disable them,
+# typically due to standards-conformance issues.
+AC_DEFUN([gl_USE_SYSTEM_EXTENSIONS],
+  [AC_REQUIRE([AC_USE_SYSTEM_EXTENSIONS])])
diff -urN popt-for-windows/m4/fnmatch.m4 popt-for-windows-gnulib/m4/fnmatch.m4
--- popt-for-windows/m4/fnmatch.m4	1970-01-01 01:00:00.000000000 +0100
+++ popt-for-windows-gnulib/m4/fnmatch.m4	2008-10-25 15:17:05.000000000 +0100
@@ -0,0 +1,127 @@
+# Check for fnmatch - serial 2.
+
+# Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007 Free Software
+# Foundation, Inc.
+# This file is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# Autoconf defines AC_FUNC_FNMATCH, but that is obsolescent.
+# New applications should use the macros below instead.
+
+# _AC_FUNC_FNMATCH_IF(STANDARD = GNU | POSIX, CACHE_VAR, IF-TRUE, IF-FALSE)
+# -------------------------------------------------------------------------
+# If a STANDARD compliant fnmatch is found, run IF-TRUE, otherwise
+# IF-FALSE.  Use CACHE_VAR.
+AC_DEFUN([_AC_FUNC_FNMATCH_IF],
+[AC_CACHE_CHECK(
+   [for working $1 fnmatch],
+   [$2],
+  [dnl Some versions of Solaris, SCO, and the GNU C Library
+   dnl have a broken or incompatible fnmatch.
+   dnl So we run a test program.  If we are cross-compiling, take no chance.
+   dnl Thanks to John Oleynick, Franois Pinard, and Paul Eggert for this test.
+   AC_RUN_IFELSE(
+      [AC_LANG_PROGRAM(
+	 [[#include <fnmatch.h>
+	   static int
+	   y (char const *pattern, char const *string, int flags)
+	   {
+	     return fnmatch (pattern, string, flags) == 0;
+	   }
+	   static int
+	   n (char const *pattern, char const *string, int flags)
+	   {
+	     return fnmatch (pattern, string, flags) == FNM_NOMATCH;
+	   }
+	 ]],
+	 [[char const *Apat = 'A' < '\\\\' ? "[A-\\\\\\\\]" : "[\\\\\\\\-A]";
+	   char const *apat = 'a' < '\\\\' ? "[a-\\\\\\\\]" : "[\\\\\\\\-a]";
+	   static char const A_1[] = { 'A' - 1, 0 };
+	   static char const A01[] = { 'A' + 1, 0 };
+	   static char const a_1[] = { 'a' - 1, 0 };
+	   static char const a01[] = { 'a' + 1, 0 };
+	   static char const bs_1[] = { '\\\\' - 1, 0 };
+	   static char const bs01[] = { '\\\\' + 1, 0 };
+	   return
+	    !(n ("a*", "", 0)
+	      && y ("a*", "abc", 0)
+	      && n ("d*/*1", "d/s/1", FNM_PATHNAME)
+	      && y ("a\\\\bc", "abc", 0)
+	      && n ("a\\\\bc", "abc", FNM_NOESCAPE)
+	      && y ("*x", ".x", 0)
+	      && n ("*x", ".x", FNM_PERIOD)
+	      && y (Apat, "\\\\", 0) && y (Apat, "A", 0)
+	      && y (apat, "\\\\", 0) && y (apat, "a", 0)
+	      && n (Apat, A_1, 0) == ('A' < '\\\\')
+	      && n (apat, a_1, 0) == ('a' < '\\\\')
+	      && y (Apat, A01, 0) == ('A' < '\\\\')
+	      && y (apat, a01, 0) == ('a' < '\\\\')
+	      && y (Apat, bs_1, 0) == ('A' < '\\\\')
+	      && y (apat, bs_1, 0) == ('a' < '\\\\')
+	      && n (Apat, bs01, 0) == ('A' < '\\\\')
+	      && n (apat, bs01, 0) == ('a' < '\\\\')
+	      && ]m4_if([$1], [GNU],
+		   [y ("xxXX", "xXxX", FNM_CASEFOLD)
+		    && y ("a++(x|yy)b", "a+xyyyyxb", FNM_EXTMATCH)
+		    && n ("d*/*1", "d/s/1", FNM_FILE_NAME)
+		    && y ("*", "x", FNM_FILE_NAME | FNM_LEADING_DIR)
+		    && y ("x*", "x/y/z", FNM_FILE_NAME | FNM_LEADING_DIR)
+		    && y ("*c*", "c/x", FNM_FILE_NAME | FNM_LEADING_DIR)],
+		   1))[;]])],
+      [$2=yes],
+      [$2=no],
+      [$2=cross])])
+AS_IF([test $$2 = yes], [$3], [$4])
+])# _AC_FUNC_FNMATCH_IF
+
+
+# _AC_LIBOBJ_FNMATCH
+# ------------------
+# Prepare the replacement of fnmatch.
+AC_DEFUN([_AC_LIBOBJ_FNMATCH],
+[AC_REQUIRE([AC_FUNC_ALLOCA])dnl
+AC_REQUIRE([AC_TYPE_MBSTATE_T])dnl
+AC_CHECK_DECLS([isblank], [], [], [#include <ctype.h>])
+AC_CHECK_FUNCS_ONCE([btowc isblank iswctype mbsrtowcs mempcpy wmemchr wmemcpy wmempcpy])
+AC_CHECK_HEADERS_ONCE([wctype.h])
+AC_LIBOBJ([fnmatch])
+FNMATCH_H=fnmatch.h
+])# _AC_LIBOBJ_FNMATCH
+
+
+AC_DEFUN([gl_FUNC_FNMATCH_POSIX],
+[
+  FNMATCH_H=
+  _AC_FUNC_FNMATCH_IF([POSIX], [ac_cv_func_fnmatch_posix],
+		      [rm -f lib/fnmatch.h],
+		      [_AC_LIBOBJ_FNMATCH])
+  if test $ac_cv_func_fnmatch_posix != yes; then
+    dnl We must choose a different name for our function, since on ELF systems
+    dnl a broken fnmatch() in libc.so would override our fnmatch() if it is
+    dnl compiled into a shared library.
+    AC_DEFINE([fnmatch], [posix_fnmatch],
+      [Define to a replacement function name for fnmatch().])
+  fi
+  AC_SUBST([FNMATCH_H])
+])
+
+
+AC_DEFUN([gl_FUNC_FNMATCH_GNU],
+[
+  dnl Persuade glibc <fnmatch.h> to declare FNM_CASEFOLD etc.
+  AC_REQUIRE([AC_USE_SYSTEM_EXTENSIONS])
+
+  FNMATCH_H=
+  _AC_FUNC_FNMATCH_IF([GNU], [ac_cv_func_fnmatch_gnu],
+		      [rm -f lib/fnmatch.h],
+		      [_AC_LIBOBJ_FNMATCH])
+  if test $ac_cv_func_fnmatch_gnu != yes; then
+    dnl We must choose a different name for our function, since on ELF systems
+    dnl a broken fnmatch() in libc.so would override our fnmatch() if it is
+    dnl compiled into a shared library.
+    AC_DEFINE([fnmatch], [gnu_fnmatch],
+      [Define to a replacement function name for fnmatch().])
+  fi
+  AC_SUBST([FNMATCH_H])
+])
diff -urN popt-for-windows/m4/getlogin_r.m4 popt-for-windows-gnulib/m4/getlogin_r.m4
--- popt-for-windows/m4/getlogin_r.m4	1970-01-01 01:00:00.000000000 +0100
+++ popt-for-windows-gnulib/m4/getlogin_r.m4	2008-10-25 15:17:05.000000000 +0100
@@ -0,0 +1,33 @@
+#serial 4
+
+# Copyright (C) 2005, 2006, 2007 Free Software Foundation, Inc.
+#
+# This file is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+dnl From Derek Price
+dnl
+dnl Provide getlogin_r when the system lacks it.
+dnl
+
+AC_DEFUN([gl_GETLOGIN_R],
+[
+  AC_REQUIRE([gl_UNISTD_H_DEFAULTS])
+  AC_CHECK_FUNCS_ONCE([getlogin_r])
+  if test $ac_cv_func_getlogin_r = no; then
+    AC_LIBOBJ([getlogin_r])
+    gl_PREREQ_GETLOGIN_R
+    if test $ac_cv_have_decl_getlogin_r = yes; then
+      HAVE_DECL_GETLOGIN_R=1
+    else
+      HAVE_DECL_GETLOGIN_R=0
+    fi
+  fi
+])
+
+AC_DEFUN([gl_PREREQ_GETLOGIN_R],
+[
+  AC_CHECK_DECLS_ONCE([getlogin])
+  AC_CHECK_DECLS_ONCE([getlogin_r])
+])
diff -urN popt-for-windows/m4/glob.m4 popt-for-windows-gnulib/m4/glob.m4
--- popt-for-windows/m4/glob.m4	1970-01-01 01:00:00.000000000 +0100
+++ popt-for-windows-gnulib/m4/glob.m4	2008-10-25 15:17:05.000000000 +0100
@@ -0,0 +1,86 @@
+# glob.m4 serial 10
+dnl Copyright (C) 2005-2007 Free Software Foundation, Inc.
+dnl This file is free software; the Free Software Foundation
+dnl gives unlimited permission to copy and/or distribute it,
+dnl with or without modifications, as long as this notice is preserved.
+
+# The glob module assumes you want GNU glob, with glob_pattern_p etc,
+# rather than vanilla POSIX glob.  This means your code should
+# always include <glob.h> for the glob prototypes.
+
+AC_DEFUN([gl_GLOB_SUBSTITUTE],
+[
+  gl_PREREQ_GLOB
+
+  GLOB_H=glob.h
+  AC_LIBOBJ([glob])
+  AC_SUBST([GLOB_H])
+])
+
+AC_DEFUN([gl_GLOB],
+[ GLOB_H=
+  AC_CHECK_HEADERS([glob.h], [], [GLOB_H=glob.h])
+
+  if test -z "$GLOB_H"; then
+    AC_CACHE_CHECK([for GNU glob interface version 1],
+      [gl_cv_gnu_glob_interface_version_1],
+[     AC_COMPILE_IFELSE(
+[[#include <gnu-versions.h>
+char a[_GNU_GLOB_INTERFACE_VERSION == 1 ? 1 : -1];]],
+	[gl_cv_gnu_glob_interface_version_1=yes],
+	[gl_cv_gnu_glob_interface_version_1=no])])
+
+    if test "$gl_cv_gnu_glob_interface_version_1" = "no"; then
+      GLOB_H=glob.h
+    fi
+  fi
+
+  if test -z "$GLOB_H"; then
+    AC_CACHE_CHECK([whether glob lists broken symlinks],
+                   [gl_cv_glob_lists_symlinks],
+[     if ln -s conf-doesntexist conf$$-globtest 2>/dev/null; then
+        gl_cv_glob_lists_symlinks=maybe
+      else
+        # If we can't make a symlink, then we cannot test this issue.  Be
+        # pessimistic about this.
+        gl_cv_glob_lists_symlinks=no
+      fi
+
+      if test $gl_cv_glob_lists_symlinks = maybe; then
+        AC_RUN_IFELSE(
+AC_LANG_PROGRAM(
+[[#include <stddef.h>
+#include <glob.h>]],
+[[glob_t found;
+if (glob ("conf*-globtest", 0, NULL, &found) == GLOB_NOMATCH) return 1;]]),
+          [gl_cv_glob_lists_symlinks=yes],
+          [gl_cv_glob_lists_symlinks=no], [gl_cv_glob_lists_symlinks=no])
+      fi])
+
+    if test $gl_cv_glob_lists_symlinks = no; then
+      GLOB_H=glob.h
+    fi
+  fi
+
+  rm -f conf$$-globtest
+
+  if test -n "$GLOB_H"; then
+    gl_GLOB_SUBSTITUTE
+  fi
+])
+
+# Prerequisites of lib/glob.*.
+AC_DEFUN([gl_PREREQ_GLOB],
+[
+  AC_REQUIRE([gl_CHECK_TYPE_STRUCT_DIRENT_D_TYPE])dnl
+  AC_REQUIRE([AC_C_RESTRICT])dnl
+  AC_REQUIRE([AC_USE_SYSTEM_EXTENSIONS])dnl
+  AC_CHECK_HEADERS_ONCE([sys/cdefs.h unistd.h])dnl
+  if test $ac_cv_header_sys_cdefs_h = yes; then
+    HAVE_SYS_CDEFS_H=1
+  else
+    HAVE_SYS_CDEFS_H=0
+  fi
+  AC_SUBST([HAVE_SYS_CDEFS_H])
+  AC_CHECK_FUNCS_ONCE([fstatat getlogin_r getpwnam_r])dnl
+])
diff -urN popt-for-windows/m4/gnulib-common.m4 popt-for-windows-gnulib/m4/gnulib-common.m4
--- popt-for-windows/m4/gnulib-common.m4	1970-01-01 01:00:00.000000000 +0100
+++ popt-for-windows-gnulib/m4/gnulib-common.m4	2008-10-25 15:17:05.000000000 +0100
@@ -0,0 +1,101 @@
+# gnulib-common.m4 serial 6
+dnl Copyright (C) 2007-2008 Free Software Foundation, Inc.
+dnl This file is free software; the Free Software Foundation
+dnl gives unlimited permission to copy and/or distribute it,
+dnl with or without modifications, as long as this notice is preserved.
+
+# gl_COMMON
+# is expanded unconditionally through gnulib-tool magic.
+AC_DEFUN([gl_COMMON], [
+  dnl Use AC_REQUIRE here, so that the code is expanded once only.
+  AC_REQUIRE([gl_COMMON_BODY])
+])
+AC_DEFUN([gl_COMMON_BODY], [
+  AH_VERBATIM([isoc99_inline],
+[/* Work around a bug in Apple GCC 4.0.1 build 5465: In C99 mode, it supports
+   the ISO C 99 semantics of 'extern inline' (unlike the GNU C semantics of
+   earlier versions), but does not display it by setting __GNUC_STDC_INLINE__.
+   __APPLE__ && __MACH__ test for MacOS X.
+   __APPLE_CC__ tests for the Apple compiler and its version.
+   __STDC_VERSION__ tests for the C99 mode.  */
+#if defined __APPLE__ && defined __MACH__ && __APPLE_CC__ >= 5465 && !defined __cplusplus && __STDC_VERSION__ >= 199901L && !defined __GNUC_STDC_INLINE__
+# define __GNUC_STDC_INLINE__ 1
+#endif])
+  AH_VERBATIM([unused_parameter],
+[/* Define as a marker that can be attached to function parameter declarations
+   for parameters that are not used.  This helps to reduce warnings, such as
+   from GCC -Wunused-parameter.  */
+#if __GNUC__ >= 3 || (__GNUC__ == 2 && __GNUC_MINOR__ >= 7)
+# define _UNUSED_PARAMETER_ __attribute__ ((__unused__))
+#else
+# define _UNUSED_PARAMETER_
+#endif
+])
+])
+
+# gl_MODULE_INDICATOR([modulename])
+# defines a C macro indicating the presence of the given module.
+AC_DEFUN([gl_MODULE_INDICATOR],
+[
+  AC_DEFINE([GNULIB_]translit([$1],[abcdefghijklmnopqrstuvwxyz./-],[ABCDEFGHIJKLMNOPQRSTUVWXYZ___]), [1],
+    [Define to 1 when using the gnulib module ]$1[.])
+])
+
+# m4_foreach_w
+# is a backport of autoconf-2.59c's m4_foreach_w.
+# Remove this macro when we can assume autoconf >= 2.60.
+m4_ifndef([m4_foreach_w],
+  [m4_define([m4_foreach_w],
+    [m4_foreach([$1], m4_split(m4_normalize([$2]), [ ]), [$3])])])
+
+# AC_PROG_MKDIR_P
+# is a backport of autoconf-2.60's AC_PROG_MKDIR_P.
+# Remove this macro when we can assume autoconf >= 2.60.
+m4_ifdef([AC_PROG_MKDIR_P], [], [
+  AC_DEFUN([AC_PROG_MKDIR_P],
+    [AC_REQUIRE([AM_PROG_MKDIR_P])dnl defined by automake
+     MKDIR_P='$(mkdir_p)'
+     AC_SUBST([MKDIR_P])])])
+
+# AC_C_RESTRICT
+# This definition overrides the AC_C_RESTRICT macro from autoconf 2.60..2.61,
+# so that mixed use of GNU C and GNU C++ and mixed use of Sun C and Sun C++
+# works.
+# This definition can be removed once autoconf >= 2.62 can be assumed.
+AC_DEFUN([AC_C_RESTRICT],
+[AC_CACHE_CHECK([for C/C++ restrict keyword], ac_cv_c_restrict,
+  [ac_cv_c_restrict=no
+   # The order here caters to the fact that C++ does not require restrict.
+   for ac_kw in __restrict __restrict__ _Restrict restrict; do
+     AC_COMPILE_IFELSE([AC_LANG_PROGRAM(
+      [[typedef int * int_ptr;
+	int foo (int_ptr $ac_kw ip) {
+	return ip[0];
+       }]],
+      [[int s[1];
+	int * $ac_kw t = s;
+	t[0] = 0;
+	return foo(t)]])],
+      [ac_cv_c_restrict=$ac_kw])
+     test "$ac_cv_c_restrict" != no && break
+   done
+  ])
+ AH_VERBATIM([restrict],
+[/* Define to the equivalent of the C99 'restrict' keyword, or to
+   nothing if this is not supported.  Do not define if restrict is
+   supported directly.  */
+#undef restrict
+/* Work around a bug in Sun C++: it does not support _Restrict, even
+   though the corresponding Sun C compiler does, which causes
+   "#define restrict _Restrict" in the previous line.  Perhaps some future
+   version of Sun C++ will work with _Restrict; if so, it'll probably
+   define __RESTRICT, just as Sun C does.  */
+#if defined __SUNPRO_CC && !defined __RESTRICT
+# define _Restrict
+#endif])
+ case $ac_cv_c_restrict in
+   restrict) ;;
+   no) AC_DEFINE([restrict], []) ;;
+   *)  AC_DEFINE_UNQUOTED([restrict], [$ac_cv_c_restrict]) ;;
+ esac
+])
diff -urN popt-for-windows/m4/gnulib-comp.m4 popt-for-windows-gnulib/m4/gnulib-comp.m4
--- popt-for-windows/m4/gnulib-comp.m4	1970-01-01 01:00:00.000000000 +0100
+++ popt-for-windows-gnulib/m4/gnulib-comp.m4	2008-10-25 15:17:05.000000000 +0100
@@ -0,0 +1,245 @@
+# DO NOT EDIT! GENERATED AUTOMATICALLY!
+# Copyright (C) 2002-2008 Free Software Foundation, Inc.
+#
+# This file is free software, distributed under the terms of the GNU
+# General Public License.  As a special exception to the GNU General
+# Public License, this file may be distributed as part of a program
+# that contains a configuration script generated by Autoconf, under
+# the same distribution terms as the rest of that program.
+#
+# Generated by gnulib-tool.
+#
+# This file represents the compiled summary of the specification in
+# gnulib-cache.m4. It lists the computed macro invocations that need
+# to be invoked from configure.ac.
+# In projects using CVS, this file can be treated like other built files.
+
+
+# This macro should be invoked from ./configure.ac, in the section
+# "Checks for programs", right after AC_PROG_CC, and certainly before
+# any checks for libraries, header files, types and library functions.
+AC_DEFUN([gl_EARLY],
+[
+  m4_pattern_forbid([^gl_[A-Z]])dnl the gnulib macro namespace
+  m4_pattern_allow([^gl_ES$])dnl a valid locale name
+  m4_pattern_allow([^gl_LIBOBJS$])dnl a variable
+  m4_pattern_allow([^gl_LTLIBOBJS$])dnl a variable
+  AC_REQUIRE([AC_PROG_RANLIB])
+  AC_REQUIRE([gl_USE_SYSTEM_EXTENSIONS])
+])
+
+# This macro should be invoked from ./configure.ac, in the section
+# "Check for header files, types and library functions".
+AC_DEFUN([gl_INIT],
+[
+  AM_CONDITIONAL([GL_COND_LIBTOOL], [true])
+  gl_cond_libtool=true
+  m4_pushdef([AC_LIBOBJ], m4_defn([gl_LIBOBJ]))
+  m4_pushdef([AC_REPLACE_FUNCS], m4_defn([gl_REPLACE_FUNCS]))
+  m4_pushdef([AC_LIBSOURCES], m4_defn([gl_LIBSOURCES]))
+  m4_pushdef([gl_LIBSOURCES_LIST], [])
+  m4_pushdef([gl_LIBSOURCES_DIR], [])
+  gl_COMMON
+  gl_source_base='lib'
+changequote(,)dnl
+LTALLOCA=`echo "$ALLOCA" | sed 's/\.[^.]* /.lo /g;s/\.[^.]*$/.lo/'`
+changequote([, ])dnl
+AC_SUBST([LTALLOCA])
+  gl_FUNC_ALLOCA
+  gl_CHECK_TYPE_STRUCT_DIRENT_D_TYPE
+  gl_DIRENT_H
+  gl_FUNC_DIRFD
+  gl_DIRENT_MODULE_INDICATOR([dirfd])
+  # No macro. You should also use one of fnmatch-posix or fnmatch-gnu.
+  gl_GETLOGIN_R
+  gl_UNISTD_MODULE_INDICATOR([getlogin_r])
+  gl_GLOB
+  gl_FUNC_MALLOC_POSIX
+  gl_STDLIB_MODULE_INDICATOR([malloc-posix])
+  gl_FUNC_MEMPCPY
+  gl_STRING_MODULE_INDICATOR([mempcpy])
+  AM_STDBOOL_H
+  gl_STDLIB_H
+  gl_FUNC_STRDUP
+  gl_STRING_MODULE_INDICATOR([strdup])
+  gl_HEADER_STRING_H
+  gl_HEADER_SYS_STAT_H
+  AC_PROG_MKDIR_P
+  gl_UNISTD_H
+  gl_WCHAR_H
+  gl_WCTYPE_H
+  m4_ifval(gl_LIBSOURCES_LIST, [
+    m4_syscmd([test ! -d ]m4_defn([gl_LIBSOURCES_DIR])[ ||
+      for gl_file in ]gl_LIBSOURCES_LIST[ ; do
+        if test ! -r ]m4_defn([gl_LIBSOURCES_DIR])[/$gl_file ; then
+          echo "missing file ]m4_defn([gl_LIBSOURCES_DIR])[/$gl_file" >&2
+          exit 1
+        fi
+      done])dnl
+      m4_if(m4_sysval, [0], [],
+        [AC_FATAL([expected source file, required through AC_LIBSOURCES, not found])])
+  ])
+  m4_popdef([gl_LIBSOURCES_DIR])
+  m4_popdef([gl_LIBSOURCES_LIST])
+  m4_popdef([AC_LIBSOURCES])
+  m4_popdef([AC_REPLACE_FUNCS])
+  m4_popdef([AC_LIBOBJ])
+  AC_CONFIG_COMMANDS_PRE([
+    gl_libobjs=
+    gl_ltlibobjs=
+    if test -n "$gl_LIBOBJS"; then
+      # Remove the extension.
+      sed_drop_objext='s/\.o$//;s/\.obj$//'
+      for i in `for i in $gl_LIBOBJS; do echo "$i"; done | sed "$sed_drop_objext" | sort | uniq`; do
+        gl_libobjs="$gl_libobjs $i.$ac_objext"
+        gl_ltlibobjs="$gl_ltlibobjs $i.lo"
+      done
+    fi
+    AC_SUBST([gl_LIBOBJS], [$gl_libobjs])
+    AC_SUBST([gl_LTLIBOBJS], [$gl_ltlibobjs])
+  ])
+  gltests_libdeps=
+  gltests_ltlibdeps=
+  m4_pushdef([AC_LIBOBJ], m4_defn([gltests_LIBOBJ]))
+  m4_pushdef([AC_REPLACE_FUNCS], m4_defn([gltests_REPLACE_FUNCS]))
+  m4_pushdef([AC_LIBSOURCES], m4_defn([gltests_LIBSOURCES]))
+  m4_pushdef([gltests_LIBSOURCES_LIST], [])
+  m4_pushdef([gltests_LIBSOURCES_DIR], [])
+  gl_COMMON
+  gl_source_base='tests'
+  m4_ifval(gltests_LIBSOURCES_LIST, [
+    m4_syscmd([test ! -d ]m4_defn([gltests_LIBSOURCES_DIR])[ ||
+      for gl_file in ]gltests_LIBSOURCES_LIST[ ; do
+        if test ! -r ]m4_defn([gltests_LIBSOURCES_DIR])[/$gl_file ; then
+          echo "missing file ]m4_defn([gltests_LIBSOURCES_DIR])[/$gl_file" >&2
+          exit 1
+        fi
+      done])dnl
+      m4_if(m4_sysval, [0], [],
+        [AC_FATAL([expected source file, required through AC_LIBSOURCES, not found])])
+  ])
+  m4_popdef([gltests_LIBSOURCES_DIR])
+  m4_popdef([gltests_LIBSOURCES_LIST])
+  m4_popdef([AC_LIBSOURCES])
+  m4_popdef([AC_REPLACE_FUNCS])
+  m4_popdef([AC_LIBOBJ])
+  AC_CONFIG_COMMANDS_PRE([
+    gltests_libobjs=
+    gltests_ltlibobjs=
+    if test -n "$gltests_LIBOBJS"; then
+      # Remove the extension.
+      sed_drop_objext='s/\.o$//;s/\.obj$//'
+      for i in `for i in $gltests_LIBOBJS; do echo "$i"; done | sed "$sed_drop_objext" | sort | uniq`; do
+        gltests_libobjs="$gltests_libobjs $i.$ac_objext"
+        gltests_ltlibobjs="$gltests_ltlibobjs $i.lo"
+      done
+    fi
+    AC_SUBST([gltests_LIBOBJS], [$gltests_libobjs])
+    AC_SUBST([gltests_LTLIBOBJS], [$gltests_ltlibobjs])
+  ])
+])
+
+# Like AC_LIBOBJ, except that the module name goes
+# into gl_LIBOBJS instead of into LIBOBJS.
+AC_DEFUN([gl_LIBOBJ], [
+  AS_LITERAL_IF([$1], [gl_LIBSOURCES([$1.c])])dnl
+  gl_LIBOBJS="$gl_LIBOBJS $1.$ac_objext"
+])
+
+# Like AC_REPLACE_FUNCS, except that the module name goes
+# into gl_LIBOBJS instead of into LIBOBJS.
+AC_DEFUN([gl_REPLACE_FUNCS], [
+  m4_foreach_w([gl_NAME], [$1], [AC_LIBSOURCES(gl_NAME[.c])])dnl
+  AC_CHECK_FUNCS([$1], , [gl_LIBOBJ($ac_func)])
+])
+
+# Like AC_LIBSOURCES, except the directory where the source file is
+# expected is derived from the gnulib-tool parameterization,
+# and alloca is special cased (for the alloca-opt module).
+# We could also entirely rely on EXTRA_lib..._SOURCES.
+AC_DEFUN([gl_LIBSOURCES], [
+  m4_foreach([_gl_NAME], [$1], [
+    m4_if(_gl_NAME, [alloca.c], [], [
+      m4_define([gl_LIBSOURCES_DIR], [lib])
+      m4_append([gl_LIBSOURCES_LIST], _gl_NAME, [ ])
+    ])
+  ])
+])
+
+# Like AC_LIBOBJ, except that the module name goes
+# into gltests_LIBOBJS instead of into LIBOBJS.
+AC_DEFUN([gltests_LIBOBJ], [
+  AS_LITERAL_IF([$1], [gltests_LIBSOURCES([$1.c])])dnl
+  gltests_LIBOBJS="$gltests_LIBOBJS $1.$ac_objext"
+])
+
+# Like AC_REPLACE_FUNCS, except that the module name goes
+# into gltests_LIBOBJS instead of into LIBOBJS.
+AC_DEFUN([gltests_REPLACE_FUNCS], [
+  m4_foreach_w([gl_NAME], [$1], [AC_LIBSOURCES(gl_NAME[.c])])dnl
+  AC_CHECK_FUNCS([$1], , [gltests_LIBOBJ($ac_func)])
+])
+
+# Like AC_LIBSOURCES, except the directory where the source file is
+# expected is derived from the gnulib-tool parameterization,
+# and alloca is special cased (for the alloca-opt module).
+# We could also entirely rely on EXTRA_lib..._SOURCES.
+AC_DEFUN([gltests_LIBSOURCES], [
+  m4_foreach([_gl_NAME], [$1], [
+    m4_if(_gl_NAME, [alloca.c], [], [
+      m4_define([gltests_LIBSOURCES_DIR], [tests])
+      m4_append([gltests_LIBSOURCES_LIST], _gl_NAME, [ ])
+    ])
+  ])
+])
+
+# This macro records the list of files which have been installed by
+# gnulib-tool and may be removed by future gnulib-tool invocations.
+AC_DEFUN([gl_FILE_LIST], [
+  build-aux/link-warning.h
+  lib/alloca.c
+  lib/alloca.in.h
+  lib/dirent.in.h
+  lib/dirfd.c
+  lib/dummy.c
+  lib/fnmatch.c
+  lib/fnmatch.in.h
+  lib/fnmatch_loop.c
+  lib/getlogin_r.c
+  lib/glob-libc.h
+  lib/glob.c
+  lib/glob.in.h
+  lib/malloc.c
+  lib/mempcpy.c
+  lib/stdbool.in.h
+  lib/stdlib.in.h
+  lib/strdup.c
+  lib/string.in.h
+  lib/sys_stat.in.h
+  lib/unistd.in.h
+  lib/wchar.in.h
+  lib/wctype.in.h
+  m4/alloca.m4
+  m4/d-type.m4
+  m4/dirent_h.m4
+  m4/dirfd.m4
+  m4/extensions.m4
+  m4/fnmatch.m4
+  m4/getlogin_r.m4
+  m4/glob.m4
+  m4/gnulib-common.m4
+  m4/include_next.m4
+  m4/malloc.m4
+  m4/mbstate_t.m4
+  m4/mempcpy.m4
+  m4/onceonly.m4
+  m4/stdbool.m4
+  m4/stdlib_h.m4
+  m4/strdup.m4
+  m4/string_h.m4
+  m4/sys_stat_h.m4
+  m4/unistd_h.m4
+  m4/wchar.m4
+  m4/wctype.m4
+  m4/wint_t.m4
+])
diff -urN popt-for-windows/m4/gnulib-tool.m4 popt-for-windows-gnulib/m4/gnulib-tool.m4
--- popt-for-windows/m4/gnulib-tool.m4	1970-01-01 01:00:00.000000000 +0100
+++ popt-for-windows-gnulib/m4/gnulib-tool.m4	2008-10-25 15:17:05.000000000 +0100
@@ -0,0 +1,57 @@
+# gnulib-tool.m4 serial 2
+dnl Copyright (C) 2004-2005 Free Software Foundation, Inc.
+dnl This file is free software; the Free Software Foundation
+dnl gives unlimited permission to copy and/or distribute it,
+dnl with or without modifications, as long as this notice is preserved.
+
+dnl The following macros need not be invoked explicitly.
+dnl Invoking them does nothing except to declare default arguments
+dnl for "gnulib-tool --import".
+
+dnl Usage: gl_LOCAL_DIR([DIR])
+AC_DEFUN([gl_LOCAL_DIR], [])
+
+dnl Usage: gl_MODULES([module1 module2 ...])
+AC_DEFUN([gl_MODULES], [])
+
+dnl Usage: gl_AVOID([module1 module2 ...])
+AC_DEFUN([gl_AVOID], [])
+
+dnl Usage: gl_SOURCE_BASE([DIR])
+AC_DEFUN([gl_SOURCE_BASE], [])
+
+dnl Usage: gl_M4_BASE([DIR])
+AC_DEFUN([gl_M4_BASE], [])
+
+dnl Usage: gl_PO_BASE([DIR])
+AC_DEFUN([gl_PO_BASE], [])
+
+dnl Usage: gl_DOC_BASE([DIR])
+AC_DEFUN([gl_DOC_BASE], [])
+
+dnl Usage: gl_TESTS_BASE([DIR])
+AC_DEFUN([gl_TESTS_BASE], [])
+
+dnl Usage: gl_WITH_TESTS
+AC_DEFUN([gl_WITH_TESTS], [])
+
+dnl Usage: gl_LIB([LIBNAME])
+AC_DEFUN([gl_LIB], [])
+
+dnl Usage: gl_LGPL or gl_LGPL([VERSION])
+AC_DEFUN([gl_LGPL], [])
+
+dnl Usage: gl_MAKEFILE_NAME([FILENAME])
+AC_DEFUN([gl_MAKEFILE_NAME], [])
+
+dnl Usage: gl_LIBTOOL
+AC_DEFUN([gl_LIBTOOL], [])
+
+dnl Usage: gl_MACRO_PREFIX([PREFIX])
+AC_DEFUN([gl_MACRO_PREFIX], [])
+
+dnl Usage: gl_PO_DOMAIN([DOMAIN])
+AC_DEFUN([gl_PO_DOMAIN], [])
+
+dnl Usage: gl_VC_FILES([BOOLEAN])
+AC_DEFUN([gl_VC_FILES], [])
diff -urN popt-for-windows/m4/include_next.m4 popt-for-windows-gnulib/m4/include_next.m4
--- popt-for-windows/m4/include_next.m4	1970-01-01 01:00:00.000000000 +0100
+++ popt-for-windows-gnulib/m4/include_next.m4	2008-10-25 15:17:05.000000000 +0100
@@ -0,0 +1,128 @@
+# include_next.m4 serial 8
+dnl Copyright (C) 2006-2008 Free Software Foundation, Inc.
+dnl This file is free software; the Free Software Foundation
+dnl gives unlimited permission to copy and/or distribute it,
+dnl with or without modifications, as long as this notice is preserved.
+
+dnl From Paul Eggert and Derek Price.
+
+dnl Sets INCLUDE_NEXT and PRAGMA_SYSTEM_HEADER.
+dnl
+dnl INCLUDE_NEXT expands to 'include_next' if the compiler supports it, or to
+dnl 'include' otherwise.
+dnl
+dnl PRAGMA_SYSTEM_HEADER can be used in files that contain #include_next,
+dnl so as to avoid GCC warnings when the gcc option -pedantic is used.
+dnl '#pragma GCC system_header' has the same effect as if the file was found
+dnl through the include search path specified with '-isystem' options (as
+dnl opposed to the search path specified with '-I' options). Namely, gcc
+dnl does not warn about some things, and on some systems (Solaris and Interix)
+dnl __STDC__ evaluates to 0 instead of to 1. The latter is an undesired side
+dnl effect; we are therefore careful to use 'defined __STDC__' or '1' instead
+dnl of plain '__STDC__'.
+
+AC_DEFUN([gl_INCLUDE_NEXT],
+[
+  AC_LANG_PREPROC_REQUIRE()
+  AC_CACHE_CHECK([whether the preprocessor supports include_next],
+    [gl_cv_have_include_next],
+    [rm -rf conftestd1 conftestd2
+     mkdir conftestd1 conftestd2
+     dnl The include of <stdio.h> is because IBM C 9.0 on AIX 6.1 supports
+     dnl include_next when used as first preprocessor directive in a file,
+     dnl but not when preceded by another include directive.
+     cat <<EOF > conftestd1/conftest.h
+#define DEFINED_IN_CONFTESTD1
+#include <stdio.h>
+#include_next <conftest.h>
+#ifdef DEFINED_IN_CONFTESTD2
+int foo;
+#else
+#error "include_next doesn't work"
+#endif
+EOF
+     cat <<EOF > conftestd2/conftest.h
+#ifndef DEFINED_IN_CONFTESTD1
+#error "include_next test doesn't work"
+#endif
+#define DEFINED_IN_CONFTESTD2
+EOF
+     save_CPPFLAGS="$CPPFLAGS"
+     CPPFLAGS="$CPPFLAGS -Iconftestd1 -Iconftestd2"
+     AC_COMPILE_IFELSE([#include <conftest.h>],
+       [gl_cv_have_include_next=yes],
+       [gl_cv_have_include_next=no])
+     CPPFLAGS="$save_CPPFLAGS"
+     rm -rf conftestd1 conftestd2
+    ])
+  PRAGMA_SYSTEM_HEADER=
+  if test $gl_cv_have_include_next = yes; then
+    INCLUDE_NEXT=include_next
+    if test -n "$GCC"; then
+      PRAGMA_SYSTEM_HEADER='#pragma GCC system_header'
+    fi
+  else
+    INCLUDE_NEXT=include
+  fi
+  AC_SUBST([INCLUDE_NEXT])
+  AC_SUBST([PRAGMA_SYSTEM_HEADER])
+])
+
+# gl_CHECK_NEXT_HEADERS(HEADER1 HEADER2 ...)
+# ------------------------------------------
+# For each arg foo.h, if #include_next works, define NEXT_FOO_H to be
+# '<foo.h>'; otherwise define it to be
+# '"///usr/include/foo.h"', or whatever other absolute file name is suitable.
+# That way, a header file with the following line:
+#	#@INCLUDE_NEXT@ @NEXT_FOO_H@
+# behaves (after sed substitution) as if it contained
+#	#include_next <foo.h>
+# even if the compiler does not support include_next.
+# The three "///" are to pacify Sun C 5.8, which otherwise would say
+# "warning: #include of /usr/include/... may be non-portable".
+# Use `""', not `<>', so that the /// cannot be confused with a C99 comment.
+# Note: This macro assumes that the header file is not empty after
+# preprocessing, i.e. it does not only define preprocessor macros but also
+# provides some type/enum definitions or function/variable declarations.
+AC_DEFUN([gl_CHECK_NEXT_HEADERS],
+[
+  AC_REQUIRE([gl_INCLUDE_NEXT])
+  AC_CHECK_HEADERS_ONCE([$1])
+
+  m4_foreach_w([gl_HEADER_NAME], [$1],
+    [AS_VAR_PUSHDEF([gl_next_header],
+		    [gl_cv_next_]m4_quote(m4_defn([gl_HEADER_NAME])))
+     if test $gl_cv_have_include_next = yes; then
+       AS_VAR_SET([gl_next_header], ['<'gl_HEADER_NAME'>'])
+     else
+       AC_CACHE_CHECK(
+	 [absolute name of <]m4_quote(m4_defn([gl_HEADER_NAME]))[>],
+	 m4_quote(m4_defn([gl_next_header])),
+	 [AS_VAR_PUSHDEF([gl_header_exists],
+			 [ac_cv_header_]m4_quote(m4_defn([gl_HEADER_NAME])))
+	  if test AS_VAR_GET(gl_header_exists) = yes; then
+	    AC_LANG_CONFTEST(
+	      [AC_LANG_SOURCE(
+		 [[#include <]]m4_dquote(m4_defn([gl_HEADER_NAME]))[[>]]
+	       )])
+	    dnl eval is necessary to expand ac_cpp.
+	    dnl Ultrix and Pyramid sh refuse to redirect output of eval,
+	    dnl so use subshell.
+	    AS_VAR_SET([gl_next_header],
+	      ['"'`(eval "$ac_cpp conftest.$ac_ext") 2>&AS_MESSAGE_LOG_FD |
+	       sed -n '\#/]m4_quote(m4_defn([gl_HEADER_NAME]))[#{
+		 s#.*"\(.*/]m4_quote(m4_defn([gl_HEADER_NAME]))[\)".*#\1#
+		 s#^/[^/]#//&#
+		 p
+		 q
+	       }'`'"'])
+	  else
+	    AS_VAR_SET([gl_next_header], ['<'gl_HEADER_NAME'>'])
+	  fi
+	  AS_VAR_POPDEF([gl_header_exists])])
+     fi
+     AC_SUBST(
+       AS_TR_CPP([NEXT_]m4_quote(m4_defn([gl_HEADER_NAME]))),
+       [AS_VAR_GET([gl_next_header])])
+     AS_VAR_POPDEF([gl_next_header])])
+])
diff -urN popt-for-windows/m4/malloc.m4 popt-for-windows-gnulib/m4/malloc.m4
--- popt-for-windows/m4/malloc.m4	1970-01-01 01:00:00.000000000 +0100
+++ popt-for-windows-gnulib/m4/malloc.m4	2008-10-25 15:17:05.000000000 +0100
@@ -0,0 +1,41 @@
+# malloc.m4 serial 8
+dnl Copyright (C) 2007 Free Software Foundation, Inc.
+dnl This file is free software; the Free Software Foundation
+dnl gives unlimited permission to copy and/or distribute it,
+dnl with or without modifications, as long as this notice is preserved.
+
+# gl_FUNC_MALLOC_POSIX
+# --------------------
+# Test whether 'malloc' is POSIX compliant (sets errno to ENOMEM when it
+# fails), and replace malloc if it is not.
+AC_DEFUN([gl_FUNC_MALLOC_POSIX],
+[
+  AC_REQUIRE([gl_CHECK_MALLOC_POSIX])
+  if test $gl_cv_func_malloc_posix = yes; then
+    HAVE_MALLOC_POSIX=1
+    AC_DEFINE([HAVE_MALLOC_POSIX], 1,
+      [Define if the 'malloc' function is POSIX compliant.])
+  else
+    AC_LIBOBJ([malloc])
+    HAVE_MALLOC_POSIX=0
+  fi
+  AC_SUBST([HAVE_MALLOC_POSIX])
+])
+
+# Test whether malloc, realloc, calloc are POSIX compliant,
+# Set gl_cv_func_malloc_posix to yes or no accordingly.
+AC_DEFUN([gl_CHECK_MALLOC_POSIX],
+[
+  AC_CACHE_CHECK([whether malloc, realloc, calloc are POSIX compliant],
+    [gl_cv_func_malloc_posix],
+    [
+      dnl It is too dangerous to try to allocate a large amount of memory:
+      dnl some systems go to their knees when you do that. So assume that
+      dnl all Unix implementations of the function are POSIX compliant.
+      AC_TRY_COMPILE([],
+        [#if (defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__
+         choke me
+         #endif
+        ], [gl_cv_func_malloc_posix=yes], [gl_cv_func_malloc_posix=no])
+    ])
+])
diff -urN popt-for-windows/m4/mbstate_t.m4 popt-for-windows-gnulib/m4/mbstate_t.m4
--- popt-for-windows/m4/mbstate_t.m4	1970-01-01 01:00:00.000000000 +0100
+++ popt-for-windows-gnulib/m4/mbstate_t.m4	2008-10-25 15:17:05.000000000 +0100
@@ -0,0 +1,30 @@
+# mbstate_t.m4 serial 10
+dnl Copyright (C) 2000-2002, 2008 Free Software Foundation, Inc.
+dnl This file is free software; the Free Software Foundation
+dnl gives unlimited permission to copy and/or distribute it,
+dnl with or without modifications, as long as this notice is preserved.
+
+# From Paul Eggert.
+
+# BeOS 5 has <wchar.h> but does not define mbstate_t,
+# so you can't declare an object of that type.
+# Check for this incompatibility with Standard C.
+
+# AC_TYPE_MBSTATE_T
+# -----------------
+AC_DEFUN([AC_TYPE_MBSTATE_T],
+  [AC_CACHE_CHECK([for mbstate_t], ac_cv_type_mbstate_t,
+     [AC_COMPILE_IFELSE(
+	[AC_LANG_PROGRAM(
+	   [AC_INCLUDES_DEFAULT[
+#	    include <wchar.h>]],
+	   [[mbstate_t x; return sizeof x;]])],
+	[ac_cv_type_mbstate_t=yes],
+	[ac_cv_type_mbstate_t=no])])
+   if test $ac_cv_type_mbstate_t = yes; then
+     AC_DEFINE([HAVE_MBSTATE_T], 1,
+	       [Define to 1 if <wchar.h> declares mbstate_t.])
+   else
+     AC_DEFINE([mbstate_t], int,
+	       [Define to a type if <wchar.h> does not define.])
+   fi])
diff -urN popt-for-windows/m4/mempcpy.m4 popt-for-windows-gnulib/m4/mempcpy.m4
--- popt-for-windows/m4/mempcpy.m4	1970-01-01 01:00:00.000000000 +0100
+++ popt-for-windows-gnulib/m4/mempcpy.m4	2008-10-25 15:17:05.000000000 +0100
@@ -0,0 +1,26 @@
+# mempcpy.m4 serial 9
+dnl Copyright (C) 2003, 2004, 2006, 2007 Free Software Foundation, Inc.
+dnl This file is free software; the Free Software Foundation
+dnl gives unlimited permission to copy and/or distribute it,
+dnl with or without modifications, as long as this notice is preserved.
+
+AC_DEFUN([gl_FUNC_MEMPCPY],
+[
+  dnl Persuade glibc <string.h> to declare mempcpy().
+  AC_REQUIRE([AC_USE_SYSTEM_EXTENSIONS])
+
+  dnl The mempcpy() declaration in lib/string.in.h uses 'restrict'.
+  AC_REQUIRE([AC_C_RESTRICT])
+
+  AC_REQUIRE([gl_HEADER_STRING_H_DEFAULTS])
+  AC_REPLACE_FUNCS(mempcpy)
+  if test $ac_cv_func_mempcpy = no; then
+    HAVE_MEMPCPY=0
+    gl_PREREQ_MEMPCPY
+  fi
+])
+
+# Prerequisites of lib/mempcpy.c.
+AC_DEFUN([gl_PREREQ_MEMPCPY], [
+  :
+])
diff -urN popt-for-windows/m4/onceonly.m4 popt-for-windows-gnulib/m4/onceonly.m4
--- popt-for-windows/m4/onceonly.m4	1970-01-01 01:00:00.000000000 +0100
+++ popt-for-windows-gnulib/m4/onceonly.m4	2008-10-25 15:17:05.000000000 +0100
@@ -0,0 +1,90 @@
+# onceonly.m4 serial 6
+dnl Copyright (C) 2002-2003, 2005-2006, 2008 Free Software Foundation, Inc.
+dnl This file is free software, distributed under the terms of the GNU
+dnl General Public License.  As a special exception to the GNU General
+dnl Public License, this file may be distributed as part of a program
+dnl that contains a configuration script generated by Autoconf, under
+dnl the same distribution terms as the rest of that program.
+
+dnl This file defines some "once only" variants of standard autoconf macros.
+dnl   AC_CHECK_HEADERS_ONCE          like  AC_CHECK_HEADERS
+dnl   AC_CHECK_FUNCS_ONCE            like  AC_CHECK_FUNCS
+dnl   AC_CHECK_DECLS_ONCE            like  AC_CHECK_DECLS
+dnl   AC_REQUIRE([AC_FUNC_STRCOLL])  like  AC_FUNC_STRCOLL
+dnl The advantage is that the check for each of the headers/functions/decls
+dnl will be put only once into the 'configure' file. It keeps the size of
+dnl the 'configure' file down, and avoids redundant output when 'configure'
+dnl is run.
+dnl The drawback is that the checks cannot be conditionalized. If you write
+dnl   if some_condition; then gl_CHECK_HEADERS(stdlib.h); fi
+dnl inside an AC_DEFUNed function, the gl_CHECK_HEADERS macro call expands to
+dnl empty, and the check will be inserted before the body of the AC_DEFUNed
+dnl function.
+
+dnl The original code implemented AC_CHECK_HEADERS_ONCE and AC_CHECK_FUNCS_ONCE
+dnl in terms of AC_DEFUN and AC_REQUIRE. This implementation uses diversions to
+dnl named sections DEFAULTS and INIT_PREPARE in order to check all requested
+dnl headers at once, thus reducing the size of 'configure'. It is known to work
+dnl with autoconf 2.57..2.62 at least . The size reduction is ca. 9%.
+
+dnl Autoconf version 2.59 plus gnulib is required; this file is not needed
+dnl with Autoconf 2.60 or greater. But note that autoconf's implementation of
+dnl AC_CHECK_DECLS_ONCE expects a comma-separated list of symbols as first
+dnl argument!
+AC_PREREQ([2.59])
+
+# AC_CHECK_HEADERS_ONCE(HEADER1 HEADER2 ...) is a once-only variant of
+# AC_CHECK_HEADERS(HEADER1 HEADER2 ...).
+AC_DEFUN([AC_CHECK_HEADERS_ONCE], [
+  :
+  m4_foreach_w([gl_HEADER_NAME], [$1], [
+    AC_DEFUN([gl_CHECK_HEADER_]m4_quote(translit(gl_HEADER_NAME,
+                                                 [./-], [___])), [
+      m4_divert_text([INIT_PREPARE],
+        [gl_header_list="$gl_header_list gl_HEADER_NAME"])
+      gl_HEADERS_EXPANSION
+      AH_TEMPLATE(AS_TR_CPP([HAVE_]m4_defn([gl_HEADER_NAME])),
+        [Define to 1 if you have the <]m4_defn([gl_HEADER_NAME])[> header file.])
+    ])
+    AC_REQUIRE([gl_CHECK_HEADER_]m4_quote(translit(gl_HEADER_NAME,
+                                                   [./-], [___])))
+  ])
+])
+m4_define([gl_HEADERS_EXPANSION], [
+  m4_divert_text([DEFAULTS], [gl_header_list=])
+  AC_CHECK_HEADERS([$gl_header_list])
+  m4_define([gl_HEADERS_EXPANSION], [])
+])
+
+# AC_CHECK_FUNCS_ONCE(FUNC1 FUNC2 ...) is a once-only variant of
+# AC_CHECK_FUNCS(FUNC1 FUNC2 ...).
+AC_DEFUN([AC_CHECK_FUNCS_ONCE], [
+  :
+  m4_foreach_w([gl_FUNC_NAME], [$1], [
+    AC_DEFUN([gl_CHECK_FUNC_]m4_defn([gl_FUNC_NAME]), [
+      m4_divert_text([INIT_PREPARE],
+        [gl_func_list="$gl_func_list gl_FUNC_NAME"])
+      gl_FUNCS_EXPANSION
+      AH_TEMPLATE(AS_TR_CPP([HAVE_]m4_defn([gl_FUNC_NAME])),
+        [Define to 1 if you have the `]m4_defn([gl_FUNC_NAME])[' function.])
+    ])
+    AC_REQUIRE([gl_CHECK_FUNC_]m4_defn([gl_FUNC_NAME]))
+  ])
+])
+m4_define([gl_FUNCS_EXPANSION], [
+  m4_divert_text([DEFAULTS], [gl_func_list=])
+  AC_CHECK_FUNCS([$gl_func_list])
+  m4_define([gl_FUNCS_EXPANSION], [])
+])
+
+# AC_CHECK_DECLS_ONCE(DECL1 DECL2 ...) is a once-only variant of
+# AC_CHECK_DECLS(DECL1, DECL2, ...).
+AC_DEFUN([AC_CHECK_DECLS_ONCE], [
+  :
+  m4_foreach_w([gl_DECL_NAME], [$1], [
+    AC_DEFUN([gl_CHECK_DECL_]m4_defn([gl_DECL_NAME]), [
+      AC_CHECK_DECLS(m4_defn([gl_DECL_NAME]))
+    ])
+    AC_REQUIRE([gl_CHECK_DECL_]m4_defn([gl_DECL_NAME]))
+  ])
+])
diff -urN popt-for-windows/m4/stdbool.m4 popt-for-windows-gnulib/m4/stdbool.m4
--- popt-for-windows/m4/stdbool.m4	1970-01-01 01:00:00.000000000 +0100
+++ popt-for-windows-gnulib/m4/stdbool.m4	2008-10-25 15:17:05.000000000 +0100
@@ -0,0 +1,115 @@
+# Check for stdbool.h that conforms to C99.
+
+dnl Copyright (C) 2002-2006 Free Software Foundation, Inc.
+dnl This file is free software; the Free Software Foundation
+dnl gives unlimited permission to copy and/or distribute it,
+dnl with or without modifications, as long as this notice is preserved.
+
+# Prepare for substituting <stdbool.h> if it is not supported.
+
+AC_DEFUN([AM_STDBOOL_H],
+[
+  AC_REQUIRE([AC_HEADER_STDBOOL])
+
+  # Define two additional variables used in the Makefile substitution.
+
+  if test "$ac_cv_header_stdbool_h" = yes; then
+    STDBOOL_H=''
+  else
+    STDBOOL_H='stdbool.h'
+  fi
+  AC_SUBST([STDBOOL_H])
+
+  if test "$ac_cv_type__Bool" = yes; then
+    HAVE__BOOL=1
+  else
+    HAVE__BOOL=0
+  fi
+  AC_SUBST([HAVE__BOOL])
+])
+
+# AM_STDBOOL_H will be renamed to gl_STDBOOL_H in the future.
+AC_DEFUN([gl_STDBOOL_H], [AM_STDBOOL_H])
+
+# This macro is only needed in autoconf <= 2.59.  Newer versions of autoconf
+# have this macro built-in.
+
+AC_DEFUN([AC_HEADER_STDBOOL],
+  [AC_CACHE_CHECK([for stdbool.h that conforms to C99],
+     [ac_cv_header_stdbool_h],
+     [AC_TRY_COMPILE(
+	[
+	  #include <stdbool.h>
+	  #ifndef bool
+	   "error: bool is not defined"
+	  #endif
+	  #ifndef false
+	   "error: false is not defined"
+	  #endif
+	  #if false
+	   "error: false is not 0"
+	  #endif
+	  #ifndef true
+	   "error: true is not defined"
+	  #endif
+	  #if true != 1
+	   "error: true is not 1"
+	  #endif
+	  #ifndef __bool_true_false_are_defined
+	   "error: __bool_true_false_are_defined is not defined"
+	  #endif
+
+	  struct s { _Bool s: 1; _Bool t; } s;
+
+	  char a[true == 1 ? 1 : -1];
+	  char b[false == 0 ? 1 : -1];
+	  char c[__bool_true_false_are_defined == 1 ? 1 : -1];
+	  char d[(bool) 0.5 == true ? 1 : -1];
+	  bool e = &s;
+	  char f[(_Bool) 0.0 == false ? 1 : -1];
+	  char g[true];
+	  char h[sizeof (_Bool)];
+	  char i[sizeof s.t];
+	  enum { j = false, k = true, l = false * true, m = true * 256 };
+	  _Bool n[m];
+	  char o[sizeof n == m * sizeof n[0] ? 1 : -1];
+	  char p[-1 - (_Bool) 0 < 0 && -1 - (bool) 0 < 0 ? 1 : -1];
+	  #if defined __xlc__ || defined __GNUC__
+	   /* Catch a bug in IBM AIX xlc compiler version 6.0.0.0
+	      reported by James Lemley on 2005-10-05; see
+	      http://lists.gnu.org/archive/html/bug-coreutils/2005-10/msg00086.html
+	      This test is not quite right, since xlc is allowed to
+	      reject this program, as the initializer for xlcbug is
+	      not one of the forms that C requires support for.
+	      However, doing the test right would require a run-time
+	      test, and that would make cross-compilation harder.
+	      Let us hope that IBM fixes the xlc bug, and also adds
+	      support for this kind of constant expression.  In the
+	      meantime, this test will reject xlc, which is OK, since
+	      our stdbool.h substitute should suffice.  We also test
+	      this with GCC, where it should work, to detect more
+	      quickly whether someone messes up the test in the
+	      future.  */
+	   char digs[] = "0123456789";
+	   int xlcbug = 1 / (&(digs + 5)[-2 + (bool) 1] == &digs[4] ? 1 : -1);
+	  #endif
+	  /* Catch a bug in an HP-UX C compiler.  See
+	     http://gcc.gnu.org/ml/gcc-patches/2003-12/msg02303.html
+	     http://lists.gnu.org/archive/html/bug-coreutils/2005-11/msg00161.html
+	   */
+	  _Bool q = true;
+	  _Bool *pq = &q;
+	],
+	[
+	  *pq |= q;
+	  *pq |= ! q;
+	  /* Refer to every declared value, to avoid compiler optimizations.  */
+	  return (!a + !b + !c + !d + !e + !f + !g + !h + !i + !!j + !k + !!l
+		  + !m + !n + !o + !p + !q + !pq);
+	],
+	[ac_cv_header_stdbool_h=yes],
+	[ac_cv_header_stdbool_h=no])])
+   AC_CHECK_TYPES([_Bool])
+   if test $ac_cv_header_stdbool_h = yes; then
+     AC_DEFINE(HAVE_STDBOOL_H, 1, [Define to 1 if stdbool.h conforms to C99.])
+   fi])
diff -urN popt-for-windows/m4/stdlib_h.m4 popt-for-windows-gnulib/m4/stdlib_h.m4
--- popt-for-windows/m4/stdlib_h.m4	1970-01-01 01:00:00.000000000 +0100
+++ popt-for-windows-gnulib/m4/stdlib_h.m4	2008-10-25 15:17:05.000000000 +0100
@@ -0,0 +1,60 @@
+# stdlib_h.m4 serial 11
+dnl Copyright (C) 2007, 2008 Free Software Foundation, Inc.
+dnl This file is free software; the Free Software Foundation
+dnl gives unlimited permission to copy and/or distribute it,
+dnl with or without modifications, as long as this notice is preserved.
+
+AC_DEFUN([gl_STDLIB_H],
+[
+  AC_REQUIRE([gl_STDLIB_H_DEFAULTS])
+  gl_CHECK_NEXT_HEADERS([stdlib.h])
+])
+
+AC_DEFUN([gl_STDLIB_MODULE_INDICATOR],
+[
+  dnl Use AC_REQUIRE here, so that the default settings are expanded once only.
+  AC_REQUIRE([gl_STDLIB_H_DEFAULTS])
+  GNULIB_[]m4_translit([$1],[abcdefghijklmnopqrstuvwxyz./-],[ABCDEFGHIJKLMNOPQRSTUVWXYZ___])=1
+])
+
+AC_DEFUN([gl_STDLIB_H_DEFAULTS],
+[
+  GNULIB_MALLOC_POSIX=0;  AC_SUBST([GNULIB_MALLOC_POSIX])
+  GNULIB_REALLOC_POSIX=0; AC_SUBST([GNULIB_REALLOC_POSIX])
+  GNULIB_CALLOC_POSIX=0;  AC_SUBST([GNULIB_CALLOC_POSIX])
+  GNULIB_ATOLL=0;         AC_SUBST([GNULIB_ATOLL])
+  GNULIB_GETLOADAVG=0;    AC_SUBST([GNULIB_GETLOADAVG])
+  GNULIB_GETSUBOPT=0;     AC_SUBST([GNULIB_GETSUBOPT])
+  GNULIB_MKDTEMP=0;       AC_SUBST([GNULIB_MKDTEMP])
+  GNULIB_MKSTEMP=0;       AC_SUBST([GNULIB_MKSTEMP])
+  GNULIB_PUTENV=0;        AC_SUBST([GNULIB_PUTENV])
+  GNULIB_RAND48=0;        AC_SUBST([GNULIB_RAND48])
+  GNULIB_RANDOM_R=0;      AC_SUBST([GNULIB_RANDOM_R])
+  GNULIB_RPMATCH=0;       AC_SUBST([GNULIB_RPMATCH])
+  GNULIB_SETENV=0;        AC_SUBST([GNULIB_SETENV])
+  GNULIB_STRTOD=0;        AC_SUBST([GNULIB_STRTOD])
+  GNULIB_STRTOLL=0;       AC_SUBST([GNULIB_STRTOLL])
+  GNULIB_STRTOULL=0;      AC_SUBST([GNULIB_STRTOULL])
+  GNULIB_UNSETENV=0;      AC_SUBST([GNULIB_UNSETENV])
+  dnl Assume proper GNU behavior unless another module says otherwise.
+  HAVE_ATOLL=1;           AC_SUBST([HAVE_ATOLL])
+  HAVE_CALLOC_POSIX=1;    AC_SUBST([HAVE_CALLOC_POSIX])
+  HAVE_GETSUBOPT=1;       AC_SUBST([HAVE_GETSUBOPT])
+  HAVE_MALLOC_POSIX=1;    AC_SUBST([HAVE_MALLOC_POSIX])
+  HAVE_MKDTEMP=1;         AC_SUBST([HAVE_MKDTEMP])
+  HAVE_REALLOC_POSIX=1;   AC_SUBST([HAVE_REALLOC_POSIX])
+  HAVE_RAND48=1;          AC_SUBST([HAVE_RAND48])
+  HAVE_RANDOM_R=1;        AC_SUBST([HAVE_RANDOM_R])
+  HAVE_RPMATCH=1;         AC_SUBST([HAVE_RPMATCH])
+  HAVE_SETENV=1;          AC_SUBST([HAVE_SETENV])
+  HAVE_STRTOD=1;          AC_SUBST([HAVE_STRTOD])
+  HAVE_STRTOLL=1;         AC_SUBST([HAVE_STRTOLL])
+  HAVE_STRTOULL=1;        AC_SUBST([HAVE_STRTOULL])
+  HAVE_SYS_LOADAVG_H=0;   AC_SUBST([HAVE_SYS_LOADAVG_H])
+  HAVE_UNSETENV=1;        AC_SUBST([HAVE_UNSETENV])
+  HAVE_DECL_GETLOADAVG=1; AC_SUBST([HAVE_DECL_GETLOADAVG])
+  REPLACE_MKSTEMP=0;      AC_SUBST([REPLACE_MKSTEMP])
+  REPLACE_PUTENV=0;       AC_SUBST([REPLACE_PUTENV])
+  REPLACE_STRTOD=0;       AC_SUBST([REPLACE_STRTOD])
+  VOID_UNSETENV=0;        AC_SUBST([VOID_UNSETENV])
+])
diff -urN popt-for-windows/m4/strdup.m4 popt-for-windows-gnulib/m4/strdup.m4
--- popt-for-windows/m4/strdup.m4	1970-01-01 01:00:00.000000000 +0100
+++ popt-for-windows-gnulib/m4/strdup.m4	2008-10-25 15:17:05.000000000 +0100
@@ -0,0 +1,38 @@
+# strdup.m4 serial 10
+
+dnl Copyright (C) 2002-2008 Free Software Foundation, Inc.
+
+dnl This file is free software; the Free Software Foundation
+dnl gives unlimited permission to copy and/or distribute it,
+dnl with or without modifications, as long as this notice is preserved.
+
+AC_DEFUN([gl_FUNC_STRDUP],
+[
+  AC_REQUIRE([gl_HEADER_STRING_H_DEFAULTS])
+  AC_REPLACE_FUNCS(strdup)
+  AC_CHECK_DECLS_ONCE(strdup)
+  if test $ac_cv_have_decl_strdup = no; then
+    HAVE_DECL_STRDUP=0
+  fi
+  gl_PREREQ_STRDUP
+])
+
+AC_DEFUN([gl_FUNC_STRDUP_POSIX],
+[
+  AC_REQUIRE([gl_HEADER_STRING_H_DEFAULTS])
+  AC_REQUIRE([gl_CHECK_MALLOC_POSIX])
+  if test $gl_cv_func_malloc_posix != yes; then
+    REPLACE_STRDUP=1
+    AC_LIBOBJ([strdup])
+  else
+    AC_REPLACE_FUNCS(strdup)
+  fi
+  AC_CHECK_DECLS_ONCE(strdup)
+  if test $ac_cv_have_decl_strdup = no; then
+    HAVE_DECL_STRDUP=0
+  fi
+  gl_PREREQ_STRDUP
+])
+
+# Prerequisites of lib/strdup.c.
+AC_DEFUN([gl_PREREQ_STRDUP], [:])
diff -urN popt-for-windows/m4/string_h.m4 popt-for-windows-gnulib/m4/string_h.m4
--- popt-for-windows/m4/string_h.m4	1970-01-01 01:00:00.000000000 +0100
+++ popt-for-windows-gnulib/m4/string_h.m4	2008-10-25 15:17:05.000000000 +0100
@@ -0,0 +1,92 @@
+# Configure a GNU-like replacement for <string.h>.
+
+# Copyright (C) 2007, 2008 Free Software Foundation, Inc.
+# This file is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# serial 6
+
+# Written by Paul Eggert.
+
+AC_DEFUN([gl_HEADER_STRING_H],
+[
+  dnl Use AC_REQUIRE here, so that the default behavior below is expanded
+  dnl once only, before all statements that occur in other macros.
+  AC_REQUIRE([gl_HEADER_STRING_H_BODY])
+])
+
+AC_DEFUN([gl_HEADER_STRING_H_BODY],
+[
+  AC_REQUIRE([AC_C_RESTRICT])
+  AC_REQUIRE([gl_HEADER_STRING_H_DEFAULTS])
+  gl_CHECK_NEXT_HEADERS([string.h])
+])
+
+AC_DEFUN([gl_STRING_MODULE_INDICATOR],
+[
+  dnl Use AC_REQUIRE here, so that the default settings are expanded once only.
+  AC_REQUIRE([gl_HEADER_STRING_H_DEFAULTS])
+  GNULIB_[]m4_translit([$1],[abcdefghijklmnopqrstuvwxyz./-],[ABCDEFGHIJKLMNOPQRSTUVWXYZ___])=1
+])
+
+AC_DEFUN([gl_HEADER_STRING_H_DEFAULTS],
+[
+  GNULIB_MEMMEM=0;      AC_SUBST([GNULIB_MEMMEM])
+  GNULIB_MEMPCPY=0;     AC_SUBST([GNULIB_MEMPCPY])
+  GNULIB_MEMRCHR=0;     AC_SUBST([GNULIB_MEMRCHR])
+  GNULIB_RAWMEMCHR=0;   AC_SUBST([GNULIB_RAWMEMCHR])
+  GNULIB_STPCPY=0;      AC_SUBST([GNULIB_STPCPY])
+  GNULIB_STPNCPY=0;     AC_SUBST([GNULIB_STPNCPY])
+  GNULIB_STRCHRNUL=0;   AC_SUBST([GNULIB_STRCHRNUL])
+  GNULIB_STRDUP=0;      AC_SUBST([GNULIB_STRDUP])
+  GNULIB_STRNDUP=0;     AC_SUBST([GNULIB_STRNDUP])
+  GNULIB_STRNLEN=0;     AC_SUBST([GNULIB_STRNLEN])
+  GNULIB_STRPBRK=0;     AC_SUBST([GNULIB_STRPBRK])
+  GNULIB_STRSEP=0;      AC_SUBST([GNULIB_STRSEP])
+  GNULIB_STRSTR=0;      AC_SUBST([GNULIB_STRSTR])
+  GNULIB_STRCASESTR=0;  AC_SUBST([GNULIB_STRCASESTR])
+  GNULIB_STRTOK_R=0;    AC_SUBST([GNULIB_STRTOK_R])
+  GNULIB_MBSLEN=0;      AC_SUBST([GNULIB_MBSLEN])
+  GNULIB_MBSNLEN=0;     AC_SUBST([GNULIB_MBSNLEN])
+  GNULIB_MBSCHR=0;      AC_SUBST([GNULIB_MBSCHR])
+  GNULIB_MBSRCHR=0;     AC_SUBST([GNULIB_MBSRCHR])
+  GNULIB_MBSSTR=0;      AC_SUBST([GNULIB_MBSSTR])
+  GNULIB_MBSCASECMP=0;  AC_SUBST([GNULIB_MBSCASECMP])
+  GNULIB_MBSNCASECMP=0; AC_SUBST([GNULIB_MBSNCASECMP])
+  GNULIB_MBSPCASECMP=0; AC_SUBST([GNULIB_MBSPCASECMP])
+  GNULIB_MBSCASESTR=0;  AC_SUBST([GNULIB_MBSCASESTR])
+  GNULIB_MBSCSPN=0;     AC_SUBST([GNULIB_MBSCSPN])
+  GNULIB_MBSPBRK=0;     AC_SUBST([GNULIB_MBSPBRK])
+  GNULIB_MBSSPN=0;      AC_SUBST([GNULIB_MBSSPN])
+  GNULIB_MBSSEP=0;      AC_SUBST([GNULIB_MBSSEP])
+  GNULIB_MBSTOK_R=0;    AC_SUBST([GNULIB_MBSTOK_R])
+  GNULIB_STRERROR=0;    AC_SUBST([GNULIB_STRERROR])
+  GNULIB_STRSIGNAL=0;   AC_SUBST([GNULIB_STRSIGNAL])
+  GNULIB_STRVERSCMP=0;   AC_SUBST([GNULIB_STRVERSCMP])
+  dnl Assume proper GNU behavior unless another module says otherwise.
+  HAVE_DECL_MEMMEM=1;		AC_SUBST([HAVE_DECL_MEMMEM])
+  HAVE_MEMPCPY=1;		AC_SUBST([HAVE_MEMPCPY])
+  HAVE_DECL_MEMRCHR=1;		AC_SUBST([HAVE_DECL_MEMRCHR])
+  HAVE_RAWMEMCHR=1;		AC_SUBST([HAVE_RAWMEMCHR])
+  HAVE_STPCPY=1;		AC_SUBST([HAVE_STPCPY])
+  HAVE_STPNCPY=1;		AC_SUBST([HAVE_STPNCPY])
+  HAVE_STRCHRNUL=1;		AC_SUBST([HAVE_STRCHRNUL])
+  HAVE_DECL_STRDUP=1;		AC_SUBST([HAVE_DECL_STRDUP])
+  HAVE_STRNDUP=1;		AC_SUBST([HAVE_STRNDUP])
+  HAVE_DECL_STRNDUP=1;		AC_SUBST([HAVE_DECL_STRNDUP])
+  HAVE_DECL_STRNLEN=1;		AC_SUBST([HAVE_DECL_STRNLEN])
+  HAVE_STRPBRK=1;		AC_SUBST([HAVE_STRPBRK])
+  HAVE_STRSEP=1;		AC_SUBST([HAVE_STRSEP])
+  HAVE_STRCASESTR=1;		AC_SUBST([HAVE_STRCASESTR])
+  HAVE_DECL_STRTOK_R=1;		AC_SUBST([HAVE_DECL_STRTOK_R])
+  HAVE_DECL_STRERROR=1;		AC_SUBST([HAVE_DECL_STRERROR])
+  HAVE_DECL_STRSIGNAL=1;	AC_SUBST([HAVE_DECL_STRSIGNAL])
+  HAVE_STRVERSCMP=1;		AC_SUBST([HAVE_STRVERSCMP])
+  REPLACE_MEMMEM=0;		AC_SUBST([REPLACE_MEMMEM])
+  REPLACE_STRDUP=0;		AC_SUBST([REPLACE_STRDUP])
+  REPLACE_STRSTR=0;		AC_SUBST([REPLACE_STRSTR])
+  REPLACE_STRCASESTR=0;		AC_SUBST([REPLACE_STRCASESTR])
+  REPLACE_STRERROR=0;		AC_SUBST([REPLACE_STRERROR])
+  REPLACE_STRSIGNAL=0;		AC_SUBST([REPLACE_STRSIGNAL])
+])
diff -urN popt-for-windows/m4/sys_stat_h.m4 popt-for-windows-gnulib/m4/sys_stat_h.m4
--- popt-for-windows/m4/sys_stat_h.m4	1970-01-01 01:00:00.000000000 +0100
+++ popt-for-windows-gnulib/m4/sys_stat_h.m4	2008-10-25 15:17:05.000000000 +0100
@@ -0,0 +1,59 @@
+# sys_stat_h.m4 serial 10   -*- Autoconf -*-
+dnl Copyright (C) 2006-2008 Free Software Foundation, Inc.
+dnl This file is free software; the Free Software Foundation
+dnl gives unlimited permission to copy and/or distribute it,
+dnl with or without modifications, as long as this notice is preserved.
+
+dnl From Eric Blake.
+dnl Test whether <sys/stat.h> contains lstat and mkdir or must be substituted.
+
+AC_DEFUN([gl_HEADER_SYS_STAT_H],
+[
+  AC_REQUIRE([gl_SYS_STAT_H_DEFAULTS])
+
+  dnl Check for lstat.  Systems that lack it (mingw) also lack symlinks, so
+  dnl stat is a good replacement.
+  AC_CHECK_FUNCS_ONCE([lstat])
+  if test $ac_cv_func_lstat = yes; then
+    HAVE_LSTAT=1
+  else
+    HAVE_LSTAT=0
+  fi
+  AC_SUBST([HAVE_LSTAT])
+
+  dnl For the mkdir substitute.
+  AC_REQUIRE([AC_C_INLINE])
+
+  dnl Check for broken stat macros.
+  AC_REQUIRE([AC_HEADER_STAT])
+
+  gl_CHECK_NEXT_HEADERS([sys/stat.h])
+  SYS_STAT_H='sys/stat.h'
+  AC_SUBST([SYS_STAT_H])
+
+  dnl Define types that are supposed to be defined in <sys/types.h> or
+  dnl <sys/stat.h>.
+  AC_CHECK_TYPE([nlink_t], [],
+    [AC_DEFINE([nlink_t], [int],
+       [Define to the type of st_nlink in struct stat, or a supertype.])],
+    [#include <sys/types.h>
+     #include <sys/stat.h>])
+
+]) # gl_HEADER_SYS_STAT_H
+
+AC_DEFUN([gl_SYS_STAT_MODULE_INDICATOR],
+[
+  dnl Use AC_REQUIRE here, so that the default settings are expanded once only.
+  AC_REQUIRE([gl_SYS_STAT_H_DEFAULTS])
+  GNULIB_[]m4_translit([$1],[abcdefghijklmnopqrstuvwxyz./-],[ABCDEFGHIJKLMNOPQRSTUVWXYZ___])=1
+])
+
+AC_DEFUN([gl_SYS_STAT_H_DEFAULTS],
+[
+  GNULIB_LCHMOD=0; AC_SUBST([GNULIB_LCHMOD])
+  GNULIB_LSTAT=0;  AC_SUBST([GNULIB_LSTAT])
+  dnl Assume proper GNU behavior unless another module says otherwise.
+  HAVE_LCHMOD=1;   AC_SUBST([HAVE_LCHMOD])
+  REPLACE_LSTAT=0; AC_SUBST([REPLACE_LSTAT])
+  REPLACE_MKDIR=0; AC_SUBST([REPLACE_MKDIR])
+])
diff -urN popt-for-windows/m4/unistd_h.m4 popt-for-windows-gnulib/m4/unistd_h.m4
--- popt-for-windows/m4/unistd_h.m4	1970-01-01 01:00:00.000000000 +0100
+++ popt-for-windows-gnulib/m4/unistd_h.m4	2008-10-25 15:17:05.000000000 +0100
@@ -0,0 +1,81 @@
+# unistd_h.m4 serial 16
+dnl Copyright (C) 2006-2008 Free Software Foundation, Inc.
+dnl This file is free software; the Free Software Foundation
+dnl gives unlimited permission to copy and/or distribute it,
+dnl with or without modifications, as long as this notice is preserved.
+
+dnl Written by Simon Josefsson, Bruno Haible.
+
+AC_DEFUN([gl_UNISTD_H],
+[
+  dnl Use AC_REQUIRE here, so that the default behavior below is expanded
+  dnl once only, before all statements that occur in other macros.
+  AC_REQUIRE([gl_UNISTD_H_DEFAULTS])
+
+  gl_CHECK_NEXT_HEADERS([unistd.h])
+
+  AC_CHECK_HEADERS_ONCE([unistd.h])
+  if test $ac_cv_header_unistd_h = yes; then
+    HAVE_UNISTD_H=1
+  else
+    HAVE_UNISTD_H=0
+  fi
+  AC_SUBST([HAVE_UNISTD_H])
+])
+
+AC_DEFUN([gl_UNISTD_MODULE_INDICATOR],
+[
+  dnl Use AC_REQUIRE here, so that the default settings are expanded once only.
+  AC_REQUIRE([gl_UNISTD_H_DEFAULTS])
+  GNULIB_[]m4_translit([$1],[abcdefghijklmnopqrstuvwxyz./-],[ABCDEFGHIJKLMNOPQRSTUVWXYZ___])=1
+])
+
+AC_DEFUN([gl_UNISTD_H_DEFAULTS],
+[
+  GNULIB_CHOWN=0;            AC_SUBST([GNULIB_CHOWN])
+  GNULIB_CLOSE=0;            AC_SUBST([GNULIB_CLOSE])
+  GNULIB_DUP2=0;             AC_SUBST([GNULIB_DUP2])
+  GNULIB_ENVIRON=0;          AC_SUBST([GNULIB_ENVIRON])
+  GNULIB_EUIDACCESS=0;       AC_SUBST([GNULIB_EUIDACCESS])
+  GNULIB_FCHDIR=0;           AC_SUBST([GNULIB_FCHDIR])
+  GNULIB_FSYNC=0;            AC_SUBST([GNULIB_FSYNC])
+  GNULIB_FTRUNCATE=0;        AC_SUBST([GNULIB_FTRUNCATE])
+  GNULIB_GETCWD=0;           AC_SUBST([GNULIB_GETCWD])
+  GNULIB_GETDOMAINNAME=0;    AC_SUBST([GNULIB_GETDOMAINNAME])
+  GNULIB_GETDTABLESIZE=0;    AC_SUBST([GNULIB_GETDTABLESIZE])
+  GNULIB_GETHOSTNAME=0;      AC_SUBST([GNULIB_GETHOSTNAME])
+  GNULIB_GETLOGIN_R=0;       AC_SUBST([GNULIB_GETLOGIN_R])
+  GNULIB_GETPAGESIZE=0;      AC_SUBST([GNULIB_GETPAGESIZE])
+  GNULIB_GETUSERSHELL=0;     AC_SUBST([GNULIB_GETUSERSHELL])
+  GNULIB_LCHOWN=0;           AC_SUBST([GNULIB_LCHOWN])
+  GNULIB_LSEEK=0;            AC_SUBST([GNULIB_LSEEK])
+  GNULIB_READLINK=0;         AC_SUBST([GNULIB_READLINK])
+  GNULIB_SLEEP=0;            AC_SUBST([GNULIB_SLEEP])
+  GNULIB_UNISTD_H_SIGPIPE=0; AC_SUBST([GNULIB_UNISTD_H_SIGPIPE])
+  GNULIB_WRITE=0;            AC_SUBST([GNULIB_WRITE])
+  dnl Assume proper GNU behavior unless another module says otherwise.
+  HAVE_DUP2=1;            AC_SUBST([HAVE_DUP2])
+  HAVE_EUIDACCESS=1;      AC_SUBST([HAVE_EUIDACCESS])
+  HAVE_FSYNC=1;           AC_SUBST([HAVE_FSYNC])
+  HAVE_FTRUNCATE=1;       AC_SUBST([HAVE_FTRUNCATE])
+  HAVE_GETDOMAINNAME=1;   AC_SUBST([HAVE_GETDOMAINNAME])
+  HAVE_GETDTABLESIZE=1;   AC_SUBST([HAVE_GETDTABLESIZE])
+  HAVE_GETHOSTNAME=1;     AC_SUBST([HAVE_GETHOSTNAME])
+  HAVE_GETPAGESIZE=1;     AC_SUBST([HAVE_GETPAGESIZE])
+  HAVE_GETUSERSHELL=1;    AC_SUBST([HAVE_GETUSERSHELL])
+  HAVE_READLINK=1;        AC_SUBST([HAVE_READLINK])
+  HAVE_SLEEP=1;           AC_SUBST([HAVE_SLEEP])
+  HAVE_DECL_ENVIRON=1;    AC_SUBST([HAVE_DECL_ENVIRON])
+  HAVE_DECL_GETLOGIN_R=1; AC_SUBST([HAVE_DECL_GETLOGIN_R])
+  HAVE_OS_H=0;            AC_SUBST([HAVE_OS_H])
+  HAVE_SYS_PARAM_H=0;     AC_SUBST([HAVE_SYS_PARAM_H])
+  REPLACE_CHOWN=0;        AC_SUBST([REPLACE_CHOWN])
+  REPLACE_CLOSE=0;        AC_SUBST([REPLACE_CLOSE])
+  REPLACE_FCHDIR=0;       AC_SUBST([REPLACE_FCHDIR])
+  REPLACE_GETCWD=0;       AC_SUBST([REPLACE_GETCWD])
+  REPLACE_GETPAGESIZE=0;  AC_SUBST([REPLACE_GETPAGESIZE])
+  REPLACE_LCHOWN=0;       AC_SUBST([REPLACE_LCHOWN])
+  REPLACE_LSEEK=0;        AC_SUBST([REPLACE_LSEEK])
+  REPLACE_WRITE=0;        AC_SUBST([REPLACE_WRITE])
+  UNISTD_H_HAVE_WINSOCK2_H=0; AC_SUBST([UNISTD_H_HAVE_WINSOCK2_H])
+])
diff -urN popt-for-windows/m4/wchar.m4 popt-for-windows-gnulib/m4/wchar.m4
--- popt-for-windows/m4/wchar.m4	1970-01-01 01:00:00.000000000 +0100
+++ popt-for-windows-gnulib/m4/wchar.m4	2008-10-25 15:17:05.000000000 +0100
@@ -0,0 +1,69 @@
+dnl A placeholder for ISO C99 <wchar.h>, for platforms that have issues.
+
+dnl Copyright (C) 2007-2008 Free Software Foundation, Inc.
+dnl This file is free software; the Free Software Foundation
+dnl gives unlimited permission to copy and/or distribute it,
+dnl with or without modifications, as long as this notice is preserved.
+
+dnl Written by Eric Blake.
+
+# wchar.m4 serial 6
+
+AC_DEFUN([gl_WCHAR_H],
+[
+  AC_REQUIRE([gl_WCHAR_H_DEFAULTS])
+  AC_CACHE_CHECK([whether <wchar.h> is standalone],
+    [gl_cv_header_wchar_h_standalone],
+    [AC_COMPILE_IFELSE([[#include <wchar.h>
+wchar_t w;]],
+      [gl_cv_header_wchar_h_standalone=yes],
+      [gl_cv_header_wchar_h_standalone=no])])
+
+  AC_REQUIRE([gt_TYPE_WINT_T])
+  if test $gt_cv_c_wint_t = yes; then
+    HAVE_WINT_T=1
+  else
+    HAVE_WINT_T=0
+  fi
+  AC_SUBST([HAVE_WINT_T])
+
+  if test $gl_cv_header_wchar_h_standalone != yes || test $gt_cv_c_wint_t != yes; then
+    WCHAR_H=wchar.h
+  fi
+
+  dnl Prepare for creating substitute <wchar.h>.
+  dnl Do it always: WCHAR_H may be empty here but can be set later.
+  dnl Check for <wchar.h> (missing in Linux uClibc when built without wide
+  dnl character support).
+  AC_CHECK_HEADERS_ONCE([wchar.h])
+  if test $ac_cv_header_wchar_h = yes; then
+    HAVE_WCHAR_H=1
+  else
+    HAVE_WCHAR_H=0
+  fi
+  AC_SUBST([HAVE_WCHAR_H])
+  gl_CHECK_NEXT_HEADERS([wchar.h])
+])
+
+dnl Unconditionally enables the replacement of <wchar.h>.
+AC_DEFUN([gl_REPLACE_WCHAR_H],
+[
+  AC_REQUIRE([gl_WCHAR_H_DEFAULTS])
+  WCHAR_H=wchar.h
+])
+
+AC_DEFUN([gl_WCHAR_MODULE_INDICATOR],
+[
+  dnl Use AC_REQUIRE here, so that the default settings are expanded once only.
+  AC_REQUIRE([gl_WCHAR_H_DEFAULTS])
+  GNULIB_[]m4_translit([$1],[abcdefghijklmnopqrstuvwxyz./-],[ABCDEFGHIJKLMNOPQRSTUVWXYZ___])=1
+])
+
+AC_DEFUN([gl_WCHAR_H_DEFAULTS],
+[
+  GNULIB_WCWIDTH=0; AC_SUBST([GNULIB_WCWIDTH])
+  dnl Assume proper GNU behavior unless another module says otherwise.
+  HAVE_DECL_WCWIDTH=1; AC_SUBST([HAVE_DECL_WCWIDTH])
+  REPLACE_WCWIDTH=0;   AC_SUBST([REPLACE_WCWIDTH])
+  WCHAR_H='';          AC_SUBST([WCHAR_H])
+])
diff -urN popt-for-windows/m4/wctype.m4 popt-for-windows-gnulib/m4/wctype.m4
--- popt-for-windows/m4/wctype.m4	1970-01-01 01:00:00.000000000 +0100
+++ popt-for-windows-gnulib/m4/wctype.m4	2008-10-25 15:17:05.000000000 +0100
@@ -0,0 +1,74 @@
+# wctype.m4 serial 2
+
+dnl A placeholder for ISO C99 <wctype.h>, for platforms that lack it.
+
+dnl Copyright (C) 2006-2008 Free Software Foundation, Inc.
+dnl This file is free software; the Free Software Foundation
+dnl gives unlimited permission to copy and/or distribute it,
+dnl with or without modifications, as long as this notice is preserved.
+
+dnl Written by Paul Eggert.
+
+AC_DEFUN([gl_WCTYPE_H],
+[
+  AC_REQUIRE([AC_PROG_CC])
+  AC_CHECK_FUNCS_ONCE([iswcntrl])
+  if test $ac_cv_func_iswcntrl = yes; then
+    HAVE_ISWCNTRL=1
+  else
+    HAVE_ISWCNTRL=0
+  fi
+  AC_SUBST([HAVE_ISWCNTRL])
+  AC_CHECK_HEADERS_ONCE([wctype.h])
+  AC_REQUIRE([AC_C_INLINE])
+
+  AC_REQUIRE([gt_TYPE_WINT_T])
+  if test $gt_cv_c_wint_t = yes; then
+    HAVE_WINT_T=1
+  else
+    HAVE_WINT_T=0
+  fi
+  AC_SUBST([HAVE_WINT_T])
+
+  WCTYPE_H=wctype.h
+  if test $ac_cv_header_wctype_h = yes; then
+    if test $ac_cv_func_iswcntrl = yes; then
+      dnl Linux libc5 has an iswprint function that returns 0 for all arguments.
+      dnl The other functions are likely broken in the same way.
+      AC_CACHE_CHECK([whether iswcntrl works], [gl_cv_func_iswcntrl_works],
+        [
+          AC_TRY_RUN([#include <stddef.h>
+                      #include <stdio.h>
+                      #include <time.h>
+                      #include <wchar.h>
+                      #include <wctype.h>
+                      int main () { return iswprint ('x') == 0; }],
+            [gl_cv_func_iswcntrl_works=yes], [gl_cv_func_iswcntrl_works=no],
+            [AC_TRY_COMPILE([#include <stdlib.h>
+                          #if __GNU_LIBRARY__ == 1
+                          Linux libc5 i18n is broken.
+                          #endif], [],
+              [gl_cv_func_iswcntrl_works=yes], [gl_cv_func_iswcntrl_works=no])
+            ])
+        ])
+      if test $gl_cv_func_iswcntrl_works = yes; then
+        WCTYPE_H=
+      fi
+    fi
+    dnl Compute NEXT_WCTYPE_H even if WCTYPE_H is empty,
+    dnl for the benefit of builds from non-distclean directories.
+    gl_CHECK_NEXT_HEADERS([wctype.h])
+    HAVE_WCTYPE_H=1
+  else
+    HAVE_WCTYPE_H=0
+  fi
+  AC_SUBST([HAVE_WCTYPE_H])
+  AC_SUBST([WCTYPE_H])
+
+  if test "$gl_cv_func_iswcntrl_works" = no; then
+    REPLACE_ISWCNTRL=1
+  else
+    REPLACE_ISWCNTRL=0
+  fi
+  AC_SUBST([REPLACE_ISWCNTRL])
+])
diff -urN popt-for-windows/m4/wint_t.m4 popt-for-windows-gnulib/m4/wint_t.m4
--- popt-for-windows/m4/wint_t.m4	1970-01-01 01:00:00.000000000 +0100
+++ popt-for-windows-gnulib/m4/wint_t.m4	2008-10-25 15:17:05.000000000 +0100
@@ -0,0 +1,28 @@
+# wint_t.m4 serial 2 (gettext-0.17)
+dnl Copyright (C) 2003, 2007 Free Software Foundation, Inc.
+dnl This file is free software; the Free Software Foundation
+dnl gives unlimited permission to copy and/or distribute it,
+dnl with or without modifications, as long as this notice is preserved.
+
+dnl From Bruno Haible.
+dnl Test whether <wchar.h> has the 'wint_t' type.
+dnl Prerequisite: AC_PROG_CC
+
+AC_DEFUN([gt_TYPE_WINT_T],
+[
+  AC_CACHE_CHECK([for wint_t], gt_cv_c_wint_t,
+    [AC_TRY_COMPILE([
+/* Tru64 with Desktop Toolkit C has a bug: <stdio.h> must be included before
+   <wchar.h>.
+   BSD/OS 4.0.1 has a bug: <stddef.h>, <stdio.h> and <time.h> must be included
+   before <wchar.h>.  */
+#include <stddef.h>
+#include <stdio.h>
+#include <time.h>
+#include <wchar.h>
+       wint_t foo = (wchar_t)'\0';], ,
+       gt_cv_c_wint_t=yes, gt_cv_c_wint_t=no)])
+  if test $gt_cv_c_wint_t = yes; then
+    AC_DEFINE(HAVE_WINT_T, 1, [Define if you have the 'wint_t' type.])
+  fi
+])
