diff -r 47135c91cd9c src/vncdisplay.c
--- a/src/vncdisplay.c	Thu Oct 09 11:23:09 2008 -0400
+++ b/src/vncdisplay.c	Wed Oct 29 14:52:36 2008 +0000
@@ -29,6 +29,13 @@
 #ifdef HAVE_PWD_H
 #include <pwd.h>
 #endif
+
+#ifdef HAVE_WINSOCK2_H
+#include <winsock2.h>
+#endif
+
+static void winsock_startup (void);
+static void winsock_cleanup (void);
 
 #define VNC_DISPLAY_GET_PRIVATE(obj) \
       (G_TYPE_INSTANCE_GET_PRIVATE((obj), VNC_TYPE_DISPLAY, VncDisplayPrivate))
@@ -243,6 +250,7 @@
 
 GtkWidget *vnc_display_new(void)
 {
+	winsock_startup ();
 	return GTK_WIDGET(g_object_new(VNC_TYPE_DISPLAY, NULL));
 }
 
@@ -1255,6 +1263,9 @@
 	}
 
 	g_object_unref(G_OBJECT(data));
+
+	winsock_cleanup ();
+
 	return FALSE;
 }
 
@@ -2188,6 +2199,49 @@
   return group;
 }
 
+#ifdef WIN32
+
+/* On Windows, we must call WSAStartup before using any sockets and we
+ * must call WSACleanup afterwards.  And we have to balance any calls
+ * to WSAStartup with a corresponding call to WSACleanup.
+ *
+ * Note that Wine lets you do socket calls anyway, but real Windows
+ * doesn't. (http://bugs.winehq.org/show_bug.cgi?id=11965)
+ */
+
+static void
+winsock_startup (void)
+{
+	WORD winsock_version, err;
+	WSADATA winsock_data;
+
+	/* http://msdn2.microsoft.com/en-us/library/ms742213.aspx */
+	winsock_version = MAKEWORD (2, 2);
+	err = WSAStartup (winsock_version, &winsock_data);
+	if (err != 0)
+		GVNC_DEBUG ("ignored error %d from WSAStartup", err);
+}
+
+static void
+winsock_cleanup (void)
+{
+	WSACleanup ();
+}
+
+#else /* !WIN32 */
+
+static void
+winsock_startup (void)
+{
+}
+
+static void
+winsock_cleanup (void)
+{
+}
+
+#endif /* !WIN32 */
+
 /*
  * Local variables:
  *  c-indent-level: 8
